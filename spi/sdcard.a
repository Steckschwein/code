*=$1000
!src "../bios/defs.h.a"
!src "../bios/bios.h.a"

!macro SDCommand .cmd, .numres {
	ldx #$00
-	lda .cmd,x
	
	jsr spi_rw_byte
	
	inx
	cpx #$06
	bne -

	lda #$ff
	jsr spi_rw_byte		; byte lesen

;	ldy #$00
	ldx #$00
-		
	lda #$ff
	jsr spi_rw_byte		; byte lesen

 	; cpy #$00 			; y=0?
 	; bne +				; nein, dann weiter
 	; cmp #$ff			; ja, dann gelesenes byte=$FF?
 	; beq -				; ja, dann nochmal lesen
+	sta sdcmdres,x		; 
 	inx
;	iny
 	cpx #.numres
 	bne -
}


!macro PrintSDRes .numres { 
	pha
	phx

	lda #'['
	jsr lcdprint
	ldx #$00
-	lda sdcmdres, x
	jsr lcdhex
	inx
	cpx #.numres
	bne -

	lda #']'
	jsr lcdprint

	pla
	plx
}



; sdcard pin assignment:
; SD   | Signal 		| VIA Port
;   1  |    /CS 		|          PB1
;   2  | CMD/DI (mosi)		|          CB2
;   5  |    CLK 		|	   PB0/CB1
;   7  | DAT/DO 		|          PB7

; outb 	= $f0
; inb		= $f1
;sdcmdres	= $e0

	jsr lcdclear
	sei

	; SR shift in, External clock on CB1
	; lda #%00001100
	; sta via1acr

	; lda #$ff
	; sta via1ddrb

	; lda #%01111110
	; sta via1portb



	ldx #74

	lda #%11111110
	sta via1portb
	tay
	iny
-	sty via1portb
	sta via1portb
	dex
	bne -



	; set CS line to LOW
	lda #%11111101
	and via1portb	
	sta via1portb
	


	; send CMD0 - init SD card to SPI mode
	+SDCommand cmd0, $01
	
	lda sdcmdres
	cmp #$01
	beq +
	
	+PrintString nocard	
-	jmp -

+	+PrintString cardok	

	+SDCommand cmd8, $01
	+PrintSDRes $01

		
-	jmp -			
	+SDCommand cmd55, $01
!for	j,0,10 	{
	lda #$ff
	jsr spi_rw_byte
	jsr lcdhex
} 
-	jmp -			
	
	
	+SDCommand acmd41, $01
	
	+PrintSDRes $01

	; lda #'B'
	; jsr lcdprint

	; +SDCommand cmd16, $01
	; +PrintSDRes $01

	; lda #' '
	; jsr lcdprint


-	jmp -			
	jmp upload

; Transmit byte VIA SPI
; Byte to transmit in A, received byte in A at exit

; spi_rw_byte
; 	phx
; 	phy

; 	sta tmp0	; zu transferierendes byte im akku nach tmp0 retten

; 	ldx #$08
	
; 	lda via1portb	; Port laden
; 	and #$fe        ; SPICLK loeschen

; 	asl		; Nach links rotieren, damit das bit nachher an der richtigen stelle steht
; 	tay		 ; bunkern

; -	
; 	rol tmp0
; 	tya		; portinhalt
; 	ror		; datenbit reinschieben

; 	sta via1portb	; ab in den port
; 	inc via1portb	; takt an
; 	sta via1portb	; takt aus 

; 	dex
; 	bne -		; schon acht mal?
	
; 	lda via1sr	; Schieberegister auslesen

; 	ply
; 	plx
; 	rts
	
; spi_r_byte
;        phy
;        lda via1portb   ; Port laden
;        AND #$7e  ;    * Daten und Takt ausschalten
;        TAY             ; aufheben
;        ORA #$01

;        STA via1portb ; Takt An 1
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 2
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 3
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 4
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 5
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 6
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 7
;        STY via1portb ; Takt aus
;        STA via1portb ; Takt An 8
;        STY via1portb ; Takt aus

;        lda via1sr
;        ply
;        rts

; ; Transmit byte VIA SPI
; ; Byte to transmit in A, received byte in A at exit
; spi_rw_byte	
; 	phx
; 	phy
; 	ldx #$08
; 	clc
; --
; 	asl

; 	tay
; 	bcs one

; zero	
; 	lda #%01111111
; 	and via1portb
; 	sta via1portb
; 	bra clk

; one	lda #%10000000
; 	ora via1portb	
; 	sta via1portb
	
; clk
; 	inc via1portb
; 	tya
; 	dec via1portb

; 	dex
; 	bne --
; 	lda via1sr
; 	ply
; 	plx
; 	rts

; cmd0 reset card to IDLE state
cmd0	!byte %01000000, %00000000, %00000000, %00000000, %00000000, %10010101
; cmd8 Sends SD Memory Card interface condition (old)
cmd8 	!byte %01001000, %00000000, %00000000, %00000001, %10101010, %00001111
; cmd58 Sends SD Memory Card interface condition
cmd58	!byte %01111010, %00000000, %00000000, %00000000, %00000000, %01110101
; cmd55
cmd55	!byte $77, $00, $00, $00, $00, $01
; acmd41
acmd41  !byte $69, $00, $00, $00, $00, $01
; cmd16 SET_BLOCKLEN
cmd16	!byte $50, $00, $00, $02, $00, $01


cardok	!text "Card OK!", $00
nocard	!text "No Card!", $00
