
keyboard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000548  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000548  000005dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  00800062  00800062  000005de  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  000005de  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000e8  00000000  00000000  000005f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000977  00000000  00000000  000006d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003d6  00000000  00000000  0000104f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000440  00000000  00000000  00001425  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000011c  00000000  00000000  00001868  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000243  00000000  00000000  00001984  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000004b9  00000000  00000000  00001bc7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  00002080  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	d5 c0       	rjmp	.+426    	; 0x1ac <__ctors_end>
   2:	e9 c1       	rjmp	.+978    	; 0x3d6 <__vector_1>
   4:	ec c0       	rjmp	.+472    	; 0x1de <__bad_interrupt>
   6:	eb c0       	rjmp	.+470    	; 0x1de <__bad_interrupt>
   8:	ea c0       	rjmp	.+468    	; 0x1de <__bad_interrupt>
   a:	e9 c0       	rjmp	.+466    	; 0x1de <__bad_interrupt>
   c:	e8 c0       	rjmp	.+464    	; 0x1de <__bad_interrupt>
   e:	e7 c0       	rjmp	.+462    	; 0x1de <__bad_interrupt>
  10:	e6 c0       	rjmp	.+460    	; 0x1de <__bad_interrupt>
  12:	e5 c0       	rjmp	.+458    	; 0x1de <__bad_interrupt>
  14:	e4 c0       	rjmp	.+456    	; 0x1de <__bad_interrupt>
  16:	e3 c0       	rjmp	.+454    	; 0x1de <__bad_interrupt>
  18:	e2 c0       	rjmp	.+452    	; 0x1de <__bad_interrupt>
  1a:	e1 c0       	rjmp	.+450    	; 0x1de <__bad_interrupt>
  1c:	e0 c0       	rjmp	.+448    	; 0x1de <__bad_interrupt>
  1e:	df c0       	rjmp	.+446    	; 0x1de <__bad_interrupt>
  20:	de c0       	rjmp	.+444    	; 0x1de <__bad_interrupt>
  22:	dd c0       	rjmp	.+442    	; 0x1de <__bad_interrupt>
  24:	dc c0       	rjmp	.+440    	; 0x1de <__bad_interrupt>

00000026 <__trampolines_end>:
  26:	01 88       	ldd	r0, Z+17	; 0x11
  28:	99 b9       	out	0x09, r25	; 9
  2a:	a9 03       	fmulsu	r18, r17
  2c:	84 95       	.word	0x9584	; ????
  2e:	b5 a5       	ldd	r27, Z+45	; 0x2d
  30:	04 82       	std	Z+4, r0	; 0x04
  32:	93 b3       	in	r25, 0x13	; 19
  34:	a3 05       	cpc	r26, r3
  36:	81 91       	ld	r24, Z+
  38:	b1 a1       	ldd	r27, Z+33	; 0x21
  3a:	06 81       	ldd	r16, Z+6	; 0x06
  3c:	92 b2       	in	r9, 0x12	; 18
  3e:	a2 07       	cpc	r26, r18
  40:	8c 9c       	mul	r8, r12
  42:	bc ac       	ldd	r11, Y+60	; 0x3c
  44:	09 8a       	std	Y+17, r0	; 0x11
  46:	9a ba       	out	0x1a, r9	; 26
  48:	aa 0a       	sbc	r10, r26
  4a:	87 98       	cbi	0x10, 7	; 16
  4c:	b8 a8       	ldd	r11, Y+48	; 0x30
  4e:	0b 85       	ldd	r16, Y+11	; 0x0b
  50:	96 b6       	in	r9, 0x36	; 54
  52:	a6 0c       	add	r10, r6
  54:	83 94       	inc	r8
  56:	b4 a4       	ldd	r11, Z+44	; 0x2c
  58:	0d 09       	sbc	r16, r13
  5a:	09 00       	.word	0x0009	; ????
  5c:	00 0e       	add	r0, r16
  5e:	5e b0       	in	r5, 0x0e	; 14
  60:	00 00       	nop
  62:	15 71       	andi	r17, 0x15	; 21
  64:	51 11       	cpse	r21, r1
  66:	00 16       	cp	r0, r16
  68:	31 21       	and	r19, r1
  6a:	00 00       	nop
  6c:	1a 79       	andi	r17, 0x9A	; 154
  6e:	59 19       	sub	r21, r9
  70:	00 1b       	sub	r16, r16
  72:	73 53       	subi	r23, 0x33	; 51
  74:	13 00       	.word	0x0013	; ????
  76:	1c 61       	ori	r17, 0x1C	; 28
  78:	41 01       	movw	r8, r2
  7a:	00 1d       	adc	r16, r0
  7c:	77 57       	subi	r23, 0x77	; 119
  7e:	17 00       	.word	0x0017	; ????
  80:	1e 32       	cpi	r17, 0x2E	; 46
  82:	22 00       	.word	0x0022	; ????
  84:	00 1f       	adc	r16, r16
  86:	b0 b0       	in	r11, 0x00	; 0
  88:	b0 b0       	in	r11, 0x00	; 0
  8a:	21 63       	ori	r18, 0x31	; 49
  8c:	43 03       	mulsu	r20, r19
  8e:	00 22       	and	r0, r16
  90:	78 58       	subi	r23, 0x88	; 136
  92:	18 00       	.word	0x0018	; ????
  94:	23 64       	ori	r18, 0x43	; 67
  96:	44 04       	cpc	r4, r4
  98:	00 24       	eor	r0, r0
  9a:	65 45       	sbci	r22, 0x55	; 85
  9c:	05 00       	.word	0x0005	; ????
  9e:	25 34       	cpi	r18, 0x45	; 69
  a0:	24 00       	.word	0x0024	; ????
  a2:	00 26       	eor	r0, r16
  a4:	33 a7       	std	Z+43, r19	; 0x2b
  a6:	00 00       	nop
  a8:	29 20       	and	r2, r9
  aa:	20 20       	and	r2, r0
  ac:	20 2a       	or	r2, r16
  ae:	76 56       	subi	r23, 0x66	; 102
  b0:	16 00       	.word	0x0016	; ????
  b2:	2b 66       	ori	r18, 0x6B	; 107
  b4:	46 06       	cpc	r4, r22
  b6:	00 2c       	mov	r0, r0
  b8:	74 54       	subi	r23, 0x44	; 68
  ba:	14 00       	.word	0x0014	; ????
  bc:	2d 72       	andi	r18, 0x2D	; 45
  be:	52 12       	cpse	r5, r18
  c0:	00 2e       	mov	r0, r16
  c2:	35 25       	eor	r19, r5
  c4:	00 00       	nop
  c6:	2f af       	std	Y+63, r18	; 0x3f
  c8:	af af       	std	Y+63, r26	; 0x3f
  ca:	af 31       	cpi	r26, 0x1F	; 31
  cc:	6e 4e       	sbci	r22, 0xEE	; 238
  ce:	0e 00       	.word	0x000e	; ????
  d0:	32 62       	ori	r19, 0x22	; 34
  d2:	42 02       	muls	r20, r18
  d4:	00 33       	cpi	r16, 0x30	; 48
  d6:	68 48       	sbci	r22, 0x88	; 136
  d8:	08 00       	.word	0x0008	; ????
  da:	34 67       	ori	r19, 0x74	; 116
  dc:	47 07       	cpc	r20, r23
  de:	00 35       	cpi	r16, 0x50	; 80
  e0:	7a 5a       	subi	r23, 0xAA	; 170
  e2:	1a 00       	.word	0x001a	; ????
  e4:	36 36       	cpi	r19, 0x66	; 102
  e6:	26 00       	.word	0x0026	; ????
  e8:	00 3a       	cpi	r16, 0xA0	; 160
  ea:	6d 4d       	sbci	r22, 0xDD	; 221
  ec:	0d 00       	.word	0x000d	; ????
  ee:	3b 6a       	ori	r19, 0xAB	; 171
  f0:	4a 0a       	sbc	r4, r26
  f2:	00 3c       	cpi	r16, 0xC0	; 192
  f4:	75 55       	subi	r23, 0x55	; 85
  f6:	15 00       	.word	0x0015	; ????
  f8:	3d 37       	cpi	r19, 0x7D	; 125
  fa:	2f 00       	.word	0x002f	; ????
  fc:	00 3e       	cpi	r16, 0xE0	; 224
  fe:	38 28       	or	r3, r8
 100:	00 00       	nop
 102:	41 2c       	mov	r4, r1
 104:	3b 00       	.word	0x003b	; ????
 106:	00 42       	sbci	r16, 0x20	; 32
 108:	6b 4b       	sbci	r22, 0xBB	; 187
 10a:	0b 00       	.word	0x000b	; ????
 10c:	43 69       	ori	r20, 0x93	; 147
 10e:	49 09       	sbc	r20, r9
 110:	00 44       	sbci	r16, 0x40	; 64
 112:	6f 4f       	sbci	r22, 0xFF	; 255
 114:	0f 00       	.word	0x000f	; ????
 116:	45 30       	cpi	r20, 0x05	; 5
 118:	3d 00       	.word	0x003d	; ????
 11a:	00 46       	sbci	r16, 0x60	; 96
 11c:	39 29       	or	r19, r9
 11e:	00 00       	nop
 120:	49 2e       	mov	r4, r25
 122:	3a 00       	.word	0x003a	; ????
 124:	00 4a       	sbci	r16, 0xA0	; 160
 126:	2d 5f       	subi	r18, 0xFD	; 253
 128:	00 00       	nop
 12a:	4b 6c       	ori	r20, 0xCB	; 203
 12c:	4c 0c       	add	r4, r12
 12e:	00 4c       	sbci	r16, 0xC0	; 192
 130:	f6 d6       	rcall	.+3564   	; 0xf1e <__data_load_end+0x9d4>
 132:	00 00       	nop
 134:	4d 70       	andi	r20, 0x0D	; 13
 136:	50 10       	cpse	r5, r0
 138:	00 4e       	sbci	r16, 0xE0	; 224
 13a:	df 3f       	cpi	r29, 0xFF	; 255
 13c:	00 5c       	subi	r16, 0xC0	; 192
 13e:	52 e4       	ldi	r21, 0x42	; 66
 140:	c4 00       	.word	0x00c4	; ????
 142:	00 54       	subi	r16, 0x40	; 64
 144:	fc dc       	rcall	.-1544   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
 146:	00 00       	nop
 148:	55 b4       	in	r5, 0x25	; 37
 14a:	60 00       	.word	0x0060	; ????
 14c:	00 58       	subi	r16, 0x80	; 128
 14e:	ff ff       	.word	0xffff	; ????
 150:	ff ff       	.word	0xffff	; ????
 152:	5a 0d       	add	r21, r10
 154:	0d 0d       	add	r16, r13
 156:	0d 5b       	subi	r16, 0xBD	; 189
 158:	2b 2a       	or	r2, r27
 15a:	00 7e       	andi	r16, 0xE0	; 224
 15c:	5d 23       	and	r21, r29
 15e:	27 00       	.word	0x0027	; ????
 160:	00 61       	ori	r16, 0x10	; 16
 162:	3c 3e       	cpi	r19, 0xEC	; 236
 164:	00 7c       	andi	r16, 0xC0	; 192
 166:	66 08       	sbc	r6, r6
 168:	ae 8f       	std	Y+30, r26	; 0x1e
 16a:	00 69       	ori	r16, 0x90	; 144
 16c:	c7 cf       	rjmp	.-114    	; 0xfc <__stack+0x1d>
 16e:	cf 00       	.word	0x00cf	; ????
 170:	6b c2       	rjmp	.+1238   	; 0x648 <__data_load_end+0xfe>
 172:	ca ca       	rjmp	.-2668   	; 0xfffff708 <__eeprom_end+0xff7ef708>
 174:	00 6c       	ori	r16, 0xC0	; 192
 176:	c6 ce       	rjmp	.-628    	; 0xffffff04 <__eeprom_end+0xff7eff04>
 178:	ce 00       	.word	0x00ce	; ????
 17a:	70 bd       	out	0x20, r23	; 32
 17c:	ad 8d       	ldd	r26, Y+29	; 0x1d
 17e:	00 71       	andi	r16, 0x10	; 16
 180:	be ae       	std	Y+62, r11	; 0x3e
 182:	8e 00       	.word	0x008e	; ????
 184:	72 c1       	rjmp	.+740    	; 0x46a <__vector_1+0x94>
 186:	c9 c9       	rjmp	.-3182   	; 0xfffff51a <__eeprom_end+0xff7ef51a>
 188:	00 74       	andi	r16, 0x40	; 64
 18a:	c3 cb       	rjmp	.-2170   	; 0xfffff912 <__eeprom_end+0xff7ef912>
 18c:	cb 00       	.word	0x00cb	; ????
 18e:	75 c0       	rjmp	.+234    	; 0x27a <putKey+0x3a>
 190:	c8 c8       	rjmp	.-3696   	; 0xfffff322 <__eeprom_end+0xff7ef322>
 192:	00 76       	andi	r16, 0x60	; 96
 194:	1b 1b       	sub	r17, r27
 196:	a0 00       	.word	0x00a0	; ????
 198:	78 8b       	std	Y+16, r23	; 0x10
 19a:	9b bb       	out	0x1b, r25	; 27
 19c:	ab 7a       	andi	r26, 0xAB	; 171
 19e:	c5 cd       	rjmp	.-1142   	; 0xfffffd2a <__eeprom_end+0xff7efd2a>
 1a0:	cd 00       	.word	0x00cd	; ????
 1a2:	7d c4       	rjmp	.+2298   	; 0xa9e <__data_load_end+0x554>
 1a4:	cc cc       	rjmp	.-1640   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
 1a6:	00 83       	st	Z, r16
 1a8:	86 97       	sbiw	r24, 0x26	; 38
 1aa:	b7 a7       	std	Z+47, r27	; 0x2f

000001ac <__ctors_end>:
 1ac:	11 24       	eor	r1, r1
 1ae:	1f be       	out	0x3f, r1	; 63
 1b0:	cf ed       	ldi	r28, 0xDF	; 223
 1b2:	cd bf       	out	0x3d, r28	; 61

000001b4 <__do_copy_data>:
 1b4:	10 e0       	ldi	r17, 0x00	; 0
 1b6:	a0 e6       	ldi	r26, 0x60	; 96
 1b8:	b0 e0       	ldi	r27, 0x00	; 0
 1ba:	e8 e4       	ldi	r30, 0x48	; 72
 1bc:	f5 e0       	ldi	r31, 0x05	; 5
 1be:	02 c0       	rjmp	.+4      	; 0x1c4 <__do_copy_data+0x10>
 1c0:	05 90       	lpm	r0, Z+
 1c2:	0d 92       	st	X+, r0
 1c4:	a2 36       	cpi	r26, 0x62	; 98
 1c6:	b1 07       	cpc	r27, r17
 1c8:	d9 f7       	brne	.-10     	; 0x1c0 <__do_copy_data+0xc>

000001ca <__do_clear_bss>:
 1ca:	20 e0       	ldi	r18, 0x00	; 0
 1cc:	a2 e6       	ldi	r26, 0x62	; 98
 1ce:	b0 e0       	ldi	r27, 0x00	; 0
 1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <.do_clear_bss_start>

000001d2 <.do_clear_bss_loop>:
 1d2:	1d 92       	st	X+, r1

000001d4 <.do_clear_bss_start>:
 1d4:	a7 37       	cpi	r26, 0x77	; 119
 1d6:	b2 07       	cpc	r27, r18
 1d8:	e1 f7       	brne	.-8      	; 0x1d2 <.do_clear_bss_loop>
 1da:	8f d1       	rcall	.+798    	; 0x4fa <main>
 1dc:	b3 c1       	rjmp	.+870    	; 0x544 <_exit>

000001de <__bad_interrupt>:
 1de:	10 cf       	rjmp	.-480    	; 0x0 <__vectors>

000001e0 <pump>:
#include "keyboard.h"
#include "keycodes.h"

void pump(uint8_t b)
{
	uint8_t bit=7;
 1e0:	47 e0       	ldi	r20, 0x07	; 7

	do
	{
		if (b & _BV(bit))
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	9c 01       	movw	r18, r24
 1e6:	04 2e       	mov	r0, r20
 1e8:	02 c0       	rjmp	.+4      	; 0x1ee <pump+0xe>
 1ea:	35 95       	asr	r19
 1ec:	27 95       	ror	r18
 1ee:	0a 94       	dec	r0
 1f0:	e2 f7       	brpl	.-8      	; 0x1ea <pump+0xa>
 1f2:	20 ff       	sbrs	r18, 0
 1f4:	02 c0       	rjmp	.+4      	; 0x1fa <pump+0x1a>
		{
			PORTA |= _BV(1);
 1f6:	d9 9a       	sbi	0x1b, 1	; 27
 1f8:	01 c0       	rjmp	.+2      	; 0x1fc <pump+0x1c>
		}
		else
		{
			PORTA &= ~_BV(1);
 1fa:	d9 98       	cbi	0x1b, 1	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1fc:	ef e0       	ldi	r30, 0x0F	; 15
 1fe:	f7 e2       	ldi	r31, 0x27	; 39
 200:	31 97       	sbiw	r30, 0x01	; 1
 202:	f1 f7       	brne	.-4      	; 0x200 <pump+0x20>
 204:	00 c0       	rjmp	.+0      	; 0x206 <pump+0x26>
 206:	00 00       	nop
		}
		
	;	_delay_ms(5);
		PORTA |= _BV(0);
 208:	d8 9a       	sbi	0x1b, 0	; 27
 20a:	ef e0       	ldi	r30, 0x0F	; 15
 20c:	f7 e2       	ldi	r31, 0x27	; 39
 20e:	31 97       	sbiw	r30, 0x01	; 1
 210:	f1 f7       	brne	.-4      	; 0x20e <pump+0x2e>
 212:	00 c0       	rjmp	.+0      	; 0x214 <pump+0x34>
 214:	00 00       	nop
	;	_delay_ms(5);
		PORTA &= ~_BV(0);
 216:	d8 98       	cbi	0x1b, 0	; 27
	
	}
	while(bit-- > 0);
 218:	41 50       	subi	r20, 0x01	; 1
 21a:	20 f7       	brcc	.-56     	; 0x1e4 <pump+0x4>
}	
 21c:	08 95       	ret

0000021e <parityGenerator>:
volatile unsigned char data;

void parityGenerator( unsigned char value )
{
	char loopCount = 8;
	while (--loopCount)
 21e:	98 e0       	ldi	r25, 0x08	; 8
 220:	91 50       	subi	r25, 0x01	; 1
 222:	39 f0       	breq	.+14     	; 0x232 <parityGenerator+0x14>
	{
		_parity += value;
 224:	20 91 76 00 	lds	r18, 0x0076
 228:	28 0f       	add	r18, r24
 22a:	20 93 76 00 	sts	0x0076, r18
		value >>= 1;
 22e:	86 95       	lsr	r24
 230:	f7 cf       	rjmp	.-18     	; 0x220 <parityGenerator+0x2>
	}
	_parity ^= 1;
 232:	80 91 76 00 	lds	r24, 0x0076
 236:	91 e0       	ldi	r25, 0x01	; 1
 238:	89 27       	eor	r24, r25
 23a:	80 93 76 00 	sts	0x0076, r24
 23e:	08 95       	ret

00000240 <putKey>:
}

void putKey( unsigned char key )
{
	*inPtr = key;
 240:	e0 91 6c 00 	lds	r30, 0x006C
 244:	f0 91 6d 00 	lds	r31, 0x006D
 248:	80 83       	st	Z, r24
	if ( ++inPtr == endPtr )
 24a:	80 91 6c 00 	lds	r24, 0x006C
 24e:	90 91 6d 00 	lds	r25, 0x006D
 252:	01 96       	adiw	r24, 0x01	; 1
 254:	90 93 6d 00 	sts	0x006D, r25
 258:	80 93 6c 00 	sts	0x006C, r24
 25c:	20 91 73 00 	lds	r18, 0x0073
 260:	30 91 74 00 	lds	r19, 0x0074
 264:	82 17       	cp	r24, r18
 266:	93 07       	cpc	r25, r19
 268:	31 f4       	brne	.+12     	; 0x276 <putKey+0x36>
		inPtr = keyBuffer;
 26a:	83 e6       	ldi	r24, 0x63	; 99
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	90 93 6d 00 	sts	0x006D, r25
 272:	80 93 6c 00 	sts	0x006C, r24
	if ( inPtr == outPtr )
 276:	40 91 6f 00 	lds	r20, 0x006F
 27a:	50 91 70 00 	lds	r21, 0x0070
 27e:	80 91 6c 00 	lds	r24, 0x006C
 282:	90 91 6d 00 	lds	r25, 0x006D
 286:	84 17       	cp	r24, r20
 288:	95 07       	cpc	r25, r21
 28a:	71 f4       	brne	.+28     	; 0x2a8 <putKey+0x68>
		if ( ++outPtr == endPtr )
 28c:	01 96       	adiw	r24, 0x01	; 1
 28e:	90 93 70 00 	sts	0x0070, r25
 292:	80 93 6f 00 	sts	0x006F, r24
 296:	82 17       	cp	r24, r18
 298:	93 07       	cpc	r25, r19
 29a:	31 f4       	brne	.+12     	; 0x2a8 <putKey+0x68>
			outPtr = keyBuffer;
 29c:	83 e6       	ldi	r24, 0x63	; 99
 29e:	90 e0       	ldi	r25, 0x00	; 0
 2a0:	90 93 70 00 	sts	0x0070, r25
 2a4:	80 93 6f 00 	sts	0x006F, r24
 2a8:	08 95       	ret

000002aa <getKey>:

unsigned char getKey( void )
{
	unsigned char key = '\0';

	if ( outPtr == endPtr )
 2aa:	20 91 6f 00 	lds	r18, 0x006F
 2ae:	30 91 70 00 	lds	r19, 0x0070
 2b2:	80 91 73 00 	lds	r24, 0x0073
 2b6:	90 91 74 00 	lds	r25, 0x0074
 2ba:	28 17       	cp	r18, r24
 2bc:	39 07       	cpc	r19, r25
 2be:	31 f4       	brne	.+12     	; 0x2cc <getKey+0x22>
		outPtr = keyBuffer;
 2c0:	83 e6       	ldi	r24, 0x63	; 99
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	90 93 70 00 	sts	0x0070, r25
 2c8:	80 93 6f 00 	sts	0x006F, r24
	if ( outPtr != inPtr )
 2cc:	e0 91 6f 00 	lds	r30, 0x006F
 2d0:	f0 91 70 00 	lds	r31, 0x0070
 2d4:	80 91 6c 00 	lds	r24, 0x006C
 2d8:	90 91 6d 00 	lds	r25, 0x006D
 2dc:	e8 17       	cp	r30, r24
 2de:	f9 07       	cpc	r31, r25
 2e0:	41 f0       	breq	.+16     	; 0x2f2 <getKey+0x48>
		key = *outPtr++;
 2e2:	cf 01       	movw	r24, r30
 2e4:	01 96       	adiw	r24, 0x01	; 1
 2e6:	90 93 70 00 	sts	0x0070, r25
 2ea:	80 93 6f 00 	sts	0x006F, r24
 2ee:	80 81       	ld	r24, Z
 2f0:	08 95       	ret
			outPtr = keyBuffer;
}

unsigned char getKey( void )
{
	unsigned char key = '\0';
 2f2:	80 e0       	ldi	r24, 0x00	; 0
	if ( outPtr == endPtr )
		outPtr = keyBuffer;
	if ( outPtr != inPtr )
		key = *outPtr++;
	return key;
}
 2f4:	08 95       	ret

000002f6 <decode>:
void decode( unsigned char data )
{
	unsigned char chr;
	
	// If we did not just receive the up (0xf0) code, we must have a keypress.
	if (( flags & UP_FLAG ) == 0 )
 2f6:	90 91 62 00 	lds	r25, 0x0062
 2fa:	93 fd       	sbrc	r25, 3
 2fc:	2a c0       	rjmp	.+84     	; 0x352 <decode+0x5c>
	{
		// Is it the up code?
		if ( data == 0xf0 )
 2fe:	80 3f       	cpi	r24, 0xF0	; 240
 300:	21 f4       	brne	.+8      	; 0x30a <decode+0x14>
		{
			flags |= UP_FLAG;
 302:	80 91 62 00 	lds	r24, 0x0062
 306:	88 60       	ori	r24, 0x08	; 8
 308:	3c c0       	rjmp	.+120    	; 0x382 <decode+0x8c>
		}
		// Shift?
		else if (( data == 0x12 ) || ( data == 0x59 ))
 30a:	82 31       	cpi	r24, 0x12	; 18
 30c:	11 f0       	breq	.+4      	; 0x312 <decode+0x1c>
 30e:	89 35       	cpi	r24, 0x59	; 89
 310:	21 f4       	brne	.+8      	; 0x31a <decode+0x24>
		{
			flags |= SHIFT_FLAG;
 312:	80 91 62 00 	lds	r24, 0x0062
 316:	81 60       	ori	r24, 0x01	; 1
 318:	34 c0       	rjmp	.+104    	; 0x382 <decode+0x8c>
		}
		// Caps Lock?
		else if ( data == 0x58 )
 31a:	88 35       	cpi	r24, 0x58	; 88
 31c:	29 f4       	brne	.+10     	; 0x328 <decode+0x32>
		{
			flags ^= CLOCK_FLAG;
 31e:	80 91 62 00 	lds	r24, 0x0062
 322:	90 e2       	ldi	r25, 0x20	; 32
 324:	89 27       	eor	r24, r25
 326:	2d c0       	rjmp	.+90     	; 0x382 <decode+0x8c>
		}
		// Control? There is only one control key on my keyboard.
		else if ( data == 0x14 )
 328:	84 31       	cpi	r24, 0x14	; 20
 32a:	21 f4       	brne	.+8      	; 0x334 <decode+0x3e>
		{
			flags |= CTL_FLAG;
 32c:	80 91 62 00 	lds	r24, 0x0062
 330:	82 60       	ori	r24, 0x02	; 2
 332:	27 c0       	rjmp	.+78     	; 0x382 <decode+0x8c>
		}
		// Alternate? Both return the same code on this keyboard.
		else if ( data == 0x11 )
 334:	81 31       	cpi	r24, 0x11	; 17
 336:	21 f4       	brne	.+8      	; 0x340 <decode+0x4a>
		{
			flags |= ALT_FLAG;
 338:	80 91 62 00 	lds	r24, 0x0062
 33c:	84 60       	ori	r24, 0x04	; 4
 33e:	21 c0       	rjmp	.+66     	; 0x382 <decode+0x8c>
		}
		// Extended code. There are no non-unique extended codes on this keyboard.
		else if ( data == 0xe0 )
 340:	80 3e       	cpi	r24, 0xE0	; 224
 342:	09 f1       	breq	.+66     	; 0x386 <decode+0x90>
		}
		// Display or use the character.
		else
		{
			// Convert the character to ASCII.
			if (( chr = decodeScanCode( data, flags )) != 0 )
 344:	60 91 62 00 	lds	r22, 0x0062
 348:	9b d0       	rcall	.+310    	; 0x480 <decodeScanCode>
 34a:	88 23       	and	r24, r24
 34c:	e1 f0       	breq	.+56     	; 0x386 <decode+0x90>
			{
				putKey( chr );
 34e:	78 df       	rcall	.-272    	; 0x240 <putKey>
 350:	08 95       	ret
		}
	}
	else
	{
		// If the up code is active, it becomes inactive after any key.
		flags &= ~UP_FLAG;
 352:	90 91 62 00 	lds	r25, 0x0062
 356:	97 7f       	andi	r25, 0xF7	; 247
 358:	90 93 62 00 	sts	0x0062, r25

		// Shift key up? Reset the shift.
		if (( data == 0x12 ) || ( data == 0x59 ))
 35c:	82 31       	cpi	r24, 0x12	; 18
 35e:	11 f0       	breq	.+4      	; 0x364 <decode+0x6e>
 360:	89 35       	cpi	r24, 0x59	; 89
 362:	21 f4       	brne	.+8      	; 0x36c <decode+0x76>
		{
			flags &= ~SHIFT_FLAG;
 364:	80 91 62 00 	lds	r24, 0x0062
 368:	8e 7f       	andi	r24, 0xFE	; 254
 36a:	0b c0       	rjmp	.+22     	; 0x382 <decode+0x8c>
		}
		// Control key up? Reset control.
		else if ( data == 0x14 )
 36c:	84 31       	cpi	r24, 0x14	; 20
 36e:	21 f4       	brne	.+8      	; 0x378 <decode+0x82>
		{
			flags &= ~CTL_FLAG;
 370:	80 91 62 00 	lds	r24, 0x0062
 374:	8d 7f       	andi	r24, 0xFD	; 253
 376:	05 c0       	rjmp	.+10     	; 0x382 <decode+0x8c>
		}
		// Alt key up? reset alternate.
		else if ( data == 0x11 )
 378:	81 31       	cpi	r24, 0x11	; 17
 37a:	29 f4       	brne	.+10     	; 0x386 <decode+0x90>
		{
			flags &= ~ALT_FLAG;
 37c:	80 91 62 00 	lds	r24, 0x0062
 380:	8b 7f       	andi	r24, 0xFB	; 251
 382:	80 93 62 00 	sts	0x0062, r24
 386:	08 95       	ret

00000388 <keyboardInit>:

//---------------------------------------------------------------------------------

void keyboardInit( void )
{
	DDRD &= 0xf0;		// D0,D1,D2,D3 are inputs (0,1 are serial, 2,3 are keyboard).
 388:	81 b3       	in	r24, 0x11	; 17
 38a:	80 7f       	andi	r24, 0xF0	; 240
 38c:	81 bb       	out	0x11, r24	; 17
	PORTD |= 0x0c;		// Set pullups on the keyboard lines.
 38e:	82 b3       	in	r24, 0x12	; 18
 390:	8c 60       	ori	r24, 0x0C	; 12
 392:	82 bb       	out	0x12, r24	; 18
	_edge = FALL;		// Next edge should be falling.
 394:	10 92 6b 00 	sts	0x006B, r1
	_bitCount = 11;		// Get 11 bits from the keyboard.
 398:	8b e0       	ldi	r24, 0x0B	; 11
 39a:	80 93 6e 00 	sts	0x006E, r24
	MCUCR &= ~0x03;		// Setup INT0 for the falling edge.
 39e:	85 b7       	in	r24, 0x35	; 53
 3a0:	8c 7f       	andi	r24, 0xFC	; 252
 3a2:	85 bf       	out	0x35, r24	; 53
	MCUCR |= 0x02;
 3a4:	85 b7       	in	r24, 0x35	; 53
 3a6:	82 60       	ori	r24, 0x02	; 2
 3a8:	85 bf       	out	0x35, r24	; 53
	PCMSK |= (1<<PIND2);	// Enable pin change on INT0 (why is this required?)	
 3aa:	80 b5       	in	r24, 0x20	; 32
 3ac:	84 60       	ori	r24, 0x04	; 4
 3ae:	80 bd       	out	0x20, r24	; 32
	GIMSK= 0x40;		// Enable INT0 interrupt
 3b0:	80 e4       	ldi	r24, 0x40	; 64
 3b2:	8b bf       	out	0x3b, r24	; 59
	inPtr = outPtr = keyBuffer;
 3b4:	83 e6       	ldi	r24, 0x63	; 99
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	90 93 70 00 	sts	0x0070, r25
 3bc:	80 93 6f 00 	sts	0x006F, r24
 3c0:	90 93 6d 00 	sts	0x006D, r25
 3c4:	80 93 6c 00 	sts	0x006C, r24
	endPtr = inPtr + (MAX_KEYS);
 3c8:	8b e6       	ldi	r24, 0x6B	; 107
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	90 93 74 00 	sts	0x0074, r25
 3d0:	80 93 73 00 	sts	0x0073, r24
 3d4:	08 95       	ret

000003d6 <__vector_1>:
// the keyboard.

//---------------------------------------------------------------------------------

ISR( INT0_vect )
{
 3d6:	1f 92       	push	r1
 3d8:	0f 92       	push	r0
 3da:	0f b6       	in	r0, 0x3f	; 63
 3dc:	0f 92       	push	r0
 3de:	11 24       	eor	r1, r1
 3e0:	2f 93       	push	r18
 3e2:	3f 93       	push	r19
 3e4:	4f 93       	push	r20
 3e6:	5f 93       	push	r21
 3e8:	6f 93       	push	r22
 3ea:	7f 93       	push	r23
 3ec:	8f 93       	push	r24
 3ee:	9f 93       	push	r25
 3f0:	af 93       	push	r26
 3f2:	bf 93       	push	r27
 3f4:	ef 93       	push	r30
 3f6:	ff 93       	push	r31
	if ( _edge == FALL )
 3f8:	80 91 6b 00 	lds	r24, 0x006B
 3fc:	81 11       	cpse	r24, r1
 3fe:	1a c0       	rjmp	.+52     	; 0x434 <__vector_1+0x5e>
	{
		if ( _bitCount < 11 && _bitCount > 2 )
 400:	80 91 6e 00 	lds	r24, 0x006E
 404:	8b 30       	cpi	r24, 0x0B	; 11
 406:	80 f4       	brcc	.+32     	; 0x428 <__vector_1+0x52>
 408:	80 91 6e 00 	lds	r24, 0x006E
 40c:	83 30       	cpi	r24, 0x03	; 3
 40e:	60 f0       	brcs	.+24     	; 0x428 <__vector_1+0x52>
		{
			data = ( data >> 1 );	// Shift the data over.
 410:	80 91 71 00 	lds	r24, 0x0071
 414:	86 95       	lsr	r24
 416:	80 93 71 00 	sts	0x0071, r24
			if ( PIND & 8 )
 41a:	83 9b       	sbis	0x10, 3	; 16
 41c:	05 c0       	rjmp	.+10     	; 0x428 <__vector_1+0x52>
				data |= 0x80;	// Add a bit if it is a one.
 41e:	80 91 71 00 	lds	r24, 0x0071
 422:	80 68       	ori	r24, 0x80	; 128
 424:	80 93 71 00 	sts	0x0071, r24
		}
		_edge = RISE;			// Ready for rising edge.
 428:	81 e0       	ldi	r24, 0x01	; 1
 42a:	80 93 6b 00 	sts	0x006B, r24
		MCUCR |= 0x03;			// Setup INT0 for rising edge.
 42e:	85 b7       	in	r24, 0x35	; 53
 430:	83 60       	ori	r24, 0x03	; 3
 432:	14 c0       	rjmp	.+40     	; 0x45c <__vector_1+0x86>
	}
	else
	{
		if( --_bitCount == 0 )		// All bits received?
 434:	80 91 6e 00 	lds	r24, 0x006E
 438:	81 50       	subi	r24, 0x01	; 1
 43a:	80 93 6e 00 	sts	0x006E, r24
 43e:	81 11       	cpse	r24, r1
 440:	06 c0       	rjmp	.+12     	; 0x44e <__vector_1+0x78>
		{
			decode( data );		// Figure out what it is.
 442:	80 91 71 00 	lds	r24, 0x0071
 446:	57 df       	rcall	.-338    	; 0x2f6 <decode>
			_bitCount = 11;		// Start over.
 448:	8b e0       	ldi	r24, 0x0B	; 11
 44a:	80 93 6e 00 	sts	0x006E, r24
		}
		_edge = FALL;			// Setup routine the next falling edge.
 44e:	10 92 6b 00 	sts	0x006B, r1
		MCUCR &= ~0x03;			// Setup INT0 for the falling edge.
 452:	85 b7       	in	r24, 0x35	; 53
 454:	8c 7f       	andi	r24, 0xFC	; 252
 456:	85 bf       	out	0x35, r24	; 53
		MCUCR |= 0x02;
 458:	85 b7       	in	r24, 0x35	; 53
 45a:	82 60       	ori	r24, 0x02	; 2
 45c:	85 bf       	out	0x35, r24	; 53
	}
}
 45e:	ff 91       	pop	r31
 460:	ef 91       	pop	r30
 462:	bf 91       	pop	r27
 464:	af 91       	pop	r26
 466:	9f 91       	pop	r25
 468:	8f 91       	pop	r24
 46a:	7f 91       	pop	r23
 46c:	6f 91       	pop	r22
 46e:	5f 91       	pop	r21
 470:	4f 91       	pop	r20
 472:	3f 91       	pop	r19
 474:	2f 91       	pop	r18
 476:	0f 90       	pop	r0
 478:	0f be       	out	0x3f, r0	; 63
 47a:	0f 90       	pop	r0
 47c:	1f 90       	pop	r1
 47e:	18 95       	reti

00000480 <decodeScanCode>:


unsigned char keyCount = 76; // Count of above keys.

unsigned char decodeScanCode( unsigned char scanCode, unsigned char flags )
{
 480:	cf 93       	push	r28
 482:	c8 2f       	mov	r28, r24
 484:	a6 2f       	mov	r26, r22
	unsigned char offset;
	unsigned char result = NOT_USED;
	unsigned char min = 0;
	unsigned char max = keyCount - 1;
 486:	40 91 60 00 	lds	r20, 0x0060
 48a:	41 50       	subi	r20, 0x01	; 1

unsigned char decodeScanCode( unsigned char scanCode, unsigned char flags )
{
	unsigned char offset;
	unsigned char result = NOT_USED;
	unsigned char min = 0;
 48c:	b0 e0       	ldi	r27, 0x00	; 0
	unsigned char mid;
	unsigned char value;

	while ( min <= max )
	{
		mid = ( min + max ) / 2;
 48e:	24 2f       	mov	r18, r20
 490:	30 e0       	ldi	r19, 0x00	; 0
 492:	2b 0f       	add	r18, r27
 494:	31 1d       	adc	r19, r1
 496:	35 95       	asr	r19
 498:	27 95       	ror	r18
		value = pgm_read_byte( &scan_to_ascii[mid][0] );
 49a:	c9 01       	movw	r24, r18
 49c:	65 e0       	ldi	r22, 0x05	; 5
 49e:	70 e0       	ldi	r23, 0x00	; 0
 4a0:	40 d0       	rcall	.+128    	; 0x522 <__mulhi3>
 4a2:	fc 01       	movw	r30, r24
 4a4:	ea 5d       	subi	r30, 0xDA	; 218
 4a6:	ff 4f       	sbci	r31, 0xFF	; 255
 4a8:	e4 91       	lpm	r30, Z
		if ( value == scanCode )
 4aa:	ec 13       	cpse	r30, r28
 4ac:	04 c0       	rjmp	.+8      	; 0x4b6 <decodeScanCode+0x36>


	if ( min <= max )
	{
		offset = 1;
		if ( flags & (SHIFT_FLAG | CLOCK_FLAG))
 4ae:	8a 2f       	mov	r24, r26
 4b0:	81 72       	andi	r24, 0x21	; 33
 4b2:	91 f4       	brne	.+36     	; 0x4d8 <decodeScanCode+0x58>
 4b4:	0b c0       	rjmp	.+22     	; 0x4cc <decodeScanCode+0x4c>
	{
		mid = ( min + max ) / 2;
		value = pgm_read_byte( &scan_to_ascii[mid][0] );
		if ( value == scanCode )
			break;
		if ( scanCode > value )
 4b6:	ec 17       	cp	r30, r28
 4b8:	18 f4       	brcc	.+6      	; 0x4c0 <decodeScanCode+0x40>
			min = mid + 1;
 4ba:	b1 e0       	ldi	r27, 0x01	; 1
 4bc:	b2 0f       	add	r27, r18
 4be:	02 c0       	rjmp	.+4      	; 0x4c4 <decodeScanCode+0x44>
		else
			max = mid - 1;
 4c0:	4f ef       	ldi	r20, 0xFF	; 255
 4c2:	42 0f       	add	r20, r18
	unsigned char min = 0;
	unsigned char max = keyCount - 1;
	unsigned char mid;
	unsigned char value;

	while ( min <= max )
 4c4:	4b 17       	cp	r20, r27
 4c6:	18 f7       	brcc	.-58     	; 0x48e <decodeScanCode+0xe>
unsigned char keyCount = 76; // Count of above keys.

unsigned char decodeScanCode( unsigned char scanCode, unsigned char flags )
{
	unsigned char offset;
	unsigned char result = NOT_USED;
 4c8:	80 e0       	ldi	r24, 0x00	; 0
 4ca:	15 c0       	rjmp	.+42     	; 0x4f6 <decodeScanCode+0x76>
		offset = 1;
		if ( flags & (SHIFT_FLAG | CLOCK_FLAG))
		{
			offset = 2;
		}
		else if ( flags & CTL_FLAG )
 4cc:	a1 fd       	sbrc	r26, 1
 4ce:	06 c0       	rjmp	.+12     	; 0x4dc <decodeScanCode+0x5c>
		{
			offset = 3;
		}
		else if ( flags & ALT_FLAG )
 4d0:	a2 ff       	sbrs	r26, 2
 4d2:	06 c0       	rjmp	.+12     	; 0x4e0 <decodeScanCode+0x60>
		{
			offset = 4;
 4d4:	44 e0       	ldi	r20, 0x04	; 4
 4d6:	05 c0       	rjmp	.+10     	; 0x4e2 <decodeScanCode+0x62>
	if ( min <= max )
	{
		offset = 1;
		if ( flags & (SHIFT_FLAG | CLOCK_FLAG))
		{
			offset = 2;
 4d8:	42 e0       	ldi	r20, 0x02	; 2
 4da:	03 c0       	rjmp	.+6      	; 0x4e2 <decodeScanCode+0x62>
		}
		else if ( flags & CTL_FLAG )
		{
			offset = 3;
 4dc:	43 e0       	ldi	r20, 0x03	; 3
 4de:	01 c0       	rjmp	.+2      	; 0x4e2 <decodeScanCode+0x62>
	}


	if ( min <= max )
	{
		offset = 1;
 4e0:	41 e0       	ldi	r20, 0x01	; 1
		}
		else if ( flags & ALT_FLAG )
		{
			offset = 4;
		}
		result = pgm_read_byte(&scan_to_ascii[mid][offset]);
 4e2:	c9 01       	movw	r24, r18
 4e4:	65 e0       	ldi	r22, 0x05	; 5
 4e6:	70 e0       	ldi	r23, 0x00	; 0
 4e8:	1c d0       	rcall	.+56     	; 0x522 <__mulhi3>
 4ea:	84 0f       	add	r24, r20
 4ec:	91 1d       	adc	r25, r1
 4ee:	8a 5d       	subi	r24, 0xDA	; 218
 4f0:	9f 4f       	sbci	r25, 0xFF	; 255
 4f2:	fc 01       	movw	r30, r24
 4f4:	84 91       	lpm	r24, Z
	}

	return result;
}
 4f6:	cf 91       	pop	r28
 4f8:	08 95       	ret

000004fa <main>:
int main( void )
{
	
	unsigned char key, tmp = 0;
	
	keyboardInit( );
 4fa:	46 df       	rcall	.-372    	; 0x388 <keyboardInit>
	
	DDRB = 0xff;
 4fc:	8f ef       	ldi	r24, 0xFF	; 255
 4fe:	87 bb       	out	0x17, r24	; 23
	PORTB = 0x00;
 500:	18 ba       	out	0x18, r1	; 24
	
	DDRA = 3;
 502:	83 e0       	ldi	r24, 0x03	; 3
 504:	8a bb       	out	0x1a, r24	; 26
	PORTA=0;
 506:	1b ba       	out	0x1b, r1	; 27

	sei( );
 508:	78 94       	sei

	while( 1 )
	{
		if (( key = getKey( )) != 0 )
 50a:	cf de       	rcall	.-610    	; 0x2aa <getKey>
 50c:	88 23       	and	r24, r24
 50e:	39 f0       	breq	.+14     	; 0x51e <main+0x24>
		{
			PORTB=key;
 510:	88 bb       	out	0x18, r24	; 24
 512:	8f e1       	ldi	r24, 0x1F	; 31
 514:	9e e4       	ldi	r25, 0x4E	; 78
 516:	01 97       	sbiw	r24, 0x01	; 1
 518:	f1 f7       	brne	.-4      	; 0x516 <main+0x1c>
 51a:	00 c0       	rjmp	.+0      	; 0x51c <main+0x22>
 51c:	00 00       	nop
			//pump(key);
			_delay_ms(10);
		}
		PORTB=0;
 51e:	18 ba       	out	0x18, r1	; 24
		//pump(0);
	}
 520:	f4 cf       	rjmp	.-24     	; 0x50a <main+0x10>

00000522 <__mulhi3>:
 522:	00 24       	eor	r0, r0
 524:	55 27       	eor	r21, r21
 526:	04 c0       	rjmp	.+8      	; 0x530 <__mulhi3+0xe>
 528:	08 0e       	add	r0, r24
 52a:	59 1f       	adc	r21, r25
 52c:	88 0f       	add	r24, r24
 52e:	99 1f       	adc	r25, r25
 530:	00 97       	sbiw	r24, 0x00	; 0
 532:	29 f0       	breq	.+10     	; 0x53e <__mulhi3+0x1c>
 534:	76 95       	lsr	r23
 536:	67 95       	ror	r22
 538:	b8 f3       	brcs	.-18     	; 0x528 <__mulhi3+0x6>
 53a:	71 05       	cpc	r23, r1
 53c:	b9 f7       	brne	.-18     	; 0x52c <__mulhi3+0xa>
 53e:	80 2d       	mov	r24, r0
 540:	95 2f       	mov	r25, r21
 542:	08 95       	ret

00000544 <_exit>:
 544:	f8 94       	cli

00000546 <__stop_program>:
 546:	ff cf       	rjmp	.-2      	; 0x546 <__stop_program>
