;
;	http://www.pouet.net/prod.php?which=61298
;	http://www.youtube.com/watch?v=JxS0_ckSwqk
;
;---------------------------------------
; 1bir - 1 block interactive raycaster
;
; coded by huseyin kilic (wisdom)
;
; copyright (c) 2009-2013 crescent
;---------------------------------------
; v1.0: 2009-12-14/15/18
; v2.0: 2010-04-10/11
; v3.0: 2012-02-04/05/06/07/13-20
;       2013-04-01/02/03/04/17/18/19/20
;---------------------------------------
; memory map:
; 0326-0423 code
; 0500-063f sin/cos table
; 0800-0be7 vram
; 2800-2fff chram (only 2900-2907 used)
;---------------------------------------
; mandatory locations due to basic/kernal
; these locations have been selected to make use of
; some basic/kernal routines to help with decreasing the size of the program
rayposx     = $61
rayposxh    = $62
rayposy     = $63
rayposyh    = $64

stepx       = $66 ; leave 1 byte between x and y
stepy       = $68

playerx     = $69
playerxh    = $6a
playery     = $6b
playeryh    = $6c

distance    = $70 ; reset in $bc00 and $bc0f calls

rowptr      = $d1
rowptrh     = $d2
lineh_t     = $d9
linel_t     = $ecf0

heights     = $f8 ; 3 bytes consecutively

map_t       = $ecb9 ; this area has been choosen because of lots of zeroes

; external value dependencies
heading     = $81 ; default = $20
sinadd      = $9a ; default = $03
colors      = $b1 ; 3 bytes consecutively

; temp
currentrow  = $ff

; constants
sin_t       = $0500
blocksize   = $28

; basic/kernal calls
copyplr2ray = $bc00
copyray2plr = $bc0f
setrowptr   = $e9f0
invertstepx = $bfb8
setheights  = $f2c1
;---------------------------------------
; main
;---------------------------------------
            *= $0326
;            !word main
;            !word $f6ed
main
            ; set vram to $0800
            ; and chram to $2800
            asl $d018
            asl $0288
            jsr $e534
            ; set lineh_t to $d800
            ;lda #$d8 ; workaround for ccs64 kernal "bug"
            jsr $e549
            ;sta $0288
            
            sei
;---------------------------------------
; sin/cos table generator
;---------------------------------------
            ;lda #$00
            and #$00 ; clears carry for sinadd below
			clc
            tay
gensin_loop
            sta sin_t,y
            iny
            ;clc
            adc sinadd
            ldx sinadd
            dec sincount_t,x
            bne gensin_loop
            dec sinadd
            bpl gensin_loop

            ; x = $00
            ; y = $40
gensin_loop2
            lda sin_t,x
            sta sin_t+$0100,x ; needed for cos extension
            sta sin_t-1+$40,y
            eor #$ff
            sta sin_t+$80,x
            sta sin_t-1+$c0,y
            ;lda #$ff
            ;sta $2900,y
            inx
            dey
            bpl gensin_loop2
;---------------------------------------
; raycaster            
;---------------------------------------
loop_main
            ; cast 40 rays for each screen column
            ; starting with rightmost one
            ; yr is used as global column index
            ; throughout the rest of the program
            ldy #39
loop_ray
            ; determine current ray's direction
            ; by taking player's current direction
            ; and fov into account
            ; fov is 40 brads out of 256 brads
            tya
            clc
            adc heading
            ;sec
            sbc #19+1 ; half of the fov (+1 because of sec)
            tax
            ; get sin/cos values accordingly
            ; and copy player position to current ray position
            ; distance is reset on return from this call
            jsr getsincos_copyplr2ray
            
            ; reset line row before each column gets drawn
            ; (needed in vertical line section)
            stx currentrow

loop_dist
            ; step along current ray's path and find distance
            inc distance
            
            ; limit distance when it is needed in larger maps
            ; or open (wrapped) maps
            
            ; max distance = $29
            ;lda distance
            ;cmp #$29
            ;bcs skip_dist
            
            ; max distance = $40 (make sure ar is always 0 here)
            ;bit distance
            ;bvs skip_dist

            ; max distance = $80
            bmi skip_dist
            
            jsr addsteptopos
            ; on return from last call, ar is cell (block) value
            ; ar = 0 means empty cell, so continue tracing
            beq loop_dist
skip_dist
            ; now ar contains the value in reached map position
            ; (or last cell value fetched if max distance is reached)
            
            ; use ar or xr to colorize the block
            ;and #$07
            ;ora #$03
            stx colors+1

            ; find out visible block height
            ; according to distance
            ;ldx #$ff
            ;txa
            ; as lax #imm is unstable, the following is needed to
            ; load ar and xr both with $ff value from kernal stkey var.
            lda $91
			tax
            ; fill the single char that appears on screen
            ; (as in char $a0 in default charset)
            ; dirty but needed because of size restriction
            sta $2900,y 
            
            ; calculate visible block height through simple division
            lda #<blocksize
loop_div
            inx
            ;sec
            sbc distance
            bcs loop_div

            ; xr = half of visible block height
            txa
;---------------------------------------
; vertical line
;---------------------------------------
            ; yr = x position (screen column)
            ; ar = half height (zero height is ok)
            cmp #13          ; height > 12?
            bcc vline_validheight
            lda #12          ; make sure max height = 12
vline_validheight
            asl              ; calculate full height
            sta heights+1    ; store for looping below
            eor #$ff         ; subtract full height from screen height
            ;sec             ; (24 rows)
            adc #24+1        ; +1 because of sec
            lsr              ; sky/floor heights are equal to each other
            ;sta heights
            ;sta heights+2
            jsr setheights   ; dirty again, but works
            
            ; loop through 3 sections of one screen column
            ; i.e. sky - wall - floor
            ldx #$02
vline_loop
            dec heights,x
            bmi vline_sectioncomplete
            txs              ; dirty way of saving xr temporarily
            ldx currentrow   ; this was reset before the distance loop
            ; there are two ways used in this program to set up
            ; current row address, either through kernal call ($e549)
            ; or by directly modifiying zp pointer
            ;jsr setrowptr ; call $e549 in main if you comment out this line
            lda linel_t,x
            sta rowptr
            lda lineh_t,x
            sta rowptrh
            tsx
            lda colors,x ; each section can be assigned to a different color
            sta (rowptr),y
            ; advance to next screen row
            inc currentrow
            bne vline_loop ; absolute jump, as currentrow never reaches zero
vline_sectioncomplete
            ; advance to next column section
            dex
            bpl vline_loop
;---------------------------------------
            ; advance to next ray/column
            dey
            bpl loop_ray
;---------------------------------------
; user input
;---------------------------------------
            ; common preparation code to set up sin/cos and
            ; to copy player position to ray position to trace movement
            ; direction to determine if player hits a block
            ; in case player actually tries to move forward or backwards
            ldx heading
            jsr getsincos_copyplr2ray

            ; get joystick 2 status (lowest 4 bits)
            ; and check each bit to determine action
            lda $dc00

            lsr
            bcs skip_j1
            ; try to move forward
            pha
            jsr stepandcopy
            pla
skip_j1
            lsr
            bcs skip_j2
            ; try to move backward
            pha
            jsr invertstepandcopy
            pla
skip_j2
            lsr
            bcs skip_j3
            ; turn right
            dec heading
            ;dec heading
skip_j3
            lsr
            bcs loop_main
            ; turn left
            inc heading
            ;inc heading

            ; absolute jump, as carry is always 0 here
            bcc loop_main
;---------------------------------------
; ray tracing subroutines
;---------------------------------------
            ; heart of tracing, very slow, because of looping
            ; for x and y components and also because of
            ; brute force approach
addsteptopos
            ldx #$02
loop_stepadd
            lda stepx,x    ; & y
            ora #$7f       ; sign extend 8 bit step value to 16 bit
            bmi *+4
            lda #$00
            pha
            ;clc
            lda stepx,x    ; & y
            adc rayposx,x  ; & y
            sta rayposx,x  ; & y
            pla
            adc rayposxh,x ; & y
            sta rayposxh,x ; & y
            dex
            dex
            bpl loop_stepadd
            
            ; ar = rayposxh

            ; calculate index to look up the map cell
            ; the map area is 8x8 bytes
            ; instead of the usual y * 8 + x
            ; x * 8 + y done here, to save some bytes
            ; (just causing a flip of the map as a side effect)
            asl
            asl
            asl
            ; by doing ora instead of adc, it is possible to have
            ; a closed area map in $ecb9
            adc rayposyh
            tax
            lda map_t,x
step_exit
            rts
;---------------------------------------
getsincos_copyplr2ray
            lda sin_t,x      ; sin(x)
            sta stepx
            lda sin_t+$40,x  ; cos(x)
            sta stepy
            ; copy player position to ray position for a start
            ; through the basic rom
            jmp copyplr2ray
;---------------------------------------
invertstepandcopy
            ; invert step variables for backward motion
            jsr invertstepx ; eor stepx through basic rom
            lda stepy
            eor #$ff
            sta stepy
;---------------------------------------
stepandcopy
            ; see if player can move to the direction desired
            jsr addsteptopos
            bne step_exit ; no, return without doing anything
            ; yes, move player by
            ; copying ray position to player position
            ; through the basic rom
            jmp copyray2plr
;---------------------------------------
; data
;---------------------------------------
            ; number of sin additions (backwards)
sincount_t
            !byte 6,14,19,25
;---------------------------------------
