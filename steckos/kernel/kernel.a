!address {
	.shell_addr		= $d000
	KERNEL_START = $e000
}


* = KERNEL_START

text_mode_40 = 1
num_ls_entries = $03
.kbd_frame_div  = $01

!src <defs.h.a>
!src <bios.h.a>
!src <via.h.a>
!src <fat32.h.a>
; !src <params.h.a>
; !src <errors.h.a>



kern_init
	sei
	

	; disable RTC interrupts
	; Select SPI SS for RTC
	lda #%01110110
	; and via1portb
	sta via1portb

    lda #$8f
    jsr spi_rw_byte
	lda #$00
    jsr spi_rw_byte

	; Select SPI SS for RTC
	lda #%01111110
	; and via1portb
	sta via1portb

	+SetVector .kern_irq, irqvec

	; read from keyboard buffer until empty to filter crap from kbd init
	; select keyboard controller
-	jsr .getkey
	cmp #$00
	bne -

	jsr	.textui_init0

	
	+SetVector .textui_chrout, outvec

	cli
	
	+SetVector .kernel_version, msgptr
	jsr strout


	jsr init_sdcard

	; check errno. if != 00, sd card init failed.
	; do not attempt to mount card, jump to upload instead
	lda errno
	bne .error

	lda #%01111110
	sta via1portb

	jsr .fat_mount 
	lda errno
	bne .error 

	+SetVector .filename, filenameptr
	jsr .fat_open 
	lda errno
	bne .error 

	+SetVector .shell_addr, sd_blkptr
	jsr .fat_read
	lda errno
	bne .error 

	jsr .fat_close

	ldx #$ff 
	txs 
	
	jmp .shell_addr	

.error
	; Card could not be mounted, contains no shell.bin, whatever
	; serial upload it is
	

	jsr .upload
	
	; sei
	jmp (.startaddr)

.keyin
-	jsr .getkey
	cmp #$00
	beq -
	rts

.getkey
	phx

	lda #%01111010
	sta via1portb

	; lda #$ff
	jsr spi_r_byte
       
	ldx #%11111110
	stx via1portb

	plx
	rts


; system interrupt handler
; handle keyboard input and text screen refresh
.kern_irq
	+save

	bit	a_vreg
	bpl ++	   ; VDP IRQ flag set?

	jsr	.textui_update_screen

++
	+restore
	rti

!src "textui.a"
!src "gfxui.a"
!src <fat.a>
.upload
	+PrintString .crlf
	+PrintString .serial_upload
	; ldy #param_baud
	; lda (paramvec),y

	; jsr hexout
	+PrintString .crlf

	jsr .textui_screen_dirty

	; load start address
	jsr uart_rx
	sta .startaddr
	
	jsr uart_rx
	sta .startaddr+1

	lda .startaddr+1
	jsr hexout
	lda .startaddr
	jsr hexout

	lda #' '
	jsr chrout
	jsr .textui_screen_dirty

	jsr .upload_ok
	
	; load number of bytes to be uploaded
	jsr uart_rx
	sta .length
		
	jsr uart_rx
	sta .length+1

	; calculate end address
	clc
	lda .length
	adc .startaddr
	sta .endaddr

	lda .length+1
	adc .startaddr+1
	sta .endaddr+1

	lda .endaddr+1
	jsr hexout

	lda .endaddr
	jsr hexout
	
	lda #' '
	jsr chrout

	jsr .textui_screen_dirty
	sei 
	lda .startaddr
	sta .addr
	lda .startaddr+1
	sta .addr+1	

	jsr .upload_ok
	

	ldy #$00
-	jsr uart_rx
	sta (.addr),y

	iny	
	cpy #$00
	bne +
	inc .addr+1
+		

	; msb of current address equals msb of end address?
	lda .addr+1
	cmp .endaddr+1
	bne - ; no? read next byte

	; yes? compare y to lsb of endaddr
	cpy .endaddr
	bne - ; no? read next byte

	; yes? write OK and jump to start addr	

	jsr .upload_ok
	cli 

	lda #'O'
	jsr chrout
	lda #'K'
	jsr chrout

	rts

.upload_ok
	lda #'O'
	jsr uart_tx
	lda #'K'
	jsr uart_tx
	rts

; locations
.kbd_div					!byte $00

; strings
.kernel_version 			!text "SteckOS Kernel 0.2b",$0d,$0a,$00
.crlf						!byte $0a,$0d,$00
.txt_msg_loading 			!text "Loading ",$00
.serial_upload				!text "Serial Upload ",$00
.filename					!text "shell.bin",$00
* = KERNEL_START + $f00
; "kernel" jumptable
krn_keyin			jmp .keyin
krn_mount 			jmp .fat_mount 
krn_open 			jmp .fat_open
krn_read_dir		jmp .fat_dir_scan
krn_close 			jmp .fat_close
krn_read 			jmp .fat_read 
krn_open_rootdir 	jmp .fat_open_rootdir

krn_textui_init 		jmp	.textui_init
krn_textui_enable		jmp	.textui_enable
krn_textui_disable		jmp .textui_disable			;disable textui
krn_gfxui_on			jmp	.gfxui_on
krn_gfxui_off			jmp	.gfxui_off
krn_display_off			jmp vdp_display_off
krn_getkey				jmp .getkey
;TODO FIXME externalize it, imgviewer
krn_gfxui_blend_off	    jmp	.gfxui_blend_off
krn_gfxui_blend_on	    jmp	.gfxui_blend_on
krn_textui_crsxy				jmp .textui_crsxy
krn_textui_update_crs_ptr		jmp .textui_update_crs_ptr
krn_textui_clrscr_ptr		    jmp .textui_blank