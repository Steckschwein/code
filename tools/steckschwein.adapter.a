!src "../steckos/asminc/via.inc"
;!src "../steckos/asminc/vdp.inc"
!src <t9929.h.a>

!macro SetVector .word, .addr {
        lda #<.word
        sta .addr
        lda #>.word
        sta .addr+1
} 

; general purpose pointer
addr 		= $e0
adrl     	= addr
adrh     	= addr+1
ptr1		= $e2
ptr1l		= ptr1
ptr1h		= ptr1+1
ptr2		= $e4
ptr2l		= ptr2
ptr2h		= ptr2+1 
; general purpose temp variables
tmp0		= $ea
tmp1		= $eb 

.init_io
    ;+SetVector RESET, nmivec direct loaded into ROM
    +SetVector COUT1, CSWL
    +SetVector .getkey, KSWL
    rts
	;jmp init_vdp done by bios already
    
.getkey
	phx
-	lda #%01111010
	sta via1portb
	jsr .spi_r_byte
	ldx #%11111110
	stx via1portb
    cmp #$00
    beq -
	plx
    ora #$80; apple 2 monitor specific
    rts
	
vdp_nopslide:
;		nop	;2
;		nop	;2
		rts	;6 + 6 = 
		
.scroll2

vdp_bgcolor:
		sta   a_vreg
		lda   #v_reg7
		+vnops
		nop
		sta   a_vreg
		rts

.scroll
		pha
		phx
		
		+SetVector	(ADDRESS_GFX1_SCREEN+.COLS), ptr1		        ; +COLS - offset second row
		+SetVector	(ADDRESS_GFX1_SCREEN+(.WRITE_ADDRESS<<8)), ptr2	; offset first row as "write adress"

		lda	a_vreg  ; clear v-blank bit, we dont know where we are...			
-
		bit	a_vreg  ; sync with next v-blank, so that we have the full 4300µs to copy the vram
		bpl	-
		lda	#Gray<<4|Dark_Yellow
		jsr vdp_bgcolor
--
		lda	ptr1l	; 3cl
		sta	a_vreg
		+vnops
		lda	ptr1h	; 3cl
		sta	a_vreg
		+vnops		; wait 2µs, 8Mhz = 16cl => 8 nop
		ldx	a_vram	;
		+vnops
		
		lda	ptr2l	; 3cl
		sta	a_vreg
		+vnops
		lda	ptr2h	; 3cl
		sta a_vreg
		+vnops
		stx	a_vram
		inc	ptr1l	; 5cl
		bne	+		; 3cl
		inc	ptr1h
		lda	ptr1h
		cmp	#>(ADDRESS_GFX1_SCREEN+(.COLS * 24 + ((.COLS * 24) % 256)))	;screen ram $1800 - $1b00
		beq	++
+
		inc	ptr2l  ; 5cl
		bne	--		; 3cl
		inc	ptr2h
		lda	#Gray<<4|Black
		jsr vdp_bgcolor
		bra	-			
++
		ldx	#.COLS	; write address is already setup from loop
		lda	#' '
-
;		sta	a_vram
;		+vnops
;		dex
;		bne	-

		lda	#Gray<<4|Black
		jsr vdp_bgcolor
		
		plx
		pla
		
		rts
		
; output char upon CH/CV cursor pointer
;
.chrout						; set the vdp vram adress and write one byte afterwards
		pha
		pha
		
!ifndef CHAR6x8{
		lda	CV   		; * 32
		asl
		asl
		asl
		asl
		asl
		ora	CH
		sta	a_vreg
		
		lda CV   		; * 32
		lsr					; div 8 -> page offset 0-2
		lsr
		lsr
		ora	#.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN
		sta a_vreg
}

!ifdef CHAR6x8{
		stz	tmp1
		lda CV
		asl
		asl
		asl
		sta tmp0			; save crs_y * 8
		asl		   			; crs_y*16
		rol tmp1		   	; save carry if overflow
		asl					; crs_y*32
		rol tmp1			; again, save carry
		adc tmp0		   	; crs_y*32 + crs_y*8 (crs_ptr) => y*40
		bcc +
		inc	tmp1			; overflow inc page count
		clc					; 
+		adc CH				; add x to address
		sta a_vreg
		lda #(.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN)
		adc	tmp1			; add carry and page to address high byte
		sta	a_vreg
}
		pla
		and #$7f
		sta a_vram
		pla
		rts
    
;----------------------------------------------------------------------------------------------
; Receive byte VIA SPI
; Received byte in A at exit
; Destructive: A,Y
;----------------------------------------------------------------------------------------------	
.spi_r_byte
    lda via1portb   ; Port laden
    AND #$fe        ; Takt ausschalten
    TAX             ; aufheben
    ORA #$01

    STA via1portb ; Takt An 1
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 2
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 3
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 4
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 5
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 6
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 7
    STX via1portb ; Takt aus
    STA via1portb ; Takt An 8
    STX via1portb ; Takt aus

    lda via1sr
    rts
