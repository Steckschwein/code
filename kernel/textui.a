!source <t99xx.lib.a>

;   
;
;
;

!address {
    .screen=$c000	
}

.screen_status !byte .TEXTUI_ENABLED
.screen_frames !byte 0
.saved_char	!byte ' '

.ROWS=24
.KEY_BACKSPACE=$08
.KEY_CARIAGE_RETURN=$0a
.KEY_RETURN=$0d
.WRITE=1<<0
.DIRTY=1<<1
.CURSOR=1<<2
.TEXTUI_ENABLED=1<<4

.textui_incy
	jmp	.inc_cursor_y
	
.textui_decy
	lda	crs_y
	bne	+
	rts
+	dec	crs_y	; go on with textui_update_crs_ptr below
	bra	.textui_update_crs_ptr
	
.textui_incx
	lda	crs_x
	cmp	#(.COLS-1)
	bne +
	rts
+	inc	crs_x
	bra	.textui_update_crs_ptr
	
.textui_decx
	lda	crs_x
	bne	+
	rts
+	dec	crs_x	; go on with textui_update_crs_ptr below
	

;   updates the 16 bit pointer crs_p upon crs_x, crs_y values
;    
.textui_update_crs_ptr
	pha
    
    lda .saved_char     ;restore saved char
    sta (crs_ptr)
    lda #.CURSOR
    trb .screen_status  ;reset cursor state
    
!ifdef text_mode_40 {
.charset=charset_6x8	; loaded after shell code, see shell.a
.COLS=40
.CURSOR_CHAR=160	
	stz	   tmp1
	lda    crs_y
    asl
    asl
    asl
    sta    tmp0    ; result *8
    asl
    rol    tmp1
    asl
    rol    tmp1
+	clc
    adc    tmp0    ; y*32 + y*8 = y*40
    bcc    +
    inc    tmp1
+	clc
    adc    crs_x
    sta    crs_ptr
    lda    #>.screen
    adc    tmp1
    sta    crs_ptr+1
}

!ifndef text_mode_40 {
.charset=charset	; the one from ROM
.COLS=32
.CURSOR_CHAR=160
	lda	crs_y
	asl	
	asl
	asl
	asl			
	asl			; offs= y*.COLS
	ora	crs_x
	sta	crs_ptr
	
	lda	crs_y	; * .COLS
	lsr			; /8 -> page offset 0-2
	lsr
	lsr
	clc
	adc	#>.screen
	sta	crs_ptr+1
}
    lda (crs_ptr)
    sta .saved_char     ;save char
	pla
	rts
;   
;   
;
.textui_init0
	jsr	vdp_display_off			;display off
	
	jsr	.textui_blank			;blank screen buffer
	
	stz	crs_x
	stz	crs_y
	jsr .textui_update_crs_ptr		;init cursor pointer

.textui_init
	+SetVector	.charset, .adrl	;load charset
	; lda	#<(ADDRESS_GFX1_SPRITE_PATTERN)
	; ldy	#>(ADDRESS_GFX1_SPRITE_PATTERN+(.WRITE_ADDRESS<<8))


!ifndef text_mode_40 {
	lda	#<ADDRESS_GFX1_PATTERN
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX1_PATTERN
	ldx	#$08					
	jsr	vdp_memcpy

	jsr	vdp_mode_gfx1_sprites_off	;clean sprite attribute table
	lda	#Medium_Green<<4|Black		;enable gfx 1
	jmp	vdp_mode_gfx1
}
!ifdef text_mode_40 {
	jmp	vdp_mode_text
}
	
.textui_blank
	ldx	#$00
	lda	#' '
-	sta	.screen,x
	sta	.screen+$100,x
	sta	.screen+$200,x
	sta	.screen+$300,x
	inx
	bne	-
-	sta	.screen+$400,x	;last line for scroll up
	inx
	cpx	#.COLS
	bne	-
	jmp	.textui_screen_dirty
	
.textui_cursor
	lda .screen_status
	and	#.WRITE
	bne	+++
	lda .screen_frames
	and	#$0f
	bne	+++
	lda	#.CURSOR
	tsb	.screen_status
	beq	+
	trb	.screen_status
  	lda	.saved_char
	jmp .textui_put
+	lda	#.CURSOR_CHAR
	jmp .textui_put
+++	rts

.textui_update_screen
;	lda	#Gray
;	jsr	vdp_bgcolor	
    
	lda	.screen_status
	and	#.TEXTUI_ENABLED
	beq	+
	
	inc	.screen_frames

	jsr	.textui_cursor
	
	lda	.screen_status
	and	#.DIRTY
	beq	+		;exit if not dirty
	
	+SetVector	.screen, .adrl
	lda	#<ADDRESS_GFX1_SCREEN
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN
	ldx	#$04
	jsr	vdp_memcpy
	
	lda	.screen_status		;clean dirty
	and	#!.DIRTY
	sta	.screen_status

	lda	#Medium_Green<<4|Black
	jsr	vdp_bgcolor
 	
+   
    rts	

.textui_scroll_up
	ldx	#$00
-	lda	.screen+.COLS,x
	sta	.screen,x
	inx
	bne	-
-	lda	.screen+256+.COLS,x
	sta	.screen+256,x
	inx
	bne	-
-	lda	.screen+512+.COLS,x
	sta	.screen+512,x
	inx
	bne	-
-	lda	.screen+$300+.COLS,x
	sta	.screen+$300,x
	inx
	bne	-
	rts
	
.inc_cursor_y
	lda crs_y
	cmp	#.ROWS-1		;last line
	bne	+

    lda .saved_char     ;restore saved char
    sta (crs_ptr)
    lda #.CURSOR
    trb .screen_status  ;reset cursor state
	bra	.textui_scroll_up	; scroll and exit
    
+	inc crs_y
    jmp .textui_update_crs_ptr

.textui_enable
	lda	.screen_status
	ora	#.TEXTUI_ENABLED
	bra	+
.textui_disable
	lda	.screen_status
	and	#!.TEXTUI_ENABLED
+	sta	.screen_status
	rts

.textui_put
	sta	(crs_ptr)
	bra	.textui_screen_dirty
    
.textui_print
	inc .screen_status	;write on
	ldy	#$00
-	lda	(msgptr),y
	beq	+
	jsr .textui_dispatch_char
	iny
	bne	-
+	dec	.screen_status	;write off
	bra	.textui_screen_dirty

.textui_chrout
	beq	+	; \0 char
	pha		; safe char
 ;   sei
	inc .screen_status	;write on
;    cli
	jsr .textui_dispatch_char
	dec	.screen_status	;write off
	jsr	.textui_screen_dirty
	pla								; restore char
+	rts

	
; set crs x and y position absolutely - 0..32/0..23 or 0..39/0..23 40 char mode
;
.textui_crsxy
    stx crs_x
    sty crs_y
    jmp .textui_update_crs_ptr
    
.textui_dispatch_char
	cmp	#.KEY_CARIAGE_RETURN	;cariage return?
	bne	+
.textui_pos1
	stz	crs_x
	bra	+++
+	cmp	#.KEY_RETURN			;line feed
	bne	+
    jmp	.inc_cursor_y
+	cmp	#.KEY_BACKSPACE
	bne	+	
	lda	crs_x
	beq	++
	dec	crs_x
	lda	#' '			;blank the saved char
	sta	.saved_char		
	jmp	.textui_update_crs_ptr
++	lda	crs_y			; cursor y=0, no dec
	beq	+++
	dec	crs_y
	lda	#(.COLS-1)			; set x to end of line above
	sta	crs_x
	jmp	.textui_update_crs_ptr
+	sta	.saved_char         ; the trick, simple set saved value to plot as saved char, will be print by textui_update_crs_ptr
	lda	crs_x
	cmp	#(.COLS-1)
	beq +
	inc	crs_x
	jmp	.textui_update_crs_ptr
+	stz	crs_x
	jmp	.inc_cursor_y
+++	jmp	.textui_update_crs_ptr
	
.textui_screen_dirty
	lda	.screen_status		;set dirty
	ora	#.DIRTY
	sta	.screen_status
	rts