*= $d000

text_mode_40 = 1
num_ls_entries = $03

!src <defs.h.a>
!src <bios.h.a>
!src <via.h.a>
!src <fat32.h.a>
; !src <params.h.a>
; !src <errors.h.a>

!address {
	.shell_addr		= $d900
	.key = $10
}


kern_init
	sei
	
	stz .key	
	
	lda #<count
	sta via1t1cl            ; set low byte of count
	lda #>count
	sta via1t1ch            ; set high byte of count

	lda #%11000000
	sta via1ier             ; enable VIA1 T1 interrupts

	lda #%01000000
	sta via1acr             ; T1 continuous, PB7 disabled

	+SetVector .kern_irq, irqvec


	; read from keyboard buffer until empty to filter crap from kbd init
	; select keyboard controller
	lda #%01111010
	sta via1portb

-	jsr spi_r_byte
	bne -

	; deselect keyboard controller
	lda #%01111110
	sta via1portb


	jsr	.textui_init0

	+SetVector _textui_chrout, outvec


	cli
	
	+SetVector .kernel_version, msgptr
	jsr strout

	jsr init_sdcard

	; check errno. if != 00, sd card init failed.
	; do not attempt to mount card, jump to upload instead
	lda errno
	bne .error

	lda #%01111110
	sta via1portb

	jsr .fat_mount 
	lda errno
	bne .error 

	+SetVector .filename, filenameptr
	jsr .fat_open 
	lda errno
	bne .error 

	+SetVector .shell_addr, sd_blkptr
	jsr .fat_read
	lda errno
	bne .error 

	jsr .fat_close

	ldx #$ff 
	txs 
	
	jmp .shell_addr	

.error
	; Card could not be mounted, contains no shell.bin, whatever
	; serial upload it is
	
	jsr .upload
	ldx #$ff 
	txs 
	
	jmp (.startaddr)

.keyin
-	lda .key 		; wait for .key to become != 00
	beq -
	stz .key 		; reset .key to signal isr to fetch next key
	rts

.getkey
	lda .key 		; wait for .key to become != 00	
	stz .key 		; reset .key to signal isr to fetch next key
	rts


; system interrupt handler
; handle keyboard input and text screen refresh
.kern_irq
	+save

	;via
	bit via1ifr		; Interrupt from VIA?
	bpl +			; no? get out

	bit via1t1cl	; Acknowledge timer interrupt

	lda .key		; already char in buffer? do nothing
	bne +

	; jsr getkey
	lda via1portb
	and #%01111110
	cmp #$7e
	bne +

	lda #%01111010
	; and via1portb
	sta via1portb

	TAX             ; aufheben
    ORA #$01
    !for .i,0,7 {
		STA via1portb ; Takt An 1
		STX via1portb ; Takt aus  
    }
       
	ldx #%11111110
	stx via1portb

	lda via1sr
	cmp #$00
	beq +
	sta .key

+
	bit	a_vreg
	bpl +	   ; VDP IRQ flag set?

	jsr	.textui_update_screen
+
	+restore
	rti

!src "textui.a"
!src "gfxui.a"
!src <fat.a>
.upload
	+PrintString .crlf
	+PrintString .serial_upload
	; ldy #param_baud
	; lda (paramvec),y

	; jsr hexout
	+PrintString .crlf

	jsr .textui_screen_dirty

	; load start address
	jsr uart_rx
	sta .startaddr
	
	jsr uart_rx
	sta .startaddr+1

	lda .startaddr+1
	jsr hexout
	lda .startaddr
	jsr hexout

	lda #' '
	jsr chrout
	jsr .textui_screen_dirty

	jsr .upload_ok
	
	; load number of bytes to be uploaded
	jsr uart_rx
	sta .length
		
	jsr uart_rx
	sta .length+1

	; calculate end address
	clc
	lda .length
	adc .startaddr
	sta .endaddr

	lda .length+1
	adc .startaddr+1
	sta .endaddr+1

	lda .endaddr+1
	jsr hexout

	lda .endaddr
	jsr hexout
	
	lda #' '
	jsr chrout

	jsr .textui_screen_dirty
	sei 
	lda .startaddr
	sta .addr
	lda .startaddr+1
	sta .addr+1	

	jsr .upload_ok
	

	ldy #$00
-	jsr uart_rx
	sta (.addr),y

	iny	
	cpy #$00
	bne +
	inc .addr+1
+		

	; msb of current address equals msb of end address?
	lda .addr+1
	cmp .endaddr+1
	bne - ; no? read next byte

	; yes? compare y to lsb of endaddr
	cpy .endaddr
	bne - ; no? read next byte

	; yes? write OK and jump to start addr	

	jsr .upload_ok
	cli 

	lda #'O'
	jsr chrout
	lda #'K'
	jsr chrout

	rts

.upload_ok
	lda #'O'
	jsr uart_tx
	lda #'K'
	jsr uart_tx
	rts


; strings
.kernel_version 			!text "SteckOS Kernel 0.2a",$0d,$0a,$00
.crlf						!byte $0a,$0d,$00
.txt_msg_loading 			!text "Loading ",$00
.serial_upload				!text "Serial Upload ",$00
.filename					!text "shell.bin",$00
*=$d800
; "kernel" jumptable
krn_keyin			jmp .keyin
krn_mount 			jmp .fat_mount 
krn_open 			jmp .fat_open
krn_read_dir		jmp .fat_dir_scan
krn_close 			jmp .fat_close
krn_read 			jmp .fat_read 
krn_open_rootdir 	jmp .fat_open_rootdir

krn_textui_init 		jmp	.textui_init
krn_textui_enable		jmp	.textui_enable
krn_textui_disable		jmp .textui_disable			;disable textui
krn_gfxui_init			jmp	.gfxui_init
krn_display_off			jmp vdp_display_off
krn_getkey				jmp .getkey

