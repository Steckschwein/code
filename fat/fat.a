*=$1000
!src "../bios/defs.h.a"
!src "../bios/bios.h.a"
!src "../vdp/t9929.h.a"

!src "fat32.h.a"

!macro Copy .src, .trgt, .len {
	phx
	ldx #$00
-	lda .src,x
	sta .trgt,x
	inx
	cpx #.len+1
	bne -
	plx
; !for i,0,.len {
; 	lda .src  + i
; 	sta .trgt + i
; }
}

!macro SDBlockAddr .src {
	lda .src + 3
	sta sd_cmd_param+0
	lda .src + 2
	sta sd_cmd_param+1
	lda .src + 1
	sta sd_cmd_param+2
	lda .src + 0
	sta sd_cmd_param+3
}

!address {

fat_errno	 		= $0300
fat_begin_lba 		= $0310 ; Begin of FAT32, 4 bytes
fat_reserved_sect 	= $0314 ; number of reserved sectors, 2 bytes
cluster_begin_lba 	= $0316 ; begin of cluster area, 4 bytes
sectors_per_fat 	= $0320 ; sectors per fat, 4 bytes
sectors_per_cluster = $0324 ; sectors per cluster, 1 byte
lba_addr			= $0325 ; lba address, 4 bytes
cluster_number		= $0329

sd_blktarget 		= $0400


steckos_start		= $c000	

}



main

    ;lda #dev_uart
    stz chn_out
	sei

	; jsr lcdclear

	jsr fat_mount

	; just use cluster_begin_lba if reading root dir cluster
	+Copy cluster_begin_lba, lba_addr, 3

	; Calculate cluster LBA address for anything else
	; jsr calc_lba_addr

	jsr fat_read_dir

	jsr sd_deselect_card

-	jmp -


fat_check_signature
	; pha
	stz fat_errno

	lda sd_blktarget + BS_Signature
	cmp #$55
	bne +
	lda sd_blktarget + BS_Signature+1
	cmp #$aa
	bne +
	
	; pla
	rts

+	inc fat_errno
	; pla
	rts

calc_lba_addr
	pha
	phx

	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;

	sec
	lda cluster_number 
	sbc #$02
	sta cluster_number 

!for i,1,3 {
	lda cluster_number + i 
	sbc #$00
	sta cluster_number + i
}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster

-	clc
!for i,0,3 {
	lda cluster_number + i
	adc lba_addr + i
	sta lba_addr + i	
}
	dex
	bne -

	plx
	pla

	rts

fat_mount
	jsr sd_select_card
	jsr sd_param_init

	+SetVector sd_blktarget, sd_blkptr

	jsr sd_read_block
	jsr fat_check_signature

	pha
	phx

	lda fat_errno
	beq +
	+PrintString fat_err_signature
-	jmp -

+	
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	+PrintString fat_err_partition
-	jmp -

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta fat_begin_lba,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	+SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr
	; Read FAT Volume ID at LBABegin and Check signature
	jsr sd_read_block

	jsr fat_check_signature
	lda fat_errno
	beq +
	+PrintString fat_err_signature
-	jmp -

+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +

	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	+PrintString fat_err_bad_sect_size
-	jmp -
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; Number of reserved Sectors, $20
	lda sd_blktarget + BPB_RsvdSecCnt + 1
	sta fat_reserved_sect + 1 

	lda sd_blktarget + BPB_RsvdSecCnt 
	sta fat_reserved_sect 

	ldx #$00
-	
	lda sd_blktarget + BPB_FATSz32,x
	sta sectors_per_fat,x
	inx
	cpx #$04
	bne -

	ldx #$00
-	
	lda sd_blktarget + BPB_RootClus,x
	sta cluster_number,x
	inx
	cpx #$04
	bne -

	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	clc
!for i,0,1 {
	lda fat_begin_lba + i
	adc fat_reserved_sect + i
	sta cluster_begin_lba + i	
}

!for i,2,3 {
	lda fat_begin_lba + i
	adc #$00
	sta cluster_begin_lba + i	
}


	; Number of FATs. Must be 2
	; lda sd_blktarget + BPB_NumFATs

	clc
	ldx #$00
--
	lda sectors_per_fat,x
	asl ; * 2
	adc cluster_begin_lba,x
	sta cluster_begin_lba,x
	inx
	cpx #$04
	bne --	

	plx
	; ply
	pla

	rts


fat_read_dir
	pha
	phy
	phx

	jsr sd_param_init

-	+SetVector sd_blktarget, sd_blkptr
	+SDBlockAddr lba_addr
	jsr sd_read_block


--	ldy #DIR_Attr
	lda (sd_blkptr),y
	cmp #$0f ; Long filename, skip this one
	beq +
	bit #$02 ; Hidden attribute set, skip
	bne +

	tax
    ldy #DIR_Name
	lda (sd_blkptr),y

	beq .end ; end of dir 
	
	cmp #$e5 ; deleted file
	beq +    ; skip

	jsr fat_list_entry

	txa
    bit #$04 ; System attribute. load file  	
 	bne .load

+
	; Increment blkptr by 32 bytes, jump to next dir entry
	clc
	lda sd_blkptr
	adc #32
	sta sd_blkptr
	bcc +
	inc sd_blkptr+1	
+	
	; end of block?
	lda sd_blkptr+1
	cmp #06
	bne -- ; no

	; yes, increase lba_addr and go again
	+SetVector sd_blktarget, sd_blkptr
	clc
	lda lba_addr + 0
	adc #$01
	sta lba_addr + 0
	lda lba_addr + 1
	adc #$00
	sta lba_addr + 1
	lda lba_addr + 2
	adc #$00
	sta lba_addr + 2
	lda lba_addr + 3
	adc #$00
	sta lba_addr + 3

	jmp -


.end
	ply
	plx
	pla
	rts

.load
	+PrintString fat_loading

	ldy #DIR_Name
-	lda (sd_blkptr),y
	
	phy
	jsr chrout
	ply

	iny
	cpy #$0b
	bne -


	ldy #DIR_FstClusHI +1
	lda (sd_blkptr),y
	sta cluster_number +3

	dey
	lda (sd_blkptr),y
	sta cluster_number +2

	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta cluster_number +1
	dey
	lda (sd_blkptr),y
	sta cluster_number 

	+Copy cluster_begin_lba, lba_addr, 3

	jsr calc_lba_addr

	+SetVector steckos_start, sd_blkptr
	+SDBlockAddr lba_addr
	jsr sd_read_block

	+PrintString fat_loading_done

	; Reset StackPointer
	ldx #$ff
	txs
	; Disable IRQ
	sei

	jmp steckos_start


fat_list_entry
	ldy #DIR_Name
-	lda (sd_blkptr),y
	phy
	jsr chrout
	ply
	iny
	cpy #DIR_Name + $0b

	bne -

	jsr space

	ldy #DIR_FileSize + 3 +1
-	dey
	lda (sd_blkptr),y
	jsr hexout
	cpy #DIR_FileSize
	bne -	

	jsr space


	ldy #DIR_Attr
	lda (sd_blkptr),y

 	bit #$10 ; Is a directory
    beq +
    lda #'D'
    bra ++ 

+	bit #$04 ; Is system
	beq +
    lda #'S'
    bra ++
 
+	bit #$08 ; Is volume ID
	beq +
    lda #'V'
    bra ++ 
+	
	lda #'F'
++	jsr chrout
	jsr crlf
	rts


crlf
	; lda #$0d
	; jsr chrout
	; lda #13
	; jsr chrout
	inc crs_y
	stz crs_x
	rts

space 
	lda #' '
	jsr chrout
	rts



!address {
N 	  = tmp0
CARRY = tmp7
}

div3216
	    SEC             ; Detect overflow or /0 condition.
        LDA     N+2     ; Divisor must be more than high cell of dividend.  To
        SBC     N       ; find out, subtract divisor from high cell of dividend;
        LDA     N+3     ; if carry flag is still set at the end, the divisor was
        SBC     N+1     ; not big enough to avoid overflow. This also takes care
        BCS     ++  	; of any /0 condition.  Branch if overflow or /0 error.
                        ; We will loop 16 times; but since we shift the dividend
        LDX     #$11    ; over at the same time as shifting the answer in, the
                        ; operation must start AND finish with a shift of the
                        ; low cell of the dividend (which ends up holding the
                        ; quotient), so we start with 17 (11H) in X.
-		ROL     N+4     ; Move low cell of dividend left one bit, also shifting
        ROL     N+5     ; answer in. The 1st rotation brings in a 0, which later
                        ; gets pushed off the other end in the last rotation.
        DEX
        BEQ     +		; Branch to the end if finished.

        ROL     N+2     ; Shift high cell of dividend left one bit, also
        ROL     N+3     ; shifting next bit in from high bit of low cell.
        STZ     CARRY   ; Zero old bits of CARRY so subtraction works right.
        ROL     CARRY   ; Store old high bit of dividend in CARRY.  (For STZ
                        ; one line up, NMOS 6502 will need LDA #0, STA CARRY.)
        SEC             ; See if divisor will fit into high 17 bits of dividend
        LDA     N+2     ; by subtracting and then looking at carry flag.
        SBC     N       ; First do low byte.
        STA     N+6     ; Save difference low byte until we know if we need it.
        LDA     N+3     ;
        SBC     N+1     ; Then do high byte.
        TAY             ; Save difference high byte until we know if we need it.
        LDA     CARRY   ; Bit 0 of CARRY serves as 17th bit.
        SBC     #0      ; Complete the subtraction by doing the 17th bit before
        BCC     -	    ; determining if the divisor fit into the high 17 bits
                        ; of the dividend.  If so, the carry flag remains set.
        LDA     N+6     ; If divisor fit into dividend high 17 bits, update
        STA     N+2     ; dividend high cell to what it would be after
        STY     N+3     ; subtraction.
        BRA     -	    ; Always branch.  NMOS 6502 could use BCS here.

++		LDA     #$FF    ; If overflow occurred, put FF
        STA     N+2     ; in remainder low byte
        STA     N+3     ; and high byte,
        STA     N+4     ; and in quotient low byte
        STA     N+5     ; and high byte.
+		RTS
;-----------------------------
;fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
;cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);
fat_err_signature 		!text "bad block signature", $00
fat_err_partition 		!text "invalid partition type", $00
fat_err_bad_sect_size 	!text "sector size unsupported", $00
fat_err_num_fats	  	!text "invalid number of FATs (!= 2)", $00
fat_loading		  		!text "Loading ",$00
fat_loading_done  		!text " done.",$00

!src "../vdp/t99xx.lib.a"

