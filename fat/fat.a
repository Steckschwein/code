*=$c000
!src "../bios/defs.h.a"
!src "../bios/bios.h.a"
;!src "../vdp/t9929.h.a"

!src "fat32.h.a"

	
!macro Copy .src, .trgt, .len {
	phx
	ldx #$00
-	lda .src,x
	sta .trgt,x
	inx
	cpx #.len+1
	bne -
	plx
; !for i,0,.len {
; 	lda .src  + i
; 	sta .trgt + i
; }
}

!macro SDBlockAddr .src {
	lda .src + 3
	sta sd_cmd_param+0
	lda .src + 2
	sta sd_cmd_param+1
	lda .src + 1
	sta sd_cmd_param+2
	lda .src + 0
	sta sd_cmd_param+3
}
!macro debug .x {
	lda #.x
	jsr lcdprint
} 
!macro debug32 .x {
!for i,3,0 {
	lda .x+i
	jsr lcdhex
}
}
!address {

fat_errno	 		= $0300
fat_begin_lba 		= $0310 ; Begin of FAT32, 4 bytes
fat_reserved_sect 	= $0314 ; number of reserved sectors, 2 bytes
cluster_begin_lba 	= $0316 ; begin of cluster area, 4 bytes
sectors_per_fat 	= $0320 ; sectors per fat, 4 bytes
sectors_per_cluster = $0324 ; sectors per cluster, 1 byte
lba_addr			= $0325 ; lba address, 4 bytes
cluster_number		= $0329

sd_blktarget 		= $0400

steckos_start		= $1000	

dividend = $c0
divisor = $c4
remainder = $c6
result = dividend
}

main
	jsr lcdclear
	lda #dev_uart
    sta chn_out
    stz chn_in

    jsr chrin
	lda #dev_uart

	sei

	; always divide by 512 (sector size)
	lda #$02
	sta divisor + 1
	lda #$00
	sta divisor + 0

	jsr sd_select_card
	jsr sd_param_init

	jsr fat_mount
	lda fat_errno
	bne .fat_end


	; just use cluster_begin_lba if reading root dir cluster
	+Copy cluster_begin_lba, lba_addr, 3

	; Calculate cluster LBA address for anything else
	; jsr calc_lba_addr

	jsr fat_read_dir
	lda fat_errno
	bne .fat_end

.fat_end
	jsr sd_deselect_card

-	jmp -


fat_check_signature
	; pha
	stz fat_errno

	lda sd_blktarget + BS_Signature
	cmp #$55
	bne +
	lda sd_blktarget + BS_Signature+1
	cmp #$aa
	bne +
	
	; pla
	rts

+	inc fat_errno
	; pla
	rts

calc_lba_addr
	pha
	phx

	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;

	sec
	lda cluster_number 
	sbc #$02
	sta cluster_number 

!for i,1,3 {
	lda cluster_number + i 
	sbc #$00
	sta cluster_number + i
}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster

-	clc
!for i,0,3 {
	lda cluster_number + i
	adc lba_addr + i
	sta lba_addr + i	
}
	dex
	bne -

	plx
	pla

	rts

fat_mount
	+SetVector sd_blktarget, sd_blkptr

	jsr sd_read_block
	jsr fat_check_signature

	pha
	phx

	lda fat_errno
	beq +
	+PrintString fat_err_signature
-	jmp -

+	
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	+PrintString fat_err_partition
-	jmp -

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta fat_begin_lba,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	+SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr
	; Read FAT Volume ID at LBABegin and Check signature
	jsr sd_read_block

	jsr fat_check_signature
	lda fat_errno
	beq +
	+PrintString fat_err_signature
	jmp .end_mount

+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +

	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	+PrintString fat_err_bad_sect_size
	jmp .end_mount
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; Number of reserved Sectors, $20
	lda sd_blktarget + BPB_RsvdSecCnt + 1
	sta fat_reserved_sect + 1 

	lda sd_blktarget + BPB_RsvdSecCnt 
	sta fat_reserved_sect 

	ldx #$00
-	
	lda sd_blktarget + BPB_FATSz32,x
	sta sectors_per_fat,x
	inx
	cpx #$04
	bne -

	ldx #$00
-	
	lda sd_blktarget + BPB_RootClus,x
	sta cluster_number,x
	inx
	cpx #$04
	bne -

	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	; add number of reserved sectors to fat_begin_lba. store in cluster_begin_lba
	clc
!for i,0,1 {
	lda fat_begin_lba + i
	adc fat_reserved_sect + i
	sta cluster_begin_lba + i	
}
!for i,2,3 {
	lda fat_begin_lba + i
	adc #$00
	sta cluster_begin_lba + i
}

	; Number of FATs. Must be 2
	; lda sd_blktarget + BPB_NumFATs	
	; add sectors_per_fat * 2 to cluster_begin_lba
	clc
!for i,0,3 {	
	lda sectors_per_fat + i
	rol ; *2 (2 FATs)
	adc cluster_begin_lba + i
	sta cluster_begin_lba + i
}

	; now we have the lba address of the first sector of the first cluster
	; +debug32 cluster_begin_lba
.end_mount
	plx
	; ply
	pla

	rts


fat_read_dir
	; lda fat_errno
	; jsr lcdhex

	pha
	phy
	phx

	jsr sd_param_init

-	+SetVector sd_blktarget, sd_blkptr
	+SDBlockAddr lba_addr
	jsr sd_read_block
	
--	ldy #DIR_Attr
	lda (sd_blkptr),y
	cmp #$0f ; Long filename, skip this one
	beq +
	bit #$02 ; Hidden attribute set, skip
	bne +

	tax
    ldy #DIR_Name
	lda (sd_blkptr),y

	beq .end ; end of dir 
	
	cmp #$e5 ; deleted file
	beq +    ; skip

	jsr fat_list_entry

	txa
    bit #$04 ; System attribute. load file  	
 	bne .load

+
	; Increment blkptr by 32 bytes, jump to next dir entry
	clc
	lda sd_blkptr
	adc #32
	sta sd_blkptr
	bcc +
	inc sd_blkptr+1	
+	
	; end of block?
	lda sd_blkptr+1
	cmp #06
	bne -- ; no

	; yes, increase lba_addr and go again
	+SetVector sd_blktarget, sd_blkptr
	jsr inc_lba_address
	jmp -

.end
	ply
	plx
	pla
	rts

.load
	+PrintString fat_loading

	ldy #DIR_Name
-	lda (sd_blkptr),y
	
	jsr chrout

	iny
	cpy #$0b
	bne -

	jsr crlf


!for i,3,0 {
	ldy #DIR_FileSize + i
	lda (sd_blkptr),y
	sta dividend + i
}
	jsr lcdclear

	jsr divide

	lda result + 0
	sta tmp7

	; remainder > 0, increase x
	clc
	lda remainder +1
	adc remainder +0
	beq +
	inc tmp7
+	

	lda tmp7
	
	ldy #DIR_FstClusHI +1
	lda (sd_blkptr),y
	sta cluster_number +3

	dey
	lda (sd_blkptr),y
	sta cluster_number +2

	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta cluster_number +1
	dey
	lda (sd_blkptr),y
	sta cluster_number 

	+Copy cluster_begin_lba, lba_addr, 3

	jsr calc_lba_addr

	+SetVector steckos_start, sd_blkptr
-	+SDBlockAddr lba_addr
	jsr sd_read_block
	
	+PrintChar '.'

	dec tmp7
	beq + ; zero, we're done

	; increase lba_addy by 1

	jsr inc_lba_address

	clc
	lda sd_blkptr + 1
	adc #$02
	sta sd_blkptr + 1
	
	; ready to read next block
	bra -

+
	+PrintString fat_loading_done

	jsr sd_deselect_card

	; Reset StackPointer
	ldx #$ff
	txs
	; Disable IRQ
	sei


	jmp steckos_start


inc_lba_address
	clc
	lda lba_addr + 0
	adc #$01
	sta lba_addr + 0
	lda lba_addr + 1
	adc #$00
	sta lba_addr + 1
	lda lba_addr + 2
	adc #$00
	sta lba_addr + 2
	lda lba_addr + 3
	adc #$00
	sta lba_addr + 3

	rts


fat_list_entry
	ldy #DIR_Name
-	lda (sd_blkptr),y
	phy
	jsr chrout
	ply
	iny
	cpy #DIR_Name + $0b

	bne -

	jsr space

	ldy #DIR_FileSize + 3 +1
-	dey
	lda (sd_blkptr),y
	jsr hexout
	cpy #DIR_FileSize
	bne -	

	jsr space


	ldy #DIR_Attr
	lda (sd_blkptr),y

 	bit #$10 ; Is a directory
    beq +
    lda #'D'
    bra ++ 

+	bit #$04 ; Is system
	beq +
    lda #'S'
    bra ++
 
+	bit #$08 ; Is volume ID
	beq +
    lda #'V'
    bra ++ 
+	
	lda #'F'
++	jsr chrout
	jsr crlf
	rts


crlf
	lda #$0d
	jsr chrout
	lda #$0a
	jsr chrout
	; inc crs_y
	; stz crs_x
	rts

space 
		lda #' '
		jsr chrout
		rts

divide	lda #0	        ;preset remainder to 0
		sta remainder
		sta remainder+1
		ldx #16	        ;repeat for each bit: ...

divloop	asl dividend	;dividend lb & hb*2, msb -> Carry
		rol dividend+1	
		rol remainder	;remainder lb & hb * 2 + msb from carry
		rol remainder+1
		lda remainder
		sec
		sbc divisor	;substract divisor to see if it fits in
		tay	        ;lb result -> Y, for we may need it later
		lda remainder+1
		sbc divisor+1
		bcc skip	;if carry=0 then divisor didn't fit in yet

		sta remainder+1	;else save substraction result as new remainder,
		sty remainder	
		inc result	;and INCrement result cause divisor fit in 1 times

skip	dex
		bne divloop	
		rts


;fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
;cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);
fat_err_signature 		!text "bad block signature", $00
fat_err_partition 		!text "invalid partition type", $00
fat_err_bad_sect_size 	!text "sector size unsupported", $00
fat_err_num_fats	  	!text "invalid number of FATs (!= 2)", $00
fat_loading		  		!text "Loading ",$00
fat_loading_done  		!text " done.",$00

;!src "../vdp/t99xx.lib.a"

