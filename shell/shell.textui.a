!source <t99xx.lib.a>

;text_mode_40 = 1

.sprite_sanduhr
	!byte	$ff,	$f0,	0,	Gray
	
.screen=$c000
.screen_status !byte .TEXTUI_ENABLED
.screen_frames !byte 0
.saved_char	!byte ' '

.cursor_char = 18

.ROWS=24

.KEY_RETURN=$0d
.KEY_BACKSPACE=$08

.WRITE=1<<0
.DIRTY=1<<1
.CURSOR=1<<2
.CURSOR_BUSY=1<<3
.TEXTUI_ENABLED=1<<4

!ifdef text_mode_40 {
.charset=.charset_6x8	; loaded after shell code, see shell.a
.COLS=40
.textui_update_crs_ptr
	pha
	lda	crs_y	; * .COLS
	asl	
	asl
	asl
	sta	tmp0	
	asl			
	asl
	clc
	adc	tmp0	; offs= y*.COLS -> y*40 = y*8+y*32	+ x
	clc
	adc	crs_x
	sta	crs_ptr
	lda	#$00	;add with carry
	adc	#>.screen
	sta	crs_ptr+1
;	0 6 12 18
	lda	crs_y	; * .COLS
	lsr			; /6 -> page offset 0-3 => y/6 = y/(2*2+2)
	lsr
	lsr
	clc
	adc	#>.screen
	sta	crs_ptr+1
	pla
	rts
}

!ifndef text_mode_40 {
.charset=charset	; the one from ROM
.COLS=32
.textui_update_crs_ptr
	pha
	lda	crs_y
	asl	
	asl
	asl
	asl			
	asl			; offs= y*.COLS
	ora	crs_x
	sta	crs_ptr
	
	lda	crs_y	; * .COLS
	lsr			; /8 -> page offset 0-2
	lsr
	lsr
	clc
	adc	#>.screen
	sta	crs_ptr+1
	pla
	rts
}

.textui_init0
	jsr	vdp_display_off			;display off
	
	jsr vdp_mode_gfx1_sprites_off
	
;	jsr vdp_mode_text_blank

	jsr	.textui_blank			;blank screen buffer
	
	stz	crs_x
	stz	crs_y
	jsr .textui_update_crs_ptr		;init cursor pointer
	
.textui_init
	+SetVector .charset, .adrl	;setup vram with charset
	jsr	.mirror_charset
	
	+SetVector	.charset, .adrl
	lda	#$00
	ldy	#.WRITE_ADDRESS+$00
	ldx	#$08					;load charset
	jsr	vdp_memcpy
	
	+SetVector	.assets, .adrl	;load cursor sprites to vram
	ldx	#$02*8
	lda	#$00
	ldy	#.WRITE_ADDRESS+$08
	jsr	vdp_load_sprites16x16
	
	jsr	vdp_mode_gfx1_sprites_off	;clean sprite attribute table
	+SetVector	.sprite_sanduhr, .adrl
	ldx	#$04
	lda	#$00
	ldy	#.WRITE_ADDRESS+$3c
	jsr	vdp_memcpys

!ifndef text_mode_40 {
	lda	#Medium_Green<<4|Black		;enable gfx 1
	jmp	vdp_mode_gfx1
}
!ifdef text_mode_40 {
	jmp	vdp_mode_text
}
	
.textui_blank
	ldx	#$00
	lda	#' '
-	sta	.screen,x
	sta	.screen+$100,x
	sta	.screen+$200,x
	sta	.screen+$300,x
	inx
	bne	-
-	sta	.screen+$400,x	;last line for scroll up
	inx
	cpx	#.COLS
	bne	-
	jmp	.textui_screen_dirty
	
.textui_cursor
	lda .screen_status
	and	#.WRITE
	bne	+++
	lda .screen_frames
	and	#$0f
	bne	+++
	lda	#.CURSOR
	tsb	.screen_status
	beq	+
	trb	.screen_status
  	lda	.saved_char
	jmp _textui_put
+	lda	(crs_ptr)			;save char
	sta	.saved_char
	; lda	#160
	lda	#.cursor_char
	jmp _textui_put
+++	rts

.textui_update_screen
	bit	a_vreg
	bmi +	   ; VDP IRQ flag set? 
	rts
+	
	lda	.screen_status
	and	#.TEXTUI_ENABLED
	bne	+
	rts
+
	;lda	#Gray
	;jsr	vdp_bgcolor	

	inc	.screen_frames
	jsr	.textui_busy

	jsr	.textui_cursor
	
	;TODO dirty check .screen_status AND 1 ...
	lda	.screen_status
	and	#.DIRTY
	beq	+		;exit if not dirty
	
	+SetVector	.screen, .adrl
	lda	#$00
	ldy	#.WRITE_ADDRESS+$18
	ldx	#$04
	jsr	vdp_memcpy
	
	lda	.screen_status		;clean dirty
	and	#!.DIRTY
	sta	.screen_status

+	lda	#Medium_Green<<4|Black
	jsr	vdp_bgcolor
	rts	

.textui_busy
	lda	.screen_status
	and	#.CURSOR_BUSY
	beq	+++
	lda	.screen_frames
	and	#$03
	bne	++
	lda	#$00
	ldy	#.WRITE_ADDRESS+$3c
	jsr vdp_sreg
	lda	#$ff		;y - $ff top 
	sta	a_vram		
	+vnops
	lda	#$f0		;x - $f0 before right border
	sta	a_vram		
	+vnops
	lda .sprite_sanduhr+2	;ptr
	sta	a_vram
	clc
	adc	#$04		;16x16 sprites, pointer * 4
	cmp	#$04*8
	bne	+
	lda	#$00
+	sta	.sprite_sanduhr+2
++	rts
+++	lda	#$00
	ldy	#.WRITE_ADDRESS+$3c
	jsr vdp_sreg
	lda #$d0		;y-pos off screen
	sta	a_vram
	rts
	
.textui_scroll_up
	ldx	#$00
-	lda	.screen+.COLS,x
	sta	.screen,x
	inx
	bne	-
-	lda	.screen+256+.COLS,x
	sta	.screen+256,x
	inx
	bne	-
-	lda	.screen+512+.COLS,x
	sta	.screen+512,x
	inx
	bne	-
-	lda	.screen+$300+.COLS,x
	sta	.screen+$300,x
	inx
	bne	-
	rts
	
.inc_cursor_y
	lda crs_y
	cmp	#23		;last line
	bne	+
	jmp	.textui_scroll_up	; scroll and exit
+	inc crs_y
	rts

_textui_print
	inc .screen_status	;write on
	ldy	#$00
-	lda	(msgptr),y
	beq	+
	jsr .textui_dispatch_char
	iny
	bne	-
+	dec	.screen_status	;write off
	jmp	.textui_screen_dirty

_textui_chrout
	beq	+	; \0 char
	pha		; safe char
	inc .screen_status	;write on
	jsr .textui_dispatch_char
	dec	.screen_status	;write off
	jsr	.textui_screen_dirty
	pla								; restore char
+	rts

.textui_dispatch_char
	cmp	#$0a			;cariage return
	bne	+
	lda	.saved_char		
	sta	(crs_ptr)		;restore char at cursor position
	stz	crs_x
	bra	+++
+	cmp	#.KEY_RETURN			;line feed
	bne	+
	jsr	.inc_cursor_y
	bra	+++
+	cmp	#.KEY_BACKSPACE
	bne	+
	lda	crs_x
	beq	++
	dec	crs_x
	lda	#' '			;blank at char position and also the saved char 
	sta	.saved_char		
	sta	(crs_ptr)
	jsr	.textui_update_crs_ptr
	sta	(crs_ptr)		;also erase char at the new position
	rts
++	lda	crs_y			; cursor y=0, no dec
	beq	+++
	dec	crs_y
	lda	#(.COLS-1)			; set x to end of line above
	sta	crs_x
	bra	+++
+	sta	(crs_ptr)
	lda	crs_x
	cmp	#(.COLS-1)
	beq +
	inc	crs_x
	bra	+++
+	stz	crs_x
	jsr	.inc_cursor_y
+++	jmp	.textui_update_crs_ptr
	
.textui_screen_dirty
	lda	.screen_status		;set dirty
	ora	#.DIRTY
	sta	.screen_status
	rts

_textui_toggle_cursor_busy
	lda	#.CURSOR_BUSY
	tsb	.screen_status
	beq	+
	trb	.screen_status
+	rts
	
_textui_put
	sta	(crs_ptr)
	jmp	.textui_screen_dirty
	rts
	
_textui_println
	jmp	_textui_print

.textui_enable
	lda	.screen_status
	ora	#.TEXTUI_ENABLED
	bra	+
.textui_disable
	lda	.screen_status
	and	#!.TEXTUI_ENABLED
+	sta	.screen_status
	rts

.mirror_charset
	ldx	#$08
	ldy	#$00
-	stz	tmp0
	lda	(.adrl),y	;bit inverse
	asl
	ror	tmp0
	asl
	ror	tmp0
	asl
	ror	tmp0
	asl
	ror	tmp0
	asl
	ror	tmp0
	asl
	ror	tmp0	
	lda	tmp0
	sta	(.adrl),y
	iny
	bne	-
	inc	.adrh
	dex
	bne	-
	rts

!macro	V_ToggleCursorBusy {
	jsr	_textui_toggle_cursor_busy
}

!macro	V_SetBgColor .color {
	lda	.color
	jsr	vdp_bgcolor
}