*= $c800

text_mode_40 = 1

.nvram = $a000
!src <defs.h.a>
!src <bios.h.a>
!src <via.h.a>
!src <fat32.h.a>
!src <params.h.a>
!src <errors.h.a>

	jmp	.init0
!src "shell.textui.a"
!src "shell.gfxui.a"

!address {
.key = $10
.buf 				= $0350 ; Input buffer 80 bytes. end: $03a1
.paramptr			= $11
}

!macro ShellPrint {
	jsr chrout
}

!macro ShellPrintChar char {
	lda #char
    jsr chrout
}

!macro ShellPrintHex {
	jsr	hexout
}
!macro ShellPrintDec {
	; leading zero hack
	cmp #10
	bcs +
	pha
	+ShellPrintChar '0'
	pla
+	
	jsr decout
}

!macro ShellPrintString .word {
	+SetVector .word,	msgptr
	jsr _textui_print
}

.init0
	sei
	
	stz .key	
	+SetVector _textui_chrout, outvec


	
	lda #<count
	sta via1t1cl            ; set low byte of count
	lda #>count
	sta via1t1ch            ; set high byte of count

	lda #%11000000
	sta via1ier             ; enable VIA1 T1 interrupts

	lda #%01000000
	sta via1acr             ; T1 continuous, PB7 disabled

	+SetVector .irq, irqvec


	; read from keyboard buffer until empty to filter crap from kbd init
-	lda #%01111010
	sta via1portb

	TAX             ; aufheben
    ORA #$01
    !for .i,0,7 {
		STA via1portb ; Takt An 1
		STX via1portb ; Takt aus  
    }
       
	ldx #%11111110
	stx via1portb

	lda via1sr
	cmp #$00
	bne -

	jsr	.textui_init0
	
	
	cli
.init	
	sei
	jsr .init_sdcard
	cli
	lda sd_cmd_errno
	jsr hexout
	lda #%01111110
	sta via1portb
	; +V_ToggleCursorBusy	
	jsr .fat_mount
	; +V_ToggleCursorBusy
	

	jmp	.hello

	
	
mainloop
	+ShellPrintString .crlf
	+ShellPrintString .prompt
	ldx #$00
	stz .buf
	

.inputloop	
	jsr .keyin

	cmp #$0d ; return?
	beq .parse

	cmp #$08 ; backspace?
	beq .backspace

	sta .buf, x
	inx
-	stz .buf, x


	; prevent overflow of input buffer 
	cpx #80
	beq mainloop

	jsr chrout

	bra .inputloop

.backspace
	cpx #$00
	bne +
	stz .buf, x
	bra .inputloop	
+	dex
	bra -


.parse
	ldx #$00
-	ldy #$00
--	lda .cmdlist,x
	cmp #$ff
	beq .unknown


	cmp #$20
	beq .cmdfound
	cmp #$00
	beq .cmdfound

	cmp .buf,y
	bne +	; difference. this isnt the command were looking for

	iny
	inx

	bra --

	; next cmdlist entry
+
--	inx
	lda .cmdlist,x
	bne --
	inx
	inx
	inx
	bra -

.cmdfound

	; find begin of parameter part
-	iny
	lda .buf,y
	beq +
	cmp #$20
	beq -

	; add offset to first character of parameter to paramptr
+	+SetVector .buf, .paramptr
	tya

	clc
	adc .paramptr
	sta .paramptr

	inx
	jmp (.cmdlist,x) ; 65c02 FTW!!	

.unknown
	lda .buf
	beq +
	+ShellPrintString .txt_msg_unknown_cmd
+	jmp mainloop


!src <fat.a>
.dir
	+ShellPrintString .crlf
	jsr .fat_read_dir
	jmp mainloop


.cdroot
	+ShellPrintChar '/'
	jsr .fat_open_rootdir
	jmp mainloop 

.cd
	lda .paramptr
	sta filenameptr
	lda .paramptr+1
	sta filenameptr+1
	
	+ShellPrintString .crlf
	jsr .fat_open

	lda errno
	beq +
	jsr .errmsg
	; +ShellPrintString .txt_cd
+

-	jmp mainloop 


.load	
	jsr .readfile		
	
	lda errno
	bne -

	ldx #$ff
	txs

	php
	sei

	jsr .steckos_start

	plp
	jmp .init 

.type
	jsr .readfile
	lda errno
	bne +
	+ShellPrintString .crlf
	+ShellPrintString .steckos_start	

+	jmp mainloop
	
.gfxview
	jsr .readfile	; read data to .steckos_start ($1000)
	lda errno
	bne +
	jsr	.textui_disable			;disable textui
	jsr	.gfxui_init
-	jsr .keyin
	cmp #$0d ; wait return?
	bne	-
	jsr	vdp_display_off			;restore textui
	jsr	.textui_init
	jsr	.textui_enable

+	jmp mainloop

.readfile

	lda .paramptr
	sta filenameptr
	lda .paramptr+1
	sta filenameptr+1


	jsr .fat_open
 	sta tmp5
 
	lda errno
	bne +

	
	+SetVector .steckos_start, sd_blkptr
	lda tmp5
	; jsr .fat_read_singleblock
	jsr .fat_read

	lda tmp5
	jsr .fat_close
	
+	
	jsr .errmsg
	; plp	
	rts

.irq
	+save

	;via
	bit via1ifr		; Interrupt from VIA?
	bpl +			; no? get out

	bit via1t1cl	; Acknowledge timer interrupt

	lda .key		; already char in buffer? do nothing
	bne +

	; jsr getkey
	lda via1portb
	and #%01111110
	cmp #$7e
	bne +

	lda #%01111010
	; and via1portb
	sta via1portb

	TAX             ; aufheben
    ORA #$01
    !for .i,0,7 {
		STA via1portb ; Takt An 1
		STX via1portb ; Takt aus  
    }
       
	ldx #%11111110
	stx via1portb

	lda via1sr
	cmp #$00
	beq +
	sta .key

+
	jsr	.textui_update_screen
	
	+restore
	rti

.keyin
-	lda .key 		; wait for .key to become != 00
	beq -

	stz .key 		; reset .key to signal isr to fetch next key
	rts

.upload
	sei

	jsr upload

	ldx #$ff
	txs
	; jump to new code
	jmp (.startaddr)


	

.hello
	+ShellPrintString .crlf
	+ShellPrintString .hellotxt
	; +ShellPrintString .helptxt
	jmp mainloop

.help
	+ShellPrintString .crlf
	; +ShellPrintString .hellotxt
	+ShellPrintString .helptxt
	jmp mainloop


.date 
-	lda via1portb ; wait for spi bus to become free
    and #%01111110
    cmp #$7e
    bne -

    ; Select SPI SS for RTC
	lda #%01110110
	; and via1portb
	sta via1portb

    lda #$00
    jsr spi_rw_byte

    jsr spi_r_byte
    sta tmp6
	
	jsr spi_r_byte
    sta tmp7
	
	jsr spi_r_byte
    jsr hexout
	+ShellPrintChar ':'

	lda tmp7
    jsr hexout
	+ShellPrintChar ':'
	
	lda tmp6	
	jsr hexout




    jsr spi_r_byte
	+ShellPrintChar ' '

    jsr spi_r_byte
    jsr hexout
    +ShellPrintChar '.'
	
	jsr spi_r_byte
    jsr hexout
    +ShellPrintChar '.'
	
	jsr spi_r_byte
    jsr hexout

    lda #$7e
    sta via1portb

    jmp mainloop


.cmdlist
	!text "dir"
	!byte $00
	!word .dir

	!text "ll"
	!byte $00
	!word .dir

	!text "load"
	!byte $00
	!word .load

	!text "type"
	!byte $00
	!word .type

	!text "view"
	!byte $00	
	!word .gfxview

	!text "cd"
	!byte $00	
	!word .cd

	!text "/"
	!byte $00	
	!word .cdroot
	
	!text "date"
	!byte $00	
	!word .date

	!text "upload"
	!byte $00	
	!word .upload

	!text "init"
	!byte $00	
	!word .init

	!text "help"
	!byte $00	
	!word .help
	
	; End of list
	!byte $ff

.init_sdcard
       ; 80 Taktzyklen
       ldx #74

       ; set ALL CS lines and DO to HIGH 
       lda #%11111110
       sta via1portb

       tay
       iny

-      sty via1portb
       sta via1portb
       dex
       bne -

       jsr sd_select_card
       
       jsr sd_param_init

       ; CMD0 needs CRC7 checksum to be correct
       lda #$95
       sta sd_cmd_chksum

       ; send CMD0 - init SD card to SPI mode
       lda #cmd0
       jsr sd_cmd

       ; get result
       lda #$ff
       jsr spi_rw_byte

       cmp #$01
       beq +

       ; No Card     
       lda #$ff
       sta sd_cmd_errno
       rts

+      lda #$01
       sta sd_cmd_param+2
       lda #$aa
       sta sd_cmd_param+3
       lda #$87
       sta sd_cmd_chksum

       jsr sd_busy_wait

       lda #cmd8
       jsr sd_cmd

       ldx #$00
-      
       lda #$ff
       phx
       jsr spi_rw_byte
       plx
       sta sd_cmd_result,x
       inx
       cpx #$05
       bne -

       lda sd_cmd_result
       cmp #$01
       beq +
       
       ; Invalid Card (or card we can't handle yet)
       lda #$0f
       sta sd_cmd_errno
       jsr sd_deselect_card 
       rts
+

-
       
       jsr sd_busy_wait

       jsr sd_param_init

       lda #cmd55
       jsr sd_cmd

       lda #$ff
       jsr spi_rw_byte

       cmp #$01
       beq + 

       ; Init failed
       lda #$f1      
       sta sd_cmd_errno
       rts 

+      lda #$40
       sta sd_cmd_param

       lda #$10
       sta sd_cmd_param+1

       lda #acmd41
       jsr sd_cmd

       lda #$ff
       jsr spi_r_byte

       cmp #$00
       bne -

       stz sd_cmd_param

       jsr sd_busy_wait

       lda #cmd58
       jsr sd_cmd

       ldx #$00
-      
       lda #$ff
       phx
       jsr spi_rw_byte
       plx
       sta sd_cmd_result,x
       inx
       cpx #$05
       bne -

       bit sd_cmd_result+1
       bvs +

       ; Set block size to 512 bytes
       lda #$02
       sta sd_cmd_param+2

       jsr sd_busy_wait
       
       lda #cmd16
       jsr sd_cmd

       lda #$ff
       jsr spi_rw_byte

+      

       ; SD card init successful
       stz sd_cmd_errno
       rts

sd_busy_wait
-      lda #$ff
       jsr spi_rw_byte
       cmp #$ff
       bne -
       rts

.errmsg
		
		+errMsgEntry fat_bad_block_signature, .fat_err_signature
		+errMsgEntry fat_invalid_partition_type, .fat_err_partition
		+errMsgEntry fat_invalid_sector_size, .fat_err_bad_sect_size
		+errMsgEntry fat_invalid_num_fats, .fat_err_bad_sect_size		
		+errMsgEntry fat_open_error, .fat_err_open
		+errMsgEntry fat_too_many_files, .fat_err_too_many_open
		+errMsgEntry fat_file_not_found, .fat_err_no_such_file
		+errMsgEntry fat_file_not_open, .fat_err_file_not_open

		jsr strout
		
		rts


.hellotxt		!text "SteckShell 0.08 ",$00
.helptxt		!text $0a,$0d,"dir         - directory"
				!text $0a,$0d,"/           - root dir"
				!text $0a,$0d,"cd <name>   - change directory"
				!text $0a,$0d,"load <name> - load file"
				!text $0a,$0d,"type <name> - display text file"
				!text $0a,$0d,"view <name> - display gfx file"
				!text $0a,$0d,"date        - show time and date"
.crlf			!byte $0a,$0d,$00
.prompt			!text ">",$00
.txt_msg_unknown_cmd	!text $0a,$0d,"unknown command (try 'help')",$00
.txt_cd 		!text "cd ok",$00

.fat_err_signature 		!text "bad block signature", $00
.fat_err_partition 		!text "invalid partition type", $00
.fat_err_bad_sect_size 	!text "sector size unsupported", $00
.fat_err_open			!text "open error",$00
.fat_err_no_such_file	!text "no such file or directory",$00
.fat_err_file_not_open	!text "file not open error",$00
.fat_err_too_many_open	!text "too many open files",$00


.assets
!ifndef text_mode_40 {
!src "sanduhr.raw"
!src "sanduhr_45.raw"
!src "sanduhr_90.raw"
!src "sanduhr_135.raw"
!src "sanduhr_180.raw"
!src "sanduhr_225.raw"
!src "sanduhr_270.raw"
!src "sanduhr_315.raw"
}
.sprite_sanduhr
	!byte	$ff,	$f0,	0,	Gray
