*=$1000
adrl     =$f0
adrh     =$f1
pattern  =$f2
TEXT_COLOR     = Dark_Green
TEXT_BGCOLORT  = Black
msgptr   =  $f4
!source "t9929.h.a"
VDP_WAIT_CYCLES = 4300; 4300Âµs after vertical blank int, means 0,0043s / 0,0000005s (time for one cpu cycle at 2Mhz) = 8600cycles = 4300 NOP's -
   jmp   main
msg_1	!text " HEY THOMAS, THESE ARE THE FIRST  LETTERS WRITTEN ON SCREEN WITH          THE TMS9929 VDP!         TODAY IS THE 15.04.2014          +++HAPPY BIRTHDAY+++           SO FAR... /MLA ;)", $00

main:   
   jsr   lcdclear
   lda   #'a'
   jsr   lcdprint
	jsr   vdp_init
   jsr   vdp_clear_vram
   jsr   vdp_load_charset
   jsr   vdp_blank_screen
   jsr   vdp_write
   jsr   vdp_color
   jsr   lcdclear
   lda   #'x'
   jsr   lcdprint
   ;jsr vdp_memtest
   ;jsr vdp_memtest_2
-
   jmp   -
vdp_init_bytes	!byte 0,$c0,$05,$80,$00,$40,$00,Dark_Green<<4|Black
vdp_init:
   ;reg 0 0 - ext. video off, 
   ;reg 1 c0 - 4108/4116 DRAM, int disabled, video on, text mode, size 1, magnitude off
   ;reg 2 
   ;reg 3
   ;reg 4
   ;reg 5
   ;reg 6
   ;reg 7 7 - cyan background color
   ldx   #$00
   ldy	#$80
-  +nops 8
   lda   vdp_init_bytes,x
   sta   a_vreg_w      ; write data to vdp
   +nops 8
   sty   a_vreg_w      ; write the register number to vdp, 80 - reg0 , 81 - reg1 ... see datasheet page 4.1
   iny
   inx
   cpx   #$08
   bne   -
   rts
vdp_sreg:
   +nops 8
   stx   a_vreg_w
   +nops 8
   sty   a_vreg_w
   rts
vdp_clear_vram:
   ldx   #$00
   ldy   #$40
   jsr   vdp_sreg
   lda   #$00
   ldx   #$00
   ldy   #$00
c1:
   +nops 32
   sta   a_vram_w
   inx
   bne   c1
   iny
   cpy   #$40
   bne   c1
   rts
vdp_load_charset:
   lda   #<charset_c64
   sta   adrl
   lda   #>charset_c64
   sta   adrh
   
   ldx   #$00
   ldy   #$40
   jsr   vdp_sreg
   ldx   #$00; page counter   
   ldy   #$00
-  +nops 16
   lda   (adrl),y
   sta   a_vram_w
   iny
   bne   -
   inc   adrh
   inx   
   cpx   #$08     ;2k charset - $0800
   bne   -
   rts

vdp_blank_screen:
   ldx   #$00
   ldy   #$54
   jsr   vdp_sreg
   lda   #$20
   ldx   #$00
   ldy   #$00
-  +nops 8
   sta   a_vram_w
   inx   
   bne   -
   iny
   cpy   #$04
   bne   -
   rts
   
vdp_write:
   ldx   #$00
   ldy   #$54
   jsr   vdp_sreg
   ldy   #$00
-
   lda   msg_1,y
   beq   +
   +nops 32
   sta   a_vram_w
   iny
   bne   -
+  rts
vdp_color:
   ldy   TEXT_COLOR<<4|Black
   ldx   #$00
   ldy   #$60
   jsr   vdp_sreg
-  +nops 32
   sty   a_vram_w
   inx
   cpx   #$20
   bne   -
   rts
vdp_memtest_2:
   jsr   lcdclear
   
   lda   #$00
   sta   adrl
   sta   adrh
   lda   #$96
   sta   pattern
   
;   jsr   vdp_wait_vb
   
   lda   a_vreg
   jsr   print_x   

   jsr   vdp_vram_read
   ldx   #$96
   jsr   vdp_vram_write
   +nops 16
   lda   #$69
   sta   a_vram_w
   +nops 16
   lda   #$f0
   sta   a_vram_w
   +nops 16
   lda   #$0f
   sta   a_vram_w
   
   jsr   vdp_vram_read
   pha
   +nops 8
   lda   a_vram
   pha
   +nops 8
   lda   a_vram
   pha
   +nops 8
   lda   a_vram
   jsr   print_x
   pla
   jsr   print_x
   pla
   jsr   print_x
   pla
   jsr   print_x
   
   rts
    
;   cmp   pattern
;   bne   -
;   inc   pattern
;   lda   $f2
;   cmp   #$02
;   bne   l1
;   inc   $f0
;   lda   $f0
;   cmp   #$ff
;   bne   l1

   rts
msg	!text "Mem ", $00 
; pointer for string output functions 
vdp_memtest
	jsr lcdclear
   lda a_vreg
   jsr lcdhex
   ldy #$ff
   ldx #$ff
-  nop
   dey
   bne   -
   dex
   bne   -

   lda   #$20
   jsr   lcdprint
   
   jsr   vdp_wait_vb
   
   lda   #$96
   jsr   vdp_vram_write
   lda   #$69
   sta   a_vram_w
   lda   #$11
   sta   a_vram_w
   
   lda   #$20
   jsr   lcdprint
   jsr   vdp_vram_read
   jsr   lcdhex
   lda   a_vram
   jsr   lcdhex
   lda   a_vram
   jsr   lcdhex

   rts

   jsr lcdclear  
  
	lda #<msg
	sta msgptr
	lda #>msg
	sta msgptr+1
	jsr lcdstring
   
   lda #$00
   sta adrh
   ldx #$00
-	stx a_vreg_w  ;low byte vram adress
   lda adrh
   ora #$40
   sta a_vreg_w  ;high byte vram 
   lda #$f0
   sta a_vram_w
   stx a_vreg_w
   lda adrh
   sta a_vreg_w
   lda a_vram
	cmp #$f0
	bne +
	inx
   bne -
	inc adrh
   lda adrh
   cmp #$40
   bne -
+	jsr lcdhex
   lda #$20
   jsr lcdprint
   lda adrh
	jsr lcdhex
	txa
	jsr lcdhex
   rts
   
vdp_vram_write:
   lda   adrl
   sta   a_vreg_w
   lda   adrh
   ora   #$40
   sta   a_vreg_w
   +nops 16
   stx   a_vram_w
   rts
vdp_vram_read:
   lda   adrl
   sta   a_vreg_w
   lda   adrh
   sta   a_vreg_w
   +nops 16
   lda   a_vram
   rts
   
vdp_bgcolor:
	stx   a_vreg
	lda   #vreg_r7
	sta   a_vreg
	rts
vdp_post:
   dex
   bne   vdp_post
   dey
   sty   $d400
   lda   #88
   sta   $d400
   jsr	lcdclear
   tya
   jsr	lcdprint
   rts   
vdp_wait_vb:
-  lda   a_vreg
   and   #$80
   bne -
     ldx   #10
l1:    ldy   #172
l2:   dey
      bne   l2
      dex
      bne   l1
      rts

i_nops_64
   +nops 16
i_nops_48
   +nops 16
i_nops_32
   +nops 16
i_nops
   +nops 16
   rts
   
  !source "char.ascii.a"
   
; TODO FIXME - JUSTT FOR TESTING
; LCD 
;----------------------------------------------------------------------------------------------
lcdctl		= $d200
lcddata		= lcdctl+1
; *** Clear LCD display and return cursor to home
; registers preserved
lcdclear 
         php
         pha
			jsr lcdbusy
			lda #$01
			sta lcdctl
			jsr lcdbusy
			lda #$80
			sta lcdctl
			jsr lcdbusy
			pla
         plp
			rts

; *** Wait for LCD busy bit to clear
; registers preserved
lcdbusy   
         pha
-			lda lcdctl            ;read from lcd register 0
			and #$80            ;check bit 7 (busy)
			bne -
			pla
			rts

; *** Print character on LCD (40 character)
; registers preserved
lcdprint
         pha
			sta lcddata            ;output the character
			jsr lcdbusy
			lda lcdctl            ;get current ddram address
			and #$7f
			cmp #$28          	;wrap from pos $13 (line 1 char 20)...
			bne +
			lda #$c0            	;...to $40 (line 2 char 1)
			sta lcdctl
			jsr lcdbusy
+			pla
			rts
         
; *** print string on lcd
; registers preserved
lcdstring
         pha                 ;save a, y to stack
			tya
			pha
			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr lcdprint
			iny
			bne -
+			pla                 ;restore a, y
			tay
			pla
			rts          
         
print_x:
         jsr   lcdhex
         lda   #$20
         jsr   lcdprint
         rts
; *** Print 2 digit hex number on LCD
; A, X registers preserved
; *** Lookup table for HEX to ASCII
hexascii	!text "0123456789ABCDEF"
lcdhex 
         pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd      
			pla
			rts          
!byte $00
!byte $00
!byte $00
!byte $00
!byte $00