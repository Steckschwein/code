
vdp_sreg:
	sta   a_vreg
	+nops	VRAM_WAIT
	sty   a_vreg
	rts
	
vdp_display_off:
	lda	#v_reg1_16k	;enable 16K ram, disable screen
	sta 	a_vreg
	+nops	VRAM_WAIT
	lda	  #v_reg1
	sta   a_vreg
	rts

;	input:
;	adrl/adrh vector set to vdp init table for al 8 vdp registers
vdp_init_reg:
	; setup video registers
   ldy	#$00
   ldx	#v_reg0
-  lda  (adrl),y
   sta   a_vreg
   +nops VRAM_WAIT
   stx   a_vreg
   iny
   inx
   cpy   #$08
   bne   -
   stz	crs_x
   stz	crs_y
   rts

vdp_mode_gfx1:
	+SetVector	vdp_init_bytes_gfx1, adrl
	jmp	vdp_init_reg
	
vdp_mode_gfx2:
	+SetVector	vdp_init_bytes_gfx2, adrl
	jmp	vdp_init_reg

vdp_init_bytes_gfx1
	!byte 0
	!byte v_reg1_16k|v_reg1_display_on|v_reg1_int
	!byte 	($1800 / $400)	; name table - value * $400
	!byte 	($2000 / $40)	; color table - value * $40 (gfx1), 7f/ff (gfx2)
	!byte 	($0000 / $800) ; pattern table (charset) - value * $800  --> offset in VRAM 
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 --> offset in VRAM
	!byte 	($0000 / $800)  ; sprite pattern table - value * $800  --> offset in VRAM
	!byte	Black
	
vdp_init_bytes_gfx2
	!byte v_reg0_m3
	!byte v_reg1_16k|v_reg1_display_on|v_reg1_int
	!byte ($3800 / $400)	; name table - value * $400
	!byte	$ff	; color table setting for gfx mode 2 --> only Bit 7 is taken into account 0 => $0000, 1 => $2000, Bit 6-0 AND to character number
	!byte	$03 	; pattern table, either $0000 (Bit 2 = 0) or $2000 (Bit 2=1), Bit 0,1 are AND to select the pattern array
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 --> offset in VRAM
	!byte	($1800 / $800)	; sprite pattern table - value * $800  --> offset in VRAM
	!byte	Black
   
;
;   input:	a - color
;
vdp_bgcolor:
	sei
	sta   a_vreg
	+nops	VRAM_WAIT
	lda   #v_reg7
	sta   a_vreg
	cli
	rts

vdp_load_sprites16:
;	input:
;	adrl/adrh vector set to sprite table
;	a - low byte vram adress
;	y - high byte vram adress
;  x - amount of sprites
	jsr	vdp_sreg
--	ldy	#$00
-	lda	(adrl),y
	+nops	VRAM_WAIT
	sta a_vram
	iny
	iny
	cpy	#$20
	bne	-
	ldy	#$00
	inc	adrl
-	lda	(adrl),y
	+nops	VRAM_WAIT
	sta a_vram
	iny
	iny
	cpy	#$20
	bne	-
	lda	adrl
	clc	
	adc	#$1f
	sta	adrl
	dex
	bne   --
	rts
	
;	input:
;	a - low byte vram adress
;	y - high byte vram adress
;  x - amount of bytes to fill with pattern
;	adrl - pattern
vdp_fills:
	jsr   vdp_sreg
	lda   adrl
-  +nops	VRAM_WAIT
	sta   a_vram
	dex
	bne	-
	rts
	
; fill vram with pattern
;
vdp_fill:
;	a - low byte vram adress
;	y - high byte vram adress
;	x - amount of 256byte blocks (page counter)
;	adrl - pattern
	jsr   vdp_sreg
   ldy   #$00
   lda   adrl
-  +nops	VRAM_WAIT
   sta   a_vram
   iny
   bne   -
   dex
   bne   -
   rts
	
;	input:
;	adrl/adrh vector set
;	a - low byte vram adress
;	y - high byte vram adress
;  x - amount of 256byte blocks (page counter)
vdp_memcpy:
	jsr   vdp_sreg
   ldy   #$00
-  lda   (adrl),y
   +nops	VRAM_WAIT
   sta   a_vram
   iny
   bne   -
   inc   adrh
   dex
   bne   -
   rts
	
;	input:
;	adrl/adrh vector set
;	a - low byte vram adress
;	y - high byte vram adress
;  x - amount of bytes to copy
vdp_memcpys:
	jsr	vdp_sreg
	ldy   #$00
-  lda   (adrl),y
	+nops	VRAM_WAIT
	sta   a_vram
	iny
	dex
	bne	-
	rts
	
vdp_print:
	ldy		#$00
	
--	jsr		vdp_set_addr
-	lda		(msgptr),y
	beq		++
	cmp		#$0d
	bne		+
	stz		crs_x
	inc		crs_y
	iny
	jmp		--
+	+nops 	VRAM_WAIT
	sta		a_vram
	inc 		crs_x
	iny
	bne		-
++	rts

vdp_chrout:
	tay
	jsr		vdp_set_addr
+	+nops 	VRAM_WAIT
	sty		a_vram
	inc	crs_x
	lda	crs_x
	and	#$20
	cmp	#$20
	bne	+
	stz	crs_x
	inc	crs_y
+	rts

vdp_set_addr:
	lda	crs_x
	lda	crs_y	; * 32
	asl	
	asl	
	asl	
	asl
	asl
	ora	crs_x
	sta	a_vreg	
	
	lda	crs_y	; * 32
	lsr			; /8 -> page offset 0-2
	lsr
	lsr
	clc
	adc	#$18+$40
	sta	a_vreg
	rts

vdp_xy:
	stx	crs_x
	sty	crs_y
	rts
	
!macro V_GotoXY .x, .y {
	lda	.x
	sta crs_x
	lda .y
	sta	crs_y
}
