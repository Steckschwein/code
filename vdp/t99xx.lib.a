;
;
;	TODO	
;		improve some functions,  avoid nop for vdp write delay 2Âµs by opcode reordering
;		investigate the difference between wdc and rockwell if no nop is used
;
;

.vdp_wait_blank
	sei
-	bit	a_vreg
	bmi -	   ; wait until blank - irq flag set?
	cli
	rts
	
vdp_sreg:
	sta	a_vreg
	+vnops
	nop
	sty   a_vreg
	rts


vdp_display_off:
	jsr	.vdp_wait_blank
	lda		#v_reg1_16k	;enable 16K ram, disable screen
	sta 	a_vreg
	+vnops
	lda	  	#v_reg1
	sta   	a_vreg
	rts

; setup video registers upon given table
;	input:
;	adrl/adrh vector set to vdp init table for al 8 vdp registers
vdp_init_reg:
	jsr		.vdp_wait_blank
	ldy	#$00
	ldx	#v_reg0
-  	lda  (.adrl),y
	sta   a_vreg
	+vnops
	iny				;iny first, burn cycle to avoid vdp nop
	stx   a_vreg
	inx
	cpy   #$08
	bne   -
	rts

;
;	requires	gfx2_mode_bitmap_address and gfx2_mode_ptr_bitmap_color_address setup correctly with the adresses to image and color data
;
gfx2_mode_bitmap_address 			!word $1000	;default data adress $1000
gfx2_mode_ptr_bitmap_color_address	!word $2800	;default data adress $2800
vdp_mode_gfx2_load_bitmap
	lda	gfx2_mode_bitmap_address
	sta	.adrl
	lda	gfx2_mode_bitmap_address+1
	sta	.adrh
	lda	#$00
	ldy	#$40+$00
	ldx	#$18	;6k bitmap - $1800
	jsr	vdp_memcpy					;load the pic data --> pattern table at vram $0000
	; load color
	lda	gfx2_mode_ptr_bitmap_color_address
	sta	.adrl
	lda	gfx2_mode_ptr_bitmap_color_address+1
	sta	.adrh
	lda	#$00
	ldy	#$40+$20
	ldx	#$18	;6k color map - $1800
	jmp	vdp_memcpy					;load the pic data --> color table at vram $2000

gfx3_mode_bitmap_address		!word	$1800
vdp_mode_gfx3_load_bitmap
	lda	gfx3_mode_bitmap_address
	sta	.adrl
	lda	gfx3_mode_bitmap_address+1
	sta	.adrh
	lda	#$00
	ldy	#$40+$00
	ldx	#$18	;6k bitmap - $1800
	jsr	vdp_memcpy					;load the pic data --> pattern table at vram $0000
	rts
	
;
;	text mode - 40x24 character mode, 16 colors with same color for 8 characters in a block
;
vdp_mode_text
	+SetVector vdp_init_bytes_text, .adrl
	jmp	vdp_init_reg

vdp_mode_text_blank
	ldx	#$04			; 4 x 256 bytes
	jmp	.vdp_mode_blank	
;
;	gfx mode 1 - 32x24 character mode, 16 colors with same color for 8 characters in a block
;
vdp_mode_gfx1:
	sta	.adrl		;set character color
	ldx	#$20
	lda	#$00
	ldy	#$40+$20	;color vram
	jsr	vdp_fills
	+SetVector vdp_init_bytes_gfx1, .adrl
	jmp	vdp_init_reg

vdp_mode_gfx1_blank:
	ldx	#$03
.vdp_mode_blank
	lda	#' '					;fill screen with blank
	sta	.adrl
	lda	#$00
	ldy	#$40+$18
	jmp	vdp_fill

vdp_mode_gfx1_sprites_off
vdp_mode_sprites_off
	lda	#$d0					;sprites off, at least y=$d0 will disable the sprite subsystem
	sta	.adrl
	ldx	#$32*4
	lda	#$00
	ldy	#$40+$3c
	jmp	vdp_fills
	
;
;	gfx 2 - each pixel can be adressed - e.g. for image
;	
vdp_mode_gfx2
	;set 768 different patterns --> name table
	lda	#$00
	ldy	#$40+$38
	jsr	vdp_sreg
	ldy	#$03
	ldx	#$00
-	+vnops
	stx	a_vram
	inx
	bne	-
	dey
	bne	-
	+SetVector	vdp_init_bytes_gfx2, .adrl
	jmp	vdp_init_reg

;
;	gfx 3 - 4x4 color block - multicolor mode
;	
vdp_mode_gfx3
	+SetVector	vdp_init_bytes_gfx3, .adrl
	jmp	vdp_init_reg

vdp_init_bytes_gfx1
	!byte 0
	!byte v_reg1_16k|v_reg1_display_on|v_reg1_int|v_reg1_spr_size
	!byte 	($1800 / $400)	; name table - value * $400					--> characters 
	!byte 	($2000 / $40)	; color table - value * $40 (gfx1), 7f/ff (gfx2)
	!byte 	($0000 / $800) ; pattern table (charset) - value * $800  	--> offset in VRAM 
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 		--> offset in VRAM
	!byte 	($0800 / $800)  ; sprite pattern table - value * $800  		--> offset in VRAM
	!byte	Black
	
vdp_init_bytes_text
	!byte 0
	!byte v_reg1_16k|v_reg1_display_on|v_reg1_m1
	!byte 	($1800 / $400)	; name table - value * $400					--> characters 
	!byte 	0	; not used
	!byte 	($0000 / $800) ; pattern table (charset) - value * $800  	--> offset in VRAM 
	!byte	0	; not used
	!byte 	0	; not used
	!byte	Medium_Green<<4|Black

vdp_init_bytes_gfx2
	!byte 	v_reg0_m3		; 
	!byte 	v_reg1_16k|v_reg1_display_on|v_reg1_spr_size; |v_reg1_int
	!byte 	($3800 / $400)	; name table - value * $400
	!byte	$ff				; color table setting for gfx mode 2 --> only Bit 7 is taken into account 0 => at vram $0000, 1 => at vram $2000, Bit 6-0 AND to character number
	!byte	$03 			; pattern table - either at vram $0000 (Bit 2 = 0) or at vram $2000 (Bit 2=1), Bit 0,1 are AND to select the pattern array
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 --> offset in VRAM
	!byte	($1800 / $800)	; sprite pattern table - value * $800  --> offset in VRAM
	!byte	Black

vdp_init_bytes_gfx3
	!byte 	0		; 
	!byte 	v_reg1_16k|v_reg1_display_on|v_reg1_m2|v_reg1_spr_size; |v_reg1_int
	!byte 	($3800 / $400)	; name table - value * $400
	!byte	$ff				; color table setting for gfx mode 2 --> only Bit 7 is taken into account 0 => at vram $0000, 1 => at vram $2000, Bit 6-0 AND to character number
	!byte	$03 			; pattern table - either at vram $0000 (Bit 2 = 0) or at vram $2000 (Bit 2=1), Bit 0,1 are AND to select the pattern array
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 --> offset in VRAM
	!byte	($1800 / $800)	; sprite pattern table - value * $800  --> offset in VRAM
	!byte	Black
	
;
;   input:	a - color
;
vdp_bgcolor:
	sta   a_vreg
	+vnops
	lda   #v_reg7
	sta   a_vreg
	rts

vdp_load_sprites16x16
vdp_load_sprites16
;	input:
;	adrl/adrh vector set to sprite table
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of sprites
	jsr	vdp_sreg
--	ldy	#$00
-	lda	(.adrl),y	
	+vnops
	sta a_vram
	iny
	iny
	cpy	#$20
	bne	-
	ldy	#$00
	inc	.adrl
-	lda	(.adrl),y	
	+vnops
	sta a_vram
	iny
	iny
	cpy	#$20
	bne	-
	lda	.adrl
	clc	
	adc	#$1f
	sta	.adrl
	dex
	bne   --
	rts
	
;	input:
;	a - low byte vram adress
;	y - high byte vram adress
;  x - amount of bytes to fill with pattern
;	adrl - pattern
vdp_fills:
	jsr   vdp_sreg
	lda   .adrl
-  	+vnops
	sta   a_vram
	dex
	bne	-
	rts
	
; fill vram with pattern
;
vdp_fill:
;	a - low byte vram adress
;	y - high byte vram adress
;	x - amount of 256byte blocks (page counter)
;	adrl - pattern
	jsr   vdp_sreg
	ldy   #$00
	lda   .adrl
-  	+vnops
	iny
	sta   a_vram
	bne   -
	dex
	bne   -
	rts
	
;	input:
;	adrl/adrh vector set
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of 256byte blocks (page counter)
vdp_memcpy:
	jsr   vdp_sreg
	ldy   #$00
-  	lda   (.adrl),y
	+vnops
	iny
	sta   a_vram
	bne   -
	inc   .adrh
	dex
	bne   -
	rts
	
;	input:
;	adrl/adrh vector set
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of bytes to copy
vdp_memcpys:
	jsr	vdp_sreg
	ldy   #$00
-  	lda   (.adrl),y
	+vnops
	sta   a_vram
	iny
	dex
	bne	-
	rts
	
vdp_print:
	ldy		#$00
	
--	jsr		vdp_set_addr
-	lda		(msgptr),y
	beq		++
	cmp		#$0d
	bne		+
	stz		crs_x
	inc		crs_y
	iny
	jmp		--
+	+vnops
	sta		a_vram
	inc 		crs_x
	iny
	bne		-
++	rts

vdp_chrout:
	tay
	jsr		vdp_set_addr
+	+vnops
	sty		a_vram
	inc	crs_x
	lda	crs_x
	and	#$20
	cmp	#$20
	bne	+
	stz	crs_x
	inc	crs_y
+	rts

vdp_set_addr:
	lda	crs_x
	lda	crs_y	; * 32
	asl	
	asl	
	asl	
	asl
	asl
	ora	crs_x
	sta	a_vreg	
	
	lda	crs_y	; * 32
	lsr			; /8 -> page offset 0-2
	lsr
	lsr
	clc
	adc	#$18+$40
	sta	a_vreg
	rts

vdp_xy:
	stx	crs_x
	sty	crs_y
	rts
	
!macro V_GotoXY .x, .y {
	lda	.x
	sta crs_x
	lda .y
	sta	crs_y
}