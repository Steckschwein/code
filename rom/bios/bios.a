* = $e000
charset
!src "ati_8x8.h.a"

!src <defs.h.a>
!src <uart.h.a>
!src <via.h.a>
!src <sdcard.h.a>
!src <fat32.h.a>
!src <errors.h.a>
!source <t9929.h.a>
!address {
DPL = $00
DPH = $01
.start_check = $0280
.startaddr	= ptr1
.endaddr	= ptr2
.length		= tmp0
}
.ROWS=23
.COLS=32

* = $f000

do_reset:
	; disable interrupt
	sei

	; clear decimal flag
	cld

	; init stack pointer
	ldx #$ff
	txs


	; check zp
	; Start at $ff
	ldy #$ff
	; Start with pattern $03 : $ff
-	ldx #.num_patterns
--	lda .pattern,x
	sta addr($00),y
	cmp addr($00),y
	bne .zp_broken

	dex
	bne --

	dey
	bne -

	; check stack
	ldy #$ff
-	ldx #.num_patterns
--	lda .pattern,x
	sta addr($0100),y
	cmp addr($0100),y
	bne .stack_broken

	dex
	bne --

	dey
	bne --

	jsr .init_vdp


	; Check Memory

	lda #>.start_check
	sta ptr1h
	ldy #<.start_check
	stz ptr1l

-	ldx #.num_patterns  ; 2 cycles

--	lda .pattern,x      ; 4 cycles
	sta (ptr1l),y   ; 6 cycles
	cmp (ptr1l),y   ; 5 cycles
	bne +				  ; 2 cycles, 3 if taken

	dex  				  ; 2 cycles
	bne --			  ; 2 cycles, 3 if taken

	iny  				  ; 2 cycles		
	bne -				  ; 2 cycles, 3 if taken

	; Stop at $e000 to prevent overwriting BIOS Code when ROMOFF
	ldx ptr1h		  ; 3 cycles
	inx				  ; 2 cycles
	stx ptr1h		  ; 3 cycles
	cpx #$e0			  ; 2 cycles

	bne - 			  ; 2 cycles, 3 if taken
+	sty ptr1l		  ; 3 cycles

					  ; 42 cycles

	; save end address
	
	bra .mem_ok

.zp_broken
	lda #$80
	sta memctl
-	jmp -
.stack_broken
	lda #$40
	sta memctl
-	jmp -


.mem_ok

	jsr init_via1

	lda ptr1h
	jsr .hexout
	lda ptr1l
	jsr .hexout	

	jsr .primm
	!text " bytes OK",$0a,$0d
	!text "SteckBIOS 20160516", $0a,$0d,$00

	jsr .init_uart
	jsr .primm
	!text "UART init 115200 baud 8N1",$0a,$0d,$00

	jsr .init_sdcard

	jsr .primm
	!text "SD card init successful",$0a,$0d,$00

	jsr .fat_mount
	lda errno
	beq +

	jsr .primm
	!text "Unable to mount FAT32 file system",$0a,$0d,$00
	jmp .upload
+
	jsr .primm
	!text "FAT32 file system mounted",$0a,$0d,$00

	jsr .fat_find_first
	bcs +
	jsr .primm
	!text "loader not found",$0a,$0d,$00
	jmp .upload
+
	jsr .primm
	!text "loader found",$0a,$0d,$00

	ldy #DIR_FstClusHI + 1
	lda (dirptr),y
	sta root_dir_first_clus + 3
	ldy #DIR_FstClusHI 
	lda (dirptr),y
	sta root_dir_first_clus + 2
	ldy #DIR_FstClusLO + 1
	lda (dirptr),y
	sta root_dir_first_clus + 1
	ldy #DIR_FstClusLO 
	lda (dirptr),y
	sta root_dir_first_clus
	jsr .calc_lba_addr


	!for .i,3,0 {
		ldy #DIR_FileSize + .i
		lda (dirptr),y
		sta tmp0 + .i
	}


	+SetVector steckos_start, sd_blkptr

	jsr .fat_read

	; init stack pointer
	ldx #$ff
	txs
	jmp steckos_start


.upload
	jsr .primm
	!text "Serial upload..",$0a,$0d,$00

	; load start address
	jsr .uart_rx
	sta .startaddr
	
	jsr .uart_rx
	sta .startaddr+1


	lda .startaddr+1
	jsr .hexout
	lda .startaddr
	jsr .hexout

	inc crs_x

	jsr .upload_ok

	; load number of bytes to be uploaded
	jsr .uart_rx
	sta .length
		
	jsr .uart_rx
	sta .length+1

	; calculate end address
	clc
	lda .length
	adc .startaddr
	sta .endaddr

	lda .length+1
	adc .startaddr+1
	sta .endaddr+1

	lda .endaddr+1
	jsr .hexout

	lda .endaddr
	jsr .hexout
	
	inc crs_x

	lda .startaddr
	sta addr
	lda .startaddr+1
	sta addr+1	

	jsr .upload_ok

	ldy #$00
-	jsr .uart_rx
	sta (addr),y

	iny	
	cpy #$00
	bne +
	inc addr+1
+		
	; msb of current address equals msb of end address?
	lda addr+1
	cmp .endaddr+1
	bne - ; no? read next byte

	; yes? compare y to lsb of endaddr
	cpy .endaddr
	bne - ; no? read next byte

	; yes? write OK 

	jsr .upload_ok

	jsr .primm
	!text "OK",$00

	; re-init stack pointer
	ldx #$ff
	txs

	; jump to new code
	jmp (.startaddr)


.upload_ok
	lda #'O'
	jsr .uart_tx
	lda #'K'
	jmp .uart_tx
	;rts




.init_vdp
    ;display off
    lda		#v_reg1_16k	;enable 16K ram, disable screen
    ldy	  	#v_reg1
	+vdp_sreg
    +SyncBlank

	lda	#<ADDRESS_GFX_SPRITE
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX_SPRITE
	+vdp_sreg
	lda	#$d0					;sprites off, at least y=$d0 will disable the sprite subsystem
    +vnops
    +vnops
    sta a_vram
    
	lda	#<ADDRESS_GFX1_SCREEN
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN
	+vdp_sreg
	ldy   #$00      ;2
	ldx	#$03                    ;3 pages - 3x256 byte
	lda	#' '					;fill vram screen with blank
-   +vnops          ;8
    nop             
    nop
	iny             ;2
	sta   a_vram    ;
	bne   -         ;3
	dex
	bne   -
    
    stz crs_x
    stz crs_y
    
    lda #<ADDRESS_GFX1_PATTERN
    ldy #.WRITE_ADDRESS + >ADDRESS_GFX1_PATTERN
	+vdp_sreg
    ldx #$08                    ;load charset
	ldy   #$00     ;2
    +SetVector    charset, addr
-  	lda   (addr),y ;5
	iny            ;2
    +vnops         ;8
	sta   a_vram   ;1 opcode fetch	
	bne   -        ;3
	inc   adrh
	dex
	bne   -
    
	lda	#<ADDRESS_GFX1_COLOR
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX1_COLOR	;color vram
    +vdp_sreg
    lda #Gray<<4|Black          ;enable gfx 1 with cyan on black background
	ldx	#$20
-   +vnops      ;8
    nop
    nop
    dex         ;2
    sta a_vram  ;
    bne -       ;3
    
	ldx	#$00
	ldy	#v_reg0
-  	lda .vdp_init_bytes_gfx1,x
    +vdp_sreg
    iny
	inx
	cpx	#$08
	bne   -
	rts

.inc_cursor_y
	lda crs_y
	cmp	#.ROWS		;last line ?
	bne	+
	bra	.vdp_scroll_up	; scroll up, dont inc y, exit
+	inc crs_y
	rts
	
;
; vdp direct char out, no backbuffer is used. vdp vram is accessed directly
;
.KEY_CR=$0d
.KEY_LF=$0a
.KEY_BACKSPACE=$08
vdp_chrout
	cmp	#.KEY_CR			;cariage return ?
	bne	+
	stz	crs_x
	rts
+	cmp	#.KEY_LF			;line feed
	bne	+
	bra	.inc_cursor_y
+	cmp	#.KEY_BACKSPACE
	bne	+
	lda	crs_x
	beq	++
	dec	crs_x
	bra +++
++	lda	crs_y			; cursor y=0, no dec
	beq	++
	dec	crs_y
	lda	#(.COLS-1)		; set x to end of line above
	sta	crs_x
+++ lda #' '
    bra	vdp_putchar
+	jsr	vdp_putchar
	lda	crs_x
	cmp	#(.COLS-1)
	beq +
	inc	crs_x
++	rts
+	stz	crs_x
	bra	.inc_cursor_y
    
vdp_putchar
	pha
	jsr .vdp_set_addr
	pla
	sta a_vram
    rts

.vdp_scroll_up
	+SetVector	ADDRESS_GFX1_SCREEN+.COLS, ptr1		        ; +.COLS - offset second row
	+SetVector	ADDRESS_GFX1_SCREEN+(.WRITE_ADDRESS<<8), ptr2	; offset first row
	lda	a_vreg  ; clear v-blank bit, we dont know where we are...
--	bit	a_vreg  ; sync with next v-blank, so that we have the full 4,3µs
	bpl	--
-	lda	ptr1l	; 3cl
	sta	a_vreg
	lda	ptr1h	; 3cl
	sta	a_vreg
	nop			; wait 2µs, 4Mhz = 8cl => 4 nop
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	ldx	a_vram	;
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	lda	ptr2l	; 3cl
	sta	a_vreg
	lda	ptr2h	; 3cl
	sta a_vreg
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
    stx	a_vram
	inc	ptr1l	; 5cl
	bne	+		; 3cl
	inc	ptr1h
	lda	ptr1h
	cmp	#>(ADDRESS_GFX1_SCREEN+(.COLS * 24))	;screen ram $1800 - $1b00
	beq	++
+	inc	ptr2l  ; 5cl
	bne	-		; 3cl
	inc	ptr2h
	bra	--
++	ldx	#.COLS	; write address is already setup from loop
	lda	#' '
-	sta	a_vram
    nop
	dex
	bne	-
	rts

.vdp_set_addr			; set the vdp vram adress to write one byte afterwards
	lda	crs_y   		; * 32
	asl
	asl
	asl
	asl
	asl
	ora	crs_x
	sta	a_vreg
    
	lda crs_y   		; * 32
	lsr					; div 8 -> page offset 0-2
	lsr
	lsr
	ora	#.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN
	sta a_vreg
	rts

.vdp_init_bytes_gfx1
	!byte 	0
	!byte	v_reg1_16k|v_reg1_display_on|v_reg1_spr_size
	!byte 	(ADDRESS_GFX1_SCREEN / $400)	; name table - value * $400					--> characters 
	!byte 	(ADDRESS_GFX1_COLOR /  $40)	; color table - value * $40 (gfx1), 7f/ff (gfx2)
	!byte 	(ADDRESS_GFX1_PATTERN / $800) ; pattern table (charset) - value * $800  	--> offset in VRAM 
	!byte	(ADDRESS_GFX1_SPRITE / $80)	; sprite attribute table - value * $80 		--> offset in VRAM
	!byte 	(ADDRESS_GFX1_SPRITE_PATTERN / $800)  ; sprite pattern table - value * $800  		--> offset in VRAM
	!byte	Black


.primm
;Put the string following in-line until a NULL out to the console
PUTSTRI pla			; Get the low part of "return" address
                                ; (data start address)
        sta     DPL
        pla
        sta     DPH             ; Get the high part of "return" address
                                ; (data start address)
        ; Note: actually we're pointing one short
PSINB   ldy     #1
        lda     (DPL),y         ; Get the next string character
        inc     DPL             ; update the pointer
        bne     PSICHO          ; if not, we're pointing to next character
        inc     DPH             ; account for page crossing
PSICHO  ora     #0              ; Set flags according to contents of
                                ;    Accumulator
        beq     PSIX1           ; don't print the final NULL
        jsr     vdp_chrout         ; write it out
        bra     PSINB           ; back around
PSIX1   inc     DPL             ;
        bne     PSIX2           ;
        inc     DPH             ; account for page crossing
PSIX2   jmp     (DPL)           ; return to byte following final NULL


.hexout
	pha
	phx

	tax
	lsr
	lsr
	lsr
	lsr				
	jsr .hex_digit


	txa
	jsr .hex_digit


	plx
	pla
	rts

.hex_digit
	and     #%00001111      ;mask lsd for hex print
	ora     #"0"            ;add "0"
	cmp     #"9"+1          ;is it a decimal digit?
	bcc     +	            ;yes! output it
	adc     #6              ;add offset for letter a-f
+	jmp 	vdp_chrout



;----------------------------------------------------------------------------------------------
; init VIA1 - set all ports to input
;----------------------------------------------------------------------------------------------
init_via1
			pha

			lda #$00
			sta via1ier             ; enable VIA1 T1 interrupts

			; SR shift in, External clock on CB1
			lda #%00001100
			sta via1acr

			; Port b all outputs
			; lda #$ff
			lda #%10011111
			sta via1ddrb

			; SPICLK low, MOSI low, SPI_SS HI
			lda #%01111110
			sta via1portb

		 	pla
		 	rts
;----------------------------------------------------------------------------------------------


;----------------------------------------------------------------------------------------------
; init UART
;----------------------------------------------------------------------------------------------
.init_uart
	lda #%10000000
	sta uart1lcr
	
	; 115200 baud
	lda #$01
	sta uart1dll	
	stz uart1dlh


	lda #%00000011	; 8N1
	sta uart1lcr

	lda #$00
	sta uart1fcr	; FIFO off
	sta uart1ier	; polled mode (so far) 
	sta uart1mcr	; reset DTR, RTS

	and #%00001100			; keep OUT1, OUT2 values
	sta uart1mcr		; reset DTR, RTS

	rts


;----------------------------------------------------------------------------------------------
; send byte in A 
;----------------------------------------------------------------------------------------------
.uart_tx
	pha


-	lda uart1lsr
	and #$20
	beq -

	pla 

	sta uart1rxtx

	rts

;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; receive byte, store in A 
;----------------------------------------------------------------------------------------------
.uart_rx
-	lda uart1lsr 
	and #$1f
	cmp #$01
	bne -
	
	lda uart1rxtx
 
	rts
;----------------------------------------------------------------------------------------------
;----------------------------------------------------------------------------------------------
; Transmit byte VIA SPI
; Byte to transmit in A, received byte in A at exit
; Destructive: A,X,Y
;----------------------------------------------------------------------------------------------
.spi_rw_byte
	sta tmp0	; zu transferierendes byte im akku nach tmp0 retten

	ldx #$08
	
	lda via1portb	; Port laden
	and #$fe        ; SPICLK loeschen

	asl		; Nach links rotieren, damit das bit nachher an der richtigen stelle steht
	tay		 ; bunkern

-	
	rol tmp0
	tya		; portinhalt
	ror		; datenbit reinschieben

	sta via1portb	; ab in den port
	inc via1portb	; takt an
	sta via1portb	; takt aus 

	dex
	bne -		; schon acht mal?
	
	lda via1sr	; Schieberegister auslesen

	rts

;---------------------------------------------------------------------
; Init SD Card 
; Destructive: A, X, Y
;---------------------------------------------------------------------
.init_sdcard
	; 80 Taktzyklen
	ldx #74

	; set ALL CS lines and DO to HIGH 
	lda #%11111110
	sta via1portb

	tay
	iny

-	sty via1portb
	sta via1portb
	dex
	bne -

	jsr .sd_select_card

	jsr .sd_param_init

	; CMD0 needs CRC7 checksum to be correct
	lda #$95
	sta sd_cmd_chksum

	; send CMD0 - init SD card to SPI mode
	lda #cmd0
	jsr .sd_cmd

	; get result
	lda #$ff
	jsr .spi_rw_byte

	; jsr hexout

	cmp #$01
	beq +

	; No Card     
	jsr .primm
	!text "No SD card",$0a,$0d,$00
	jmp .upload

+      
	lda #$01
	sta sd_cmd_param+2
	lda #$aa
	sta sd_cmd_param+3
	lda #$87
	sta sd_cmd_chksum

	jsr .sd_busy_wait

	lda #cmd8
	jsr .sd_cmd

	ldx #$00
-      
	lda #$ff
	phx
	jsr .spi_rw_byte
	plx
	sta sd_cmd_result,x
	inx
	cpx #$05
	bne -

	lda sd_cmd_result
	cmp #$01
	beq +

	; Invalid Card (or card we can't handle yet)
	jsr .sd_deselect_card 
	jsr .primm
	!text "Invalid SD card",$0a,$0d,$00
	jmp .upload
+

-
	jsr .sd_param_init
	jsr .sd_busy_wait
	lda #cmd55
	jsr .sd_cmd

	lda #$ff
	jsr .spi_rw_byte

	cmp #$01
	beq + 

	; Init failed
	jsr .sd_deselect_card 
	jsr .primm
	!text "Invalid SD card",$0a,$0d,$00
	jmp .upload

+      
	jsr .sd_param_init

	lda #$40
	sta sd_cmd_param

	lda #$10
	sta sd_cmd_param+1

	jsr .sd_busy_wait
	lda #acmd41
	jsr .sd_cmd

	lda #$ff
	jsr .spi_rw_byte

	cmp #$00
	beq +

	cmp #$01
	beq -

	lda #$42
	sta errno
	rts
+

	stz sd_cmd_param

	jsr .sd_busy_wait

	lda #cmd58
	jsr .sd_cmd

	ldx #$00
-      
	lda #$ff
	phx
	jsr .spi_rw_byte
	plx
	sta sd_cmd_result,x
	inx
	cpx #$05
	bne -

	bit sd_cmd_result+1
	bvs +

	jsr .sd_param_init

	; Set block size to 512 bytes
	lda #$02
	sta sd_cmd_param+2

	jsr .sd_busy_wait

	lda #cmd16
	jsr .sd_cmd

	lda #$ff
	jsr .spi_rw_byte
+      
	; SD card init successful
	stz errno
	rts

;---------------------------------------------------------------------
; Send SD Card Command
; cmd byte in A
; parameters in sd_cmd_param
;---------------------------------------------------------------------
.sd_cmd

	; transfer command byte
	jsr .spi_rw_byte

	; transfer parameter buffer
	ldx #$00
-	lda sd_cmd_param,x
	phx
	jsr .spi_rw_byte
	plx
	inx
	cpx #$05
	bne -

	; send 8 clocks with DI 1
	lda #$ff
	jsr .spi_rw_byte             

	rts

;---------------------------------------------------------------------
; select sd card, pull CS line to low
;---------------------------------------------------------------------
.sd_select_card
	pha
	lda #%01111100
	sta via1portb
	pla

	rts

;---------------------------------------------------------------------
; deselect sd card, puSH CS line to HI and generate few clock cycles 
; to allow card to deinit
;---------------------------------------------------------------------
.sd_deselect_card
	pha
	; set CS line to HI
	lda #%01111110
	sta via1portb

	lda #$ff
	jsr .spi_rw_byte

	pla
	rts

;---------------------------------------------------------------------
; wait while sd card is busy
;---------------------------------------------------------------------
.sd_busy_wait
-	lda #$ff
	jsr .spi_rw_byte
	cmp #$ff
	bne -
	rts
;---------------------------------------------------------------------
; clear sd card parameter buffer
;---------------------------------------------------------------------
.sd_param_init
	stz sd_cmd_param
	stz sd_cmd_param+1
	stz sd_cmd_param+2
	stz sd_cmd_param+3
	stz sd_cmd_chksum
	inc sd_cmd_chksum
	rts


;---------------------------------------------------------------------
; Read block from SD Card
;---------------------------------------------------------------------
.sd_read_block 
	jsr .sd_select_card
	jsr .sd_busy_wait

	; Send CMD17 command byte
	lda #cmd17
	jsr .spi_rw_byte

	; Send lba_addr in reverse order

	ldx #$03
-	lda lba_addr,x
	phx
	jsr .spi_rw_byte
	plx
	dex
	bpl -
	; !for .i, 3, 0 {
	; 	lda lba_addr + .i
	; 	jsr .spi_rw_byte      
	; }

	; Send stopbit
	lda #$01
	jsr .spi_rw_byte

	; wait for sd card data token
-	
	lda #$ff
	jsr .spi_rw_byte                         
	cmp #sd_data_token
	bne -

	ldy #$00
	lda via1portb   ; Port laden
	AND #$fe        ; Takt ausschalten
	TAX             ; aufheben
	ORA #$01
	sta tmp0

-	lda tmp0
	!for .i,0,7 {
		STA via1portb ; Takt An 
		STX via1portb ; Takt aus
	}
	lda via1sr
	sta (sd_blkptr),y
	iny
	bne -

	inc sd_blkptr+1


-	lda tmp0

	!for .i,0,7 {
		STA via1portb ; Takt An 
		STX via1portb ; Takt aus
	}

	lda via1sr

	sta (sd_blkptr),y
	iny
	bne -

	; dec sd_blkptr+1

	; Read CRC bytes     
	; ldy #$01
-	!for .i,0,15 {
		STA via1portb ; Takt An 
		STX via1portb ; Takt aus
	}
	; dey
	; bpl -

	jmp .sd_deselect_card
	; rts

;---------------------------------------------------------------------
; Read multiple blocks from SD Card
;---------------------------------------------------------------------
.sd_read_multiblock
       +save

       jsr .sd_select_card

       ; Send CMD18 command byte
       jsr .sd_busy_wait  

       lda #cmd18
       jsr .spi_rw_byte

       ; Send lba_addr in reverse order
       !for .i, 3, 0 {
              lda lba_addr + .i
              jsr .spi_rw_byte      
       }

       ; Send stopbit
       lda #$01
       jsr .spi_rw_byte

       ; Wait for data token

-      
	   lda #$ff
	   jsr .spi_rw_byte             
       cmp #$fe
       bne -

       ldy #$00
       lda via1portb   ; Port laden
       AND #$fe        ; Takt ausschalten
       TAX             ; aufheben
       ORA #$01
       sta tmp0
 
       ; read 256 bytes twice, increase blkptr in between
       !for .i,0,1 {            
--            lda tmp0

              !for .j,0,7 {
                    STA via1portb ; Takt An 
                    STX via1portb ; Takt aus
              }
              lda via1sr
              sta (sd_blkptr),y
              iny
              bne --

              inc sd_blkptr+1             
       }
              
       lda tmp0
       ; Read CRC bytes     
       !for .i,0,15 {
              sta via1portb 
              stx via1portb 
       }

   
       dec addr(<.blocks)
       beq +
       jmp -
+
              
       jsr .sd_busy_wait  

       ; all blocks read, send cmd12 to end transmission
       ; jsr sd_param_init
       lda #cmd12
       jsr .sd_cmd

       jsr .sd_busy_wait  
       
       +restore
       jmp .sd_deselect_card
       ; rts


;---------------------------------------------------------------------
; Mount FAT32 on Partition 0
;---------------------------------------------------------------------
.fat_mount
	+save

	; set lba_addr to $00000000 since we want to read the bootsector
	!for .i,0,3 {
		stz lba_addr + .i	
	}
	

	+SetVector sd_blktarget, sd_blkptr

	jsr .sd_read_block
	
	jsr .fat_check_signature

	lda errno
	beq +
	jmp .end_mount
+
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	lda #fat_invalid_partition_type
	sta errno
	jmp .end_mount

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta lba_addr,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	; +SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr	
	; Read FAT Volume ID at LBABegin and Check signature
	jsr .sd_read_block

	jsr .fat_check_signature
	lda errno
	beq +
	jmp .end_mount
+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +
	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	lda #fat_invalid_sector_size
	sta errno
	jmp .end_mount
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	; add number of reserved sectors to fat_begin_lba. store in cluster_begin_lba
	clc

!for .i,0,1 {
	lda lba_addr + .i
	adc sd_blktarget + BPB_RsvdSecCnt + .i
	sta cluster_begin_lba + .i	
	; sta fat_first_block + .i	
}
!for .i,2,3 {
	lda lba_addr + .i
	adc #$00
	sta cluster_begin_lba + .i
	; sta fat_first_block + .i	m
}

	ldy #$02
-	clc
	ldx #$00	
--	ror ; get carry flag back
	lda sd_blktarget + BPB_FATSz32,x ; sectors per fat
	adc cluster_begin_lba,x
	sta cluster_begin_lba,x
	inx
	rol ; save status register before cpx to save carry
	cpx #$04	
	bne --
	dey
	bne -

	; init file descriptor area
	; jsr .fat_init_fdarea

	+Copy sd_blktarget + BPB_RootClus, root_dir_first_clus, 3


	; now we have the lba address of the first sector of the first cluster

.end_mount
	; jsr .sd_deselect_card
	+restore
	; rts

	; fall through to open_rootdir
	
.fat_open_rootdir
	; Open root dir
	; +Copy root_dir_first_clus, current_dir_first_cluster, 3
	jmp .calc_lba_addr


	; rts

.fat_check_signature
	lda #$55
	cmp sd_blktarget + BS_Signature
	bne ++
	asl ; $aa
	cmp sd_blktarget + BS_Signature+1
	beq +
++	lda #fat_bad_block_signature
	sta errno
+	rts

; calculate LBA address of first block from cluster number found in file descriptor entry
; file descriptor index must be in x
.calc_lba_addr
	pha

	
	; lda fd_area + FD_start_cluster +3, x 

	
	; cmp #$ff
	; beq .file_not_open
	
	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
	sec
	lda root_dir_first_clus
	sbc #$02
	sta tmp0 

	!for .i,1,3 {
		lda root_dir_first_clus + .i 
		sbc #$00
		sta tmp0 + .i
	}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster
-	clc
	!for .i,0,3 {
		lda tmp0 + .i
		adc lba_addr + .i
		sta lba_addr + .i	
	}
	dex
	bne -

.calc_end
	pla

	rts

.inc_lba_address
	inc lba_addr + 0
	bne +
	sec
	lda lba_addr + 1
	adc #$00
	sta lba_addr + 1
	lda lba_addr + 2
	adc #$00
	sta lba_addr + 2
	bcc +
	inc lba_addr + 3
+
	rts

.fat_find_first

	+SetVector sd_blktarget, sd_blkptr
	ldx #$00
	jsr .calc_lba_addr
	
-	+SetVector sd_blktarget, dirptr	
	jsr .sd_read_block
	dec sd_blkptr+1

--	
	lda (dirptr)
	bne +
	clc 				; first byte of dir entry is $00?
	rts   				; we are at the end, clear carry and return
+	
	ldy #DIR_Attr		; else check if long filename entry
	lda (dirptr),y 		; we are only going to filter those here (or maybe not?)
	cmp #$0f

	beq .fat_find_next
	
	jsr .match
	bcs +

.fat_find_next
	lda dirptr
	clc
	adc #$20
	sta dirptr
	bcc ++
	inc dirptr+1
++	

	lda dirptr+1 	; end of block?
	cmp #$06
	bcc --			; no, show entr
	; increment lba address to read next block 
	jsr .inc_lba_address	
	bra -

+	
	rts
.match
	phy
	ldy #$00
-	lda (dirptr),y
	cmp .filename,y
	bne +
	iny
	cpy #$0b
	bne -
	sec
	ply
	rts
+	ply
	clc
	rts
.blocks = tmp7
.calc_blocks
	pha
	lda tmp0+3,x
	lsr
	lda tmp0+2,x
	ror
	lda tmp0+1,x
	ror
	sta .blocks
	bcs +
	lda tmp0,x
	beq ++
+	inc .blocks
++  pla
	rts

.fat_read
	jsr .calc_lba_addr
	jsr .calc_blocks

; -	jsr .sd_read_block
; 	inc sd_blkptr+1 ; 3 bytes, 6 cycles

; 	jsr .inc_lba_address
	
; 	dec .blocks
; 	bne -
	jmp .sd_read_multiblock	
	; rts

.filename	!text "LOADER  BIN",$00
;----------------------------------------------------------------------------------------------
; Memcheck patterns
;----------------------------------------------------------------------------------------------
.num_patterns 	= $01
.pattern  		!byte $aa,$55
;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
* = $fffa

!word $ffff
; $FFFC/$FFFD reset vector
;*= $fffc
!word do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!word $ffff
