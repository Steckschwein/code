!initmem $ff
!cpu 65c02
!set bios=1
!src <defs.h.a>
!src <via.h.a>
!src <sdcard.h.a>
!src <uart.h.a>
!src <fat32.h.a>
!src <params.h.a>
!src <ym3812.h.a>
;--------------------------------------------------------------------------------------------------------------
!address	.target = $00
!address	.nvram  = $0800
!address 	.start_check = $0280

*= $e000			; ROM Start
charset_8x8
!src "../charsets/char.ascii.vc20.h.a"
!src "../charsets/char.ascii.6x8.big.h.a"
biosversion	!text "BIOS    : V151013", $00	; Version String
*=$f050
.upload
			+PrintString .crlf
			+PrintString .serial_upload
			ldy #param_baud
			lda (paramvec),y

			jsr .hexout
			+PrintString .crlf

			; load start address
			jsr .uart_rx
			sta .startaddr
			
			jsr .uart_rx
			sta .startaddr+1


			lda .startaddr+1
			jsr .hexout
			lda .startaddr
			jsr .hexout

			lda #' '
			jsr chrout

			lda #'O'
			jsr .uart_tx
			lda #'K'
			jsr .uart_tx

			; load number of bytes to be uploaded
			jsr .uart_rx
			sta .length
				
			jsr .uart_rx
			sta .length+1

			; calculate end address
			clc
			lda .length
			adc .startaddr
			sta .endaddr

			lda .length+1
			adc .startaddr+1
			sta .endaddr+1

			lda .endaddr+1
			jsr .hexout

			lda .endaddr
			jsr .hexout
			
			lda #' '
			jsr chrout

			lda .startaddr
			sta .addr
			lda .startaddr+1
			sta .addr+1	

			lda #'O'
			jsr .uart_tx
			lda #'K'
			jsr .uart_tx

			ldy #$00
-			jsr .uart_rx
			sta (.addr),y

			iny	
			cpy #$00
			bne +
			inc .addr+1
+		

			; msb of current address equals msb of end address?
			lda .addr+1
			cmp .endaddr+1
			bne - ; no? read next byte

			; yes? compare y to lsb of endaddr
			cpy .endaddr
			bne - ; no? read next byte

			; yes? write OK and jump to start addr	

			lda #'O'
			jsr .uart_tx
			lda #'K'
			jsr .uart_tx

			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout

			rts
			
;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------

.do_reset
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs

   			; Check zeropage and Memory
.check_zp
		    ; Start at $ff
			ldy #$ff
			; Start with pattern $03 : $ff
-			ldx #.num_patterns
--			lda .pattern,x
			sta addr($00),y
			cmp addr($00),y
			bne .zp_broken

			dex
			bne --

			dey
			bne -


.check_stack
			ldy #$ff
-			ldx #.num_patterns
--			lda .pattern,x
			sta addr($0100),y
			cmp addr($0100),y
			bne .stack_broken

			dex
			bne --

			dey
			bne --	


			; Check Memory
.check_memory
			lda #>.start_check
			sta .ptr1h
			ldy #<.start_check
			stz .ptr1l

			; ldy #$00

-		    ldx #.num_patterns  ; 2 cycles
--			lda .pattern,x      ; 4 cycles
	  		sta (.ptr1l),y   ; 6 cycles
			cmp (.ptr1l),y   ; 5 cycles
			bne +				  ; 2 cycles, 3 if taken

			dex  				  ; 2 cycles
			bne --			  ; 2 cycles, 3 if taken

			iny  				  ; 2 cycles		
			bne -				  ; 2 cycles, 3 if taken

			; Stop at $e000 to prevent overwriting BIOS Code when ROMOFF
			ldx .ptr1h		  ; 3 cycles
			inx				  ; 2 cycles
			stx .ptr1h		  ; 3 cycles
			cpx #$e0			  ; 2 cycles

			bne - 			  ; 2 cycles, 3 if taken
+	  		sty .ptr1l		  ; 3 cycles
		
	  					  ; 42 cycles
	  		lda .ptr1l
	  		sta ram_end_l
	  		lda .ptr1h
	  		sta ram_end_h
	  		
	  	    bra .mem_ok

.mem_broken
 			lda #$c0
 			sta memctl
-			jmp -

			; Broken ZP 
.zp_broken	lda #$80
			sta memctl
-			jmp -

			; Broken stack
.stack_broken
			lda #$40
			sta memctl
-			jmp -

.mem_ok	
			
			; Set IRQ Vector
			+SetVector default_irqhandler, irqvec

			; Set NMI Vector
			+SetVector default_nmihandler, nmivec

			; Set input vector
			+SetVector .kbd_chrin, invec
			
			; Set output vector
			+SetVector vdp_chrout, outvec
			
			; set parameter vector
			+SetVector .default_params, paramvec
			
			; init IO devices
			jsr init_uart
			jsr	init_vdp

			jsr init_via1
			jsr .init_opl2

			jsr .read_nvram


			+PrintString biosversion
			+PrintString .crlf
			
			+PrintString .ramend ; display ram end
			lda ram_end_h
			jsr .hexout
			lda ram_end_l
			jsr .hexout
			+PrintString .crlf

			jsr .init_sdcard

			lda errno
			beq +

			; SD Card init failed
 			cmp #$ff
 			bne ++

			+PrintString .nocard

++			cmp #$0f
 			bne ++

			+PrintString .invalidcard
++			cmp #$ef 
			bne ++
			+PrintString .unsupportedcard
++			cmp #$1f
			bne ++

			+PrintString .initfail
			bra ++
+
			jsr .boot_from_card

++		
; 			;bra	++	
; seed=$00
; 			lda	#13
; 			sta seed
; -			bit	a_vreg
; 			bpl	-
; 			jsr	rnd
; 			jsr .hexout
; 			bra	-
			
; rnd		   lda seed
; 		   beq doEor
; 		   asl
; 		   beq noEor ;if the input was $80, skip the EOR
; 		   bcc noEor
; 		doEor:    
; 			eor #$1d
; 		noEor:  
; 			sta seed
; 			rts

			
++		
			jsr .upload
			
			; re-init stack pointer
.startup	ldx #$ff
			txs

			; jump to new code
			jmp (.startaddr)

.boot_from_card
			+PrintString .bootup_txt

			lda #%01111110
			sta via1portb

			jsr .fat_mount
			lda errno
			bne .fat_end

			lda paramvec+1
			sta filenameptr+1
			lda paramvec
			clc
			adc #param_filename
			sta filenameptr

			; +SetVector .filename, filenameptr
			+SetVector .steckos_start, .startaddr
			jsr .fat_open
			lda errno 
			bne .fat_end

			ldy #$00
-			lda (filenameptr),y
			beq +
			jsr chrout
			iny
			bne -
+


			
			+SetVector .steckos_start, sd_blkptr
			jsr .fat_read
			lda errno 
			bne .fat_end

			jsr .fat_close
			jsr .sd_deselect_card

			jmp .startup
			
.fat_end	
			jsr .sd_deselect_card
			+PrintString .bootup_failed
			lda errno 
			jsr hexout
			rts


;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
.do_nmi 
			jmp (nmivec)
			

default_nmihandler
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs
		
			jmp .mem_ok
;			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
.do_irq
			jmp (irqvec)
default_irqhandler			
			rti


;----------------------------------------------------------------------------------------------
; Output string on active output device
;----------------------------------------------------------------------------------------------
.strout
			pha                 ;save a, y to stack
			phy

			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr chrout
			iny
			bne -

+			ply                 ;restore a, y
			pla
			rts

;----------------------------------------------------------------------------------------------
; Output byte as hex string on active output device
;----------------------------------------------------------------------------------------------

.hexout
	pha
	phx

	tax
	lsr
	lsr
	lsr
	lsr				
	and     #%00001111      ;mask lsd for hex print
	ora     #"0"            ;add "0"
	cmp     #"9"+1          ;is it a decimal digit?
	bcc     +	            ;yes! output it
	adc     #6              ;add offset for letter a-f
+	jsr		chrout

	txa 
	and     #%00001111      ;mask lsd for hex print
	ora     #"0"            ;add "0"
	cmp     #"9"+1          ;is it a decimal digit?
	bcc     +	            ;yes! output it
	adc     #6              ;add offset for letter a-f
+	jsr		chrout

	plx
	pla
	rts

			


!src "vdp.a"
!src "via.a"
!src "uart.a"
!src <ym3812.a>
!src <spi.a>
!src <sdcard.a>
!src "kbd.a"

;---------------------------------------------------------------------
; FAT32 routines
;---------------------------------------------------------------------
!src <fat.a>

;---------------------------------------------------------------------
; read 96 bytes from RTC as parameter buffer
;---------------------------------------------------------------------
.read_nvram
	+save
	; select RTC
	lda #%01110110
	sta via1portb

	lda #$20
	jsr .spi_rw_byte

	ldx #$00
-		
	phx
	jsr .spi_r_byte
	plx
	sta .nvram,x
	inx
	cpx #96
	bne -

	; deselect all SPI devices
	lda #%01111110
	sta via1portb


	lda #$42 
	cmp .nvram + param_sig
	bne .nvram_invalid_sig					; Wrong signature? stick to the default

; 	stz <CRC
; -	lda .nvram,x
; 	jsr crc8
; 	inx
; 	cpx #param_checksum
; 	bne -
	
	
; 	cmp .nvram + param_checksum - 1
	
; 	bne .nvram_crc_error					; Wrong checksum? defaults

	+SetVector .nvram, paramvec

-	+restore
	rts
.nvram_invalid_sig
	+PrintString .txt_nvram_invalid_sig
	bra -
.nvram_crc_error
	+PrintString .txt_nvram_crc_error
	bra -


; stolen from 
; http://6502.org/source/integers/crc-more.html
; !address CRC  = $f8
; ; CRC     EQU $6          ; current value of CRC
; crc8:
;         EOR addr(<CRC)    ; A contained the data
;         STA addr(<CRC)    ; XOR it with the byte
;         ASL               ; current contents of A will become x^2 term
;         BCC +             ; if b7 = 1
;         EOR #$07          ; then apply polynomial with feedback
; +		EOR addr(<CRC)    ; apply x^1
;         ASL               ; C contains b7 ^ b6
;         BCC +
;         EOR #$07
; +		EOR addr(<CRC)    ; apply unity term
;         STA addr(<CRC)    ; save result
;         RTS


;----------------------------------------------------------------------------------------------
; Tables and lookup data
;----------------------------------------------------------------------------------------------

; SD Card init status messages
; .cardok		!text "SD Card OK", $00
.ramend					!text "RAM end : $", $0
.crlf					!byte $0a, $0d, $00
.txt_nvram_invalid_sig 	!text "NVRAM invalid signature",$0a, $0d, $00
.txt_nvram_crc_error	!text "NVRAM CRC error", $0a, $0d, $00
.serial_upload			!text "Serial upload. baud rate: $", $00
.nocard					!text "NO SD Card ", $00
.invalidcard			!text "Invalid SD Card!", $00
.unsupportedcard		!text "Unsupp. SD Card!", $00
.initfail				!text "SD Init failed!", $00
.fat_err_signature 		!text "bad block signature", $00
.fat_err_partition 		!text "invalid partition type", $00
.fat_err_bad_sect_size 	!text "sector size unsupported", $00
.fat_err_num_fats	  	!text "invalid number of FATs (!= 2)", $00
.bootup_txt 			!text "Boot ", $00
.bootup_failed 			!text "failed: ", $00
.filename				!text "loader.bin",$00


;----------------------------------------------------------------------------------------------
;	divisor values for 1.8432 MHz Crystal
;	value		; baud	; #
.uart_divisor	
	!word -1 	; dunno	; 0
	!word 2304	; 50	; 1
	!word 1536	; 75	; 2	
	!word 1047	; 110	; 3
	!word 857	; 134.5	; 4
	!word 768	; 150	; 5
	!word 384 	; 300	; 6
	!word 192	; 600	; 7
	!word 96	; 1200	; 8
	!word 64	; 1800	; 9
	!word 58	; 2000	; 10
	!word 48	; 2400	; 11
	!word 32	; 3600	; 12
	!word 24	; 4800	; 13
	!word 16	; 7200	; 14
	!word 12	; 9600	; 15
	!word 6		; 19200	; 16
	!word 3		; 38400	; 17
	!word 2		; 56000	; 18
	!word 1 	; 115200; 19
;----------------------------------------------------------------------------------------------
.default_params
	!byte $42
	!byte $00
	!text "loader.bin",$00 
;	!byte $0f
	!byte $13
	!byte %00000011
	!fill .default_params + param_checksum - *, $00
	!byte $00

;----------------------------------------------------------------------------------------------
; Memcheck patterns
;----------------------------------------------------------------------------------------------
.num_patterns = $01
.pattern  !byte $aa,$55

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00
sys_chrout
chrout		jmp (outvec)
sys_chrin
chrin		jmp (invec)

sys_irqhandler
irqhandler  jmp default_irqhandler
;nmihandler  jmp default_nmihandler
sys_spi_rw_byte	
spi_rw_byte	jmp .spi_rw_byte

sys_spi_r_byte	
spi_r_byte	jmp .spi_r_byte

sys_upload	jmp .upload

sys_init_sdcard
init_sdcard jmp .init_sdcard

sys_sd_read_block
sd_read_block 	jmp .sd_read_block

sys_sd_param_init
sd_param_init 	jmp .sd_param_init

sys_sd_deselect_card
sd_deselect_card 	jmp .sd_deselect_card
sys_sd_select_card
sd_select_card 	jmp .sd_select_card

sys_sd_cmd
sd_cmd 		jmp .sd_cmd

sys_strout
strout 		jmp .strout
sys_hexout
hexout 		jmp .hexout
sys_uart_rx
uart_rx     jmp .uart_rx
sys_uart_tx
uart_tx     jmp .uart_tx
sys_fat_mount
fat_mount   jmp .fat_mount
!ifdef experimental {
sys_sd_read_multiblock
sd_read_multiblock 	jmp .sd_read_multiblock	
}


;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!word .do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!word .do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!word .do_irq
