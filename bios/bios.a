!initmem $ff
!cpu 65c02
!src "defs.h.a"
!src "../vdp/t9929.h.a"
*= $e000			; ROM Start
!src "../charsets/char.ascii.vc20.h.a"

biosversion	!text "V2812a", $00	; Version String

start_msg
!text "SteckBIOS 0.1", $0d
!text "BIOS    : V2812a", $0d
;!text "Clock   :", $0d
!text "RAM end : ", $0
ready_msg
!text $0d,$0d,"READY.", $0d
!text $0
crlf	!byte $0d, $00
*=$f000
!src "../vdp/t99xx.lib.a"


.upload
			ldx #$00
			ldy #$01
			jsr i_lcdxy

			lda #$c0
			sta lcdctl
			jsr i_lcdbusy

			; load start address
			jsr i_uart_rx
			sta startaddr
			
			jsr i_uart_rx
			sta startaddr+1


			lda startaddr+1
			jsr i_lcdhex
			lda startaddr
			jsr i_lcdhex

			lda #' '
			jsr lcdprint

			lda #'O'
			jsr i_uart_tx
			lda #'K'
			jsr i_uart_tx

			; +PrintChar 'O'
			; +PrintChar 'K'

			;jsr strout

			; load number of bytes to be uploaded
			jsr i_uart_rx
			sta length
			
			jsr i_uart_rx
			sta length+1

			lda length+1
			jsr i_lcdhex

			lda length
			jsr i_lcdhex
			
			lda #' '
			jsr lcdprint

			; calculate end address
			clc
			lda length
			adc startaddr
			sta endaddr

			lda length+1
			adc startaddr+1
			sta endaddr+1

			lda endaddr+1
			jsr i_lcdhex

			lda endaddr
			jsr i_lcdhex
			
			lda #' '
			jsr lcdprint

			lda startaddr
			sta addr
			lda startaddr+1
			sta addr+1	

			lda #'O'
			jsr i_uart_tx
			lda #'K'
			jsr i_uart_tx

			; +PrintChar 'O'
			; +PrintChar 'K'

			ldy #$00
-			jsr i_uart_rx
			sta (addr),y

			iny	
			cpy #$00
			bne +
			inc addr+1
+		

			; msb of current address equals msb of end address?
			lda addr+1
			cmp endaddr+1
			bne - ; no? read next byte

			; yes? compare y to lsb of endaddr
			cpy endaddr
			bne - ; no? read next byte

			; yes? write OK and jump to start addr	

			lda #'O'
			jsr i_uart_tx
			lda #'K'
			jsr i_uart_tx

			; +PrintChar 'O'
			; +PrintChar 'K'


;			cli
			rts
			
;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------
start_check = $0300
do_reset
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs

   			; Check zeropage and Memory
check_zp
		    ; Start at $ff
			ldy #$ff
			; Start with pattern $03 : $ff
-			ldx #num_patterns
--			lda pattern,x
			sta $00,y

			cmp $00,y
			bne +

			dex
			bne --

			dey
			bne -

check_stack
			ldy #$ff
-			ldx #num_patterns
--			lda pattern,x
			sta $0100,y
			cmp $0100,y
			bne +

			dex
			bne --

			dey
			bne --	

			; Copy self modifying memcheck routine to ZP
			ldx #.selfmod_end - .selfmod_start
-			lda .selfmod_start - 1, x
			sta <.target - 1, x
			dex
			bne -
 			jmp .target ; Execute memcheck routine in ZP

			; Broken ZP or stack

+			txa
			jsr lcdclear
			jsr lcdhex
-			jmp -

.back_from_memcheck

			stz chn_out
			stz chn_in 

			; init VDP
			+SetVector vdp_init_bytes,	adrl
			jsr vdp_init_reg

			jsr	vdp_clear_vram
			jsr vdp_clear_screen
			jsr vdp_load_charset
			jsr vdp_color


			
			; init IO devices
			jsr init_lcd
			jsr init_via1
			jsr init_uart

			; Set IRQ Vector
			+SetVector i_irqhandler, irqvec

			

			lda #dev_lcd
			sta chn_out

			lda #'$'
			jsr chrout

			lda ram_end_l
			jsr hexout
			lda ram_end_h
			jsr hexout

			+PrintStringAt biosversion, $00, $02
			
			+SetVector start_msg, msgptr
			jsr	vdp_print

			stz chn_out
			
			lda #'$'
			jsr chrout

			lda ram_end_l
			jsr hexout
			lda ram_end_h
			jsr hexout

			+SetVector crlf, msgptr
			jsr	vdp_print


			lda	#v_reg1_16k|v_reg1_display_on;v_reg1_int
			ldy	#v_reg1
			jsr	vdp_sreg

			jsr init_sdcard

			lda sd_cmd_errno
			beq +
			ldy #$01
			ldx #$00
			jsr lcdxy
			; SD Card init failed
			cmp #$ff
			bne ++

			lda #dev_lcd
			sta chn_out 
			+PrintString nocard			
			jsr vdp_print
			

++			cmp #$0f
			bne ++
			+PrintString invalidcard
			jsr vdp_print

++			cmp #$1f
			bne ++
			+PrintString initfail
			jsr vdp_print
			bra ++

+			+SetVector cardok, msgptr
			jsr	vdp_print
		
++

			+SetVector ready_msg, msgptr
			jsr	vdp_print
			
			jsr .upload
			
			; re-init stack pointer
			ldx #$ff
			txs

			

			; jump to new code
			jmp (startaddr)
	

;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
do_nmi 
			
			; pha
			; jsr lcdclear

			; jsr lcdhex
			
			; lda #' '
			; jsr lcdprint
			
			; txa
			; jsr lcdhex

			; lda #' '
			; jsr lcdprint


			; tya
			; jsr lcdhex

		
			; pla
			jmp do_reset
			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
do_irq
			jmp (irqvec)
			

i_irqhandler
			pha
			phy
			lda a_vreg

			jsr vdp_cursor
			pla
			ply
			rti

;----------------------------------------------------------------------------------------------
; IO Wrapper
;----------------------------------------------------------------------------------------------
.chrin
		pha
		lda chn_in
		bne +  ; $00 - keyboard
		pla
		jmp .kbd_chrin
+		cmp #$01
		bne +
		pla
		jmp i_uart_rx
+
		pla
		rts
;----------------------------------------------------------------------------------------------
; Output character on active output device
;----------------------------------------------------------------------------------------------
i_chrout
		pha
		lda chn_out
		bne +
		pla
		jmp	vdp_chrout

+		; LCD
		cmp #$01
		bne +
		pla
		jmp i_lcdprint

+		; UART
		cmp #$02
		bne +

		pla
		jmp i_uart_tx

+		
		rts
;----------------------------------------------------------------------------------------------
; Output string on active output device
;----------------------------------------------------------------------------------------------
i_strout 	pha                 ;save a, y to stack
			lda #chn_out
			bne +

			pla
			jmp vdp_print

+			phy

			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr i_chrout
			iny
			bne -

+			ply                 ;restore a, y
			pla
			rts

;----------------------------------------------------------------------------------------------
; Output byte as hex string on active output device
;----------------------------------------------------------------------------------------------
i_hexout    pha
			phy
			phx
			
			tax
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr i_chrout        ;print value 
			
			txa                 ;restore original value
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr i_chrout        ;print value 
			
			plx
			ply
			pla
			rts

			
vdp_clear_vram:
	lda #$00
	ldy	$00+$40
	lda #$00
	sta adrl
	ldx	#$40
	jmp vdp_fill	;clear vram

;----------------------------------------------------------------------------------------------
; clear VDP Screen
;----------------------------------------------------------------------------------------------
vdp_clear_screen:
	lda	#$20
	sta	adrl
   lda   #$00
   ldy   #$18+$40
   ldx	 #$03
	jmp 	vdp_fill

;----------------------------------------------------------------------------------------------
; Load Charset into VDP VRAM
;----------------------------------------------------------------------------------------------
vdp_load_charset:
   +SetVector charset, adrl
   lda   #$00
   ldy   #$00+$40
   ldx	 #$08
   jmp 	 vdp_memcpy

;----------------------------------------------------------------------------------------------
; Set Text Color
;----------------------------------------------------------------------------------------------
vdp_color:
   lda   #$00
   ldy   #$60
   jsr   vdp_sreg
   ldx   #$00
   ldy   #TEXT_COLOR<<4|Transparent
-  +nops VRAM_WAIT
   sty   a_vram
   inx
   cpx   #$20
   bne   -
   rts


;----------------------------------------------------------------------------------------------
; Write to VDP VRAM
;----------------------------------------------------------------------------------------------
vdp_write:
   lda   #$00
   ldy   #$18+$40
   jsr   vdp_sreg
   ldy   #$00
-  lda   (msgptr),y
   beq   +
   +nops VRAM_WAIT
   sta   a_vram
   iny
   bne   -
+  rts

;----------------------------------------------------------------------------------------------
; Display Cursor
;----------------------------------------------------------------------------------------------
vdp_cursor:
   lda   #$20
   ldy   #$54
   jsr   vdp_sreg
   lda   crs_x
   and   #$10
   beq   +
   lda   #231
   jmp   ++
+  lda   #' '
++ sta   a_vram
   inc   crs_x
   rts
;----------------------------------------------------------------------------------------------



;----------------------------------------------------------------------------------------------
; init VIA1 - set all ports to input
;----------------------------------------------------------------------------------------------
init_via1
			pha
			; VIA1
			lda #%00000000
			sta via1ddra
			sta via1ddrb

			lda #$00
			sta via1ier             ; enable VIA1 T1 interrupts

			; SR shift in, External clock on CB1
			lda #%00001100
			sta via1acr

			; Port b all outputs
			lda #$ff
			sta via1ddrb

			; SPICLK low, MOSI low, SPI_SS HI
			lda #%01111110
			sta via1portb


			; lda #<count
			; sta via1t1cl            ; set low byte of count
			; lda #>count
			; sta via1t1ch            ; set high byte of count
			
			; lda #%11000000
			; sta via1ier             ; enable VIA1 T1 interrupts

			; lda #%01000000
		 ; 	sta via1acr             ; T1 continuous, PB7 disabled
		 	
		 	pla
		 	rts

;----------------------------------------------------------------------------------------------
; init UART
;----------------------------------------------------------------------------------------------
init_uart
	; ok, we detected a 16550A, i.e. a chip 
	; with working FIFO
	lda #%10000000
	sta uart1lcr

	ldx #19*2	; 115200 BAUD

;	ldx #17*2	; 38400 BAUD
;	ldx #15*2	; 9600 BAUD
;	ldx #11*2	; 2400 BAUD

	lda uart_divisor,x
	sta uart1dll	

	lda uart_divisor+1,x
	sta uart1dlh

	lda #%00000011	; 8N1

	sta uart1lcr

	lda #$00
	sta uart1fcr	; FIFO off
	sta uart1ier	; polled mode (so far) 
	sta uart1mcr	; reset DTR, RTS

	and #%00001100			; keep OUT1, OUT2 values
	sta uart1mcr		; reset DTR, RTS
	clc

	rts

lcd_line = $10 ; 16 chars per lcd row

;----------------------------------------------------------------------------------------------
; *** LCD initialisation
;----------------------------------------------------------------------------------------------
; init_lcdold  	ldx #$04            ;do function set 4 times
; -		  	lda #$38            ;function set: 8 bit, 2 lines, 5x7
; 			sta lcdctl
; 			jsr i_lcdbusy         ;wait for busy flag to clear
; 			dex
; 			bne -
; 			lda #$06            ;entry mode set: increment, no shift
; 			sta lcdctl
; 			jsr i_lcdbusy
; 			lda #$0e            ;display on, cursor on, blink off
; 			sta lcdctl
; 			jsr i_lcdbusy
; 			lda #$01            ;clear display
; 			sta lcdctl
; 			jsr i_lcdbusy
; 			lda #$80            ;ddram address set: $00
; 			sta lcdctl
; 			jsr i_lcdbusy
; 			rts

init_lcd	ldx #$04            ;do function set 4 times
-		  	lda #$38            ;function set: 8 bit, 2 lines, 5x7
			sta lcdctl
			;jsr i_lcdbusy         ;wait for busy flag to clear
			
			ldy #$00
--			iny
			cpy #$0f
			beq exit 
			lda lcdctl			
			and #$80
			bne --

			dex
			bne -
			lda #$06            ;entry mode set: increment, no shift
			sta lcdctl
			jsr i_lcdbusy
			lda #$0e            ;display on, cursor on, blink off
			sta lcdctl
			jsr i_lcdbusy
			lda #$01            ;clear display
			sta lcdctl
			jsr i_lcdbusy
			lda #$80            ;ddram address set: $00
			sta lcdctl
			jsr i_lcdbusy

			lda #$01
			sta chn_out
exit		rts



; *** Clear LCD display and return cursor to home
; registers preserved
i_lcdclear  pha
			lda #$01
			sta lcdctl
			jsr i_lcdbusy
			lda #$80
			sta lcdctl
			jsr i_lcdbusy
			pla
			rts

; *** Wait for LCD busy bit to clear
; registers preserved
i_lcdbusy   pha
-			lda lcdctl            ;read from lcd register 0
			and #$80            ;check bit 7 (busy)
			bne -
			pla
			rts



; *** Print character on LCD (40 character)
; registers preserved
i_lcdprint  pha
			sta lcddata            ;output the character
			jsr i_lcdbusy
			lda lcdctl            ;get current ddram address
			and #$7f
			cmp #lcd_line         ;wrap from pos $16 (line 1 char 20)...
			bne +
			lda #$c0            	;...to $40 (line 2 char 1)
			sta lcdctl
			jsr i_lcdbusy
+			pla
			rts

; *** print string on lcd
; registers preserved
i_lcdstring pha                 ;save a, y to stack
			tya
			pha
			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr lcdprint
			iny
			bne -
+			pla                 ;restore a, y
			tay
			pla
			rts

; *** Print 2 digit hex number on LCD
; A, X registers preserved
i_lcdhex    pha
			phy
			phx
			
			tax
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			
			txa                 ;restore original value
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			
			plx
			ply
			pla
			rts

;----------------------------------------------------------------------------------------------
; lcdxy 
; Set LCD-Cursor to position
; row in Y, col in X
;----------------------------------------------------------------------------------------------

i_lcdxy
	pha

	lda #$80
	sta tmp0

	cpy #$02
	bne +
	lda #$c0
	sta tmp0
+
	txa
	clc
	adc tmp0

	sta lcdctl
	jsr lcdbusy

	pla
	rts
;----------------------------------------------------------------------------------------------



;----------------------------------------------------------------------------------------------
; send byte in A 
;----------------------------------------------------------------------------------------------
i_uart_tx
	pha


-	lda uart1lsr
	and #$20
	beq -

	pla 

	sta uart1rxtx

	rts

;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; receive byte, store in A 
;----------------------------------------------------------------------------------------------
i_uart_rx
-	lda uart1lsr 
	and #$1f
	cmp #$01
	bne -
	
	lda uart1rxtx
 
	rts

;----------------------------------------------------------------------------------------------
; LCDDECZ - output byte in A as decimal ASCII with leading zeros
;----------------------------------------------------------------------------------------------
i_decoutz
   phx
   phy
   ldx #2
   ldy #$4c
-- sty tmp0
   lsr
-  rol
   bcs +
   cmp dec_tbl,x
   bcc ++
+  sbc dec_tbl,x
   sec
++ rol tmp0
   bcc -
   tay
   lda tmp0
   jsr i_chrout
   tya
   ldy #$13
   dex
   bpl --
   ply
   plx
   rts

;----------------------------------------------------------------------------------------------
; LCDDEC - output byte in A as decimal ASCII without leading zeros
;----------------------------------------------------------------------------------------------
i_decout
   phx
   phy
   ldx #1
   stx tmp1
   inx
   ldy #$40
-- sty tmp0
   lsr
-  rol
   bcs ++
   cmp dec_tbl,x
   bcc +
++ sbc dec_tbl,x
   sec
+  rol tmp0
   bcc -
   tay
   cpx tmp1
   lda tmp0
   bcc +
   beq ++
   stx tmp1
+  eor #$30
   jsr i_chrout
++ tya
   ldy #$10
   dex
   bpl --
   ply
   plx

   rts

;----------------------------------------------------------------------------------------------
; Transmit byte VIA SPI
; Byte to transmit in A, received byte in A at exit
; Destructive: A,X,Y
;----------------------------------------------------------------------------------------------
i_spi_rw_byte
	sta tmp0	; zu transferierendes byte im akku nach tmp0 retten

	ldx #$08
	
	lda via1portb	; Port laden
	and #$fe        ; SPICLK loeschen

	asl		; Nach links rotieren, damit das bit nachher an der richtigen stelle steht
	tay		 ; bunkern

-	
	rol tmp0
	tya		; portinhalt
	ror		; datenbit reinschieben

	sta via1portb	; ab in den port
	inc via1portb	; takt an
	sta via1portb	; takt aus 

	dex
	bne -		; schon acht mal?
	
	lda via1sr	; Schieberegister auslesen

	rts

;----------------------------------------------------------------------------------------------
; Receive byte VIA SPI
; Received byte in A at exit
; Destructive: A,Y
;----------------------------------------------------------------------------------------------
	
i_spi_r_byte
       lda via1portb   ; Port laden
       AND #$7e  ;    * Daten und Takt ausschalten
       TAY             ; aufheben
       ORA #$01

       STA via1portb ; Takt An 1
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 2
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 3
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 4
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 5
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 6
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 7
       STY via1portb ; Takt aus
       STA via1portb ; Takt An 8
       STY via1portb ; Takt aus

       lda via1sr
       rts

;---------------------------------------------------------------------
; Init SD Card 
; Destructive: A, X, Y
;---------------------------------------------------------------------
init_sdcard

	; 80 Taktzyklen
	ldx #74

	; set ALL CS lines and DO to HIGH 
	lda #%11111110
	sta via1portb

	tay
	iny

-	sty via1portb
	sta via1portb
	dex
	bne -

	jsr sd_select_card
	
	jsr sd_param_init

	; CMD0 needs CRC7 checksum to be correct
	lda #$95
	sta sd_cmd_chksum

	; send CMD0 - init SD card to SPI mode
	lda #cmd0
	jsr sd_cmd

	; get result
	lda #$ff
	jsr spi_rw_byte

	cmp #$01
	beq +

	; No Card	
	lda #$ff
	sta sd_cmd_errno
	rts

+	lda #$01
	sta sd_cmd_param+2
	lda #$aa
	sta sd_cmd_param+3
	lda #$87
	sta sd_cmd_chksum

	jsr i_sd_busy_wait

	lda #cmd8
	jsr sd_cmd

	ldx #$00
-	
	lda #$ff
	phx
	jsr spi_rw_byte
	plx
	sta sd_cmd_result,x
	inx
	cpx #$05
	bne -

	lda sd_cmd_result
	cmp #$01
	beq +
	
	; Invalid Card (or card we can't handle yet)
	lda #$0f
	sta sd_cmd_errno
	jsr sd_deselect_card	
	rts
+

-
	
	jsr i_sd_busy_wait

	jsr sd_param_init

	lda #cmd55
	jsr sd_cmd

	lda #$ff
	jsr spi_rw_byte

	cmp #$01
	beq + 

	; Init failed
	lda #$f1	
	sta sd_cmd_errno
	rts 

+	lda #$40
	sta sd_cmd_param

	lda #$10
	sta sd_cmd_param+1

	lda #acmd41
	jsr sd_cmd

	lda #$ff
	jsr spi_r_byte

	cmp #$00
	bne -

	stz sd_cmd_param

	jsr i_sd_busy_wait

	lda #cmd58
	jsr sd_cmd

	ldx #$00
-	
	lda #$ff
	phx
	jsr spi_rw_byte
	plx
	sta sd_cmd_result,x
	inx
	cpx #$05
	bne -

	bit sd_cmd_result+1
	bvs +

	; Set block size to 512 bytes
	lda #$02
	sta sd_cmd_param+2

	jsr i_sd_busy_wait
	
	lda #cmd16
	jsr sd_cmd

	lda #$ff
	jsr spi_rw_byte

+	

	; SD card init successful
	stz sd_cmd_errno
	rts


;---------------------------------------------------------------------
; Send SD Card Command
; cmd byte in A
; parameters in sd_cmd_param
;---------------------------------------------------------------------
i_sd_cmd

	; transfer command byte
	jsr spi_rw_byte
	
	; transfer parameter buffer
	ldx #$00
-	lda sd_cmd_param,x
	phx
	jsr spi_rw_byte
	plx
	inx
	cpx #$05
	bne -

	; send 8 clocks with DI 1
	lda #$ff
	jsr spi_rw_byte		

	rts
	
;---------------------------------------------------------------------
; Read block from SD Card
;---------------------------------------------------------------------
i_sd_read_block
	;jsr sd_select_card

	jsr i_sd_busy_wait

	lda #cmd17
	jsr sd_cmd

	lda #$ff
	jsr spi_rw_byte		


-	lda #$ff
	jsr spi_rw_byte		
	cmp #$fe
	bne -


	ldy #$00
-	
	phy
	jsr spi_r_byte
	ply

	sta (sd_blkptr),y
	iny
	bne -

	inc sd_blkptr+1

	ldy #$00
-	
	phy
	jsr spi_r_byte
	ply

	sta (sd_blkptr),y
	iny
	bne -

	dec sd_blkptr+1

	; Read CRC bytes	
	jsr spi_r_byte
	jmp spi_r_byte
;	rts

;---------------------------------------------------------------------
; Write block to SD Card
;---------------------------------------------------------------------
i_sd_write_block
;	jsr sd_select_card

	jsr i_sd_busy_wait

	lda #cmd24
	jsr sd_cmd
	
-	lda #$ff
	jsr spi_rw_byte		
	bne -

	lda #$fe
	jsr spi_rw_byte

	ldy #$00
-	lda (sd_blkptr),y
	phy
	jsr spi_rw_byte
	ply
	iny
	bne -

	inc sd_blkptr+1

	ldy #$00
-	lda (sd_blkptr),y
	phy
	jsr spi_rw_byte
	ply
	iny
	bne -
	dec sd_blkptr+1

	; Send fake CRC bytes
	lda #$00
	jsr spi_rw_byte
	lda #$00
	jsr spi_rw_byte

	jmp spi_r_byte		
	;rts	

;---------------------------------------------------------------------
; wait while sd card is busy
;---------------------------------------------------------------------
i_sd_busy_wait
-	lda #$ff
	jsr spi_rw_byte
	cmp #$ff
	bne -
	rts

;---------------------------------------------------------------------
; select sd card, pull CS line to low
;---------------------------------------------------------------------
i_sd_select_card
	pha
	; set CS line to LOW
	lda #%11111101
	and via1portb	
	sta via1portb
	pla

	rts

;---------------------------------------------------------------------
; deselect sd card, puSH CS line to HI and generate few clock cycles 
; to allow card to deinit
;---------------------------------------------------------------------
i_sd_deselect_card
	pha
	; set CS line to HI
	lda #%01111110
	ora via1portb	
	sta via1portb

	lda #$ff
	jsr spi_rw_byte
	
	pla

	rts

;---------------------------------------------------------------------
; clear sd card parameter buffer
;---------------------------------------------------------------------
i_sd_param_init
	stz sd_cmd_param
	stz sd_cmd_param+1
	stz sd_cmd_param+2
	stz sd_cmd_param+3
	stz sd_cmd_chksum
	inc sd_cmd_chksum
	rts

;---------------------------------------------------------------------
; enable keyboard controller on SPI bus
;---------------------------------------------------------------------
.kbd_enable
	pha
	; Select SPI SS for keyboard
	lda #%01111010
	; and via1portb
	sta via1portb

	lda #$7f
	and kbd_flg
	sta kbd_flg

	pla
	rts

;---------------------------------------------------------------------
; disable keyboard controller on SPI bus
;---------------------------------------------------------------------
.kbd_disable
	pha

	; Deselect any SPI devices
	lda #%11111110
	sta via1portb
	
	pla
	rts

;---------------------------------------------------------------------
; get key from keyboard, wait if $00
;---------------------------------------------------------------------
.kbd_chrin
-
	jsr .kbd_enable	
	jsr i_spi_r_byte
	jsr .kbd_disable
	beq -
	rts


;----------------------------------------------------------------------------------------------
; Tables and lookup data
;----------------------------------------------------------------------------------------------
; Lookup table for HEX to ASCII
hexascii	!text "0123456789ABCDEF"

; Lookup table for decimal to ASCII
dec_tbl		!byte 128,160,200

; SD Card init status messages
cardok		!text "SD Card OK", $00
nocard		!text "NO SD Card ", $00
invalidcard	!text "Invalid SD Card!", $00
initfail	!text "SD Init failed!", $00

;----------------------------------------------------------------------------------------------
;	divisor values for 1.8432 MHz Crystal
;	value		; baud	; #
uart_divisor	
	!word -1 	; dunno	; 0
	!word 2304	; 50	; 1
	!word 1536	; 75	; 2	
	!word 1047	; 110	; 3
	!word 857	; 134.5	; 4
	!word 768	; 150	; 5
	!word 384 	; 300	; 6
	!word 192	; 600	; 7
	!word 96	; 1200	; 8
	!word 64	; 1800	; 9
	!word 58	; 2000	; 10
	!word 48	; 2400	; 11
	!word 32	; 3600	; 12
	!word 24	; 4800	; 13
	!word 16	; 7200	; 14
	!word 12	; 9600	; 15
	!word 6		; 19200	; 16
	!word 3		; 38400	; 17
	!word 2		; 56000	; 18
	!word 1 	; 115200; 19
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; VDP initialisation data
;----------------------------------------------------------------------------------------------
vdp_init_bytes	
	!byte 0
	!byte v_reg1_16k
	!byte ($1800 / $400)	; name table - value * $400
	!byte ($2000 / $40)	; color table - value * $40 (gfx1), 7f/ff (gfx2)
	!byte ($0000 / $800) ; pattern table (charset) - value * $800  --> offset in VRAM 
	!byte ($2800 / $80)	; sprite attribute table - value * $80 --> offset in VRAM 
	!byte ($0000 / $800)	; sprite pattern table - value * $800  --> offset in VRAM 
	!byte TEXT_BGCOLOR

;----------------------------------------------------------------------------------------------
; Memcheck routine to be copied to ZP
;----------------------------------------------------------------------------------------------
num_patterns = $03
pattern  !byte $aa,$55,$ff,$00

.selfmod_start
!pseudopc $0000 {
.target
      stz ram_end_h
      
-     ldx #num_patterns
--    lda pattern,x
a     sta start_check   ; Start at $0200. skip stack for now      
b     cmp start_check
      bne +
      
      dex 
      bne --

      inc a+1
      inc b+1
      bne -

      ;inc a+2
      ;inc b+2

      ; Stop at $e000 to prevent overwriting BIOS Code when ROMOFF
      ldx a+2
      inx
      stx a+2
      stx b+2
      cpx #$e0
      
      bne -

+	  
	  lda a+2
	  sta ram_end_l
	  lda a+1
	  sta ram_end_h

      jmp .back_from_memcheck
}
.selfmod_end

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00
sys_chrout
chrout		jmp i_chrout
sys_chrin
chrin		jmp .chrin
sys_lcdclear
lcdclear	jmp i_lcdclear
sys_lcdprint
lcdprint 	jmp i_lcdprint
sys_lcdstring
lcdstring 	jmp i_lcdstring
sys_lcdhex
lcdhex 		jmp i_lcdhex 
sys_decout
decout 		jmp i_decout
sys_decoutz
decoutz 	jmp i_decoutz
sys_irqhandler
irqhandler  jmp i_irqhandler
sys_lcdbusy
lcdbusy 	jmp i_lcdbusy
sys_lcdxy
lcdxy 		jmp i_lcdxy

sys_spi_rw_byte	
spi_rw_byte	jmp i_spi_rw_byte

sys_spi_r_byte	
spi_r_byte	jmp i_spi_r_byte

sys_upload	jmp .upload

sys_sd_write_block
sd_write_block 	jmp i_sd_write_block

sys_sd_read_block
sd_read_block 	jmp i_sd_read_block

sys_sd_param_init
sd_param_init 	jmp i_sd_param_init

sys_sd_deselect_card
sd_deselect_card 	jmp i_sd_deselect_card
sys_sd_select_card
sd_select_card 	jmp i_sd_select_card
sys_sd_cmd
sd_cmd 		jmp i_sd_cmd
sys_strout
strout 		jmp i_strout
sys_hexout
hexout 		jmp i_hexout

;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!word do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!word do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!word do_irq
