*= $e000			; ROM Start
count 		= 19998 ; jiffy count 100Hz for 2MHz system
;count		= 29997 ; jiffy count 100Hz for 3MHz system

linebuf		= $0800

;----------------------------------------------------------------------------------------------
; zeropage locations 
;----------------------------------------------------------------------------------------------

; IRQ vector
irqvec		= $e0

; general purpose temp variables
tmp0		= $f0
tmp1		= $f1
tmp2		= $f2
tmp3		= $f3
tmp4		= $f4
tmp5		= $f5
tmp6		= $f6
tmp7		= $f7

; time variables
hours	  	= $f9
minutes   	= $fa
seconds	  	= $fb
jiffies   	= $fc

; pointer for string output functions 
msgptr 		= $fe

; transfer routine addresses
addr 		= $e2
startaddr	= $0700
endaddr     = $0702
length		= $0704


;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; ACIA 
;----------------------------------------------------------------------------------------------
acia 		= $d000
txdata		= acia
rxdata		= acia
aciast		= acia+1 	; ACIA status register
aciacmd		= acia+2 	; ACIA command register
aciactl		= acia+3 	; ACIA control register
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; UART
;----------------------------------------------------------------------------------------------
uart1		= $d300
uart1rxtx	= uart1+0
uart1ier	= uart1+0
uart1dll	= uart1+0
uart1dlh	= uart1+1
uart1iir	= uart1+2
uart1fcr	= uart1+2
uart1lcr	= uart1+3
uart1mcr	= uart1+4
uart1lsr	= uart1+5
uart1msr	= uart1+6
uart1scr	= uart1+7
;----------------------------------------------------------------------------------------------


;	divisor values for 1.8432 MHz Crystal
;	value		; baud	; #
uart_divisor	
	!word -1 	; dunno	; 0
	!word 2304	; 50	; 1
	!word 1536	; 75	; 2	
	!word 1047	; 110	; 3
	!word 857	; 134.5	; 4
	!word 768	; 150	; 5
	!word 384 	; 300	; 6
	!word 192	; 600	; 7
	!word 96	; 1200	; 8
	!word 64	; 1800	; 9
	!word 58	; 2000	; 10
	!word 48	; 2400	; 11
	!word 32	; 3600	; 12
	!word 24	; 4800	; 13
	!word 16	; 7200	; 14
	!word 12	; 9600	; 15
	!word 6		; 19200	; 16
	!word 3		; 38400	; 17
	!word 2		; 56000	; 18
;----------------------------------------------------------------------------------------------


;----------------------------------------------------------------------------------------------
; VIA1 
;----------------------------------------------------------------------------------------------
via1		= $d100
via1porta	= via1+1
via1portb	= via1
via1ddrb 	= via1+2
via1ddra	= via1+3
via1t1cl	= via1+4
via1t1ch	= via1+5
via1acr		= via1 + $0b
via1ifr		= via1 + $0d
via1ier		= via1 + $0e
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; LCD 
;-------------------------------------------------------------------------------------------	---
lcdctl		= $d200
lcddata		= lcdctl+1
;----------------------------------------------------------------------------------------------

read_data
		
			lda #<txt
			sta msgptr

			lda #>txt
			sta msgptr+1

			jsr lcdstring

			; load start address
			jsr chrin
			sta startaddr
			
			jsr chrin
			sta startaddr+1

			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout


			lda startaddr+1
			jsr lcdhex

			lda startaddr
			jsr lcdhex

			
			lda #' '
			jsr lcdprint


			; load number of bytes to be uploaded
			jsr chrin
			sta length
			
			jsr chrin
			sta length+1

			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout

			lda length+1
			jsr lcdhex

			lda length
			jsr lcdhex

			
			lda #' '
			jsr lcdprint

				; calculate end address
			clc
			lda length
			adc startaddr
			sta endaddr

			lda length+1
			adc startaddr+1
			sta endaddr+1

			lda endaddr+1
			jsr lcdhex

			lda endaddr
			jsr lcdhex

			
			lda #' '
			jsr lcdprint

			lda startaddr
			sta addr
			lda startaddr+1
			sta addr+1	


			ldy #$00
-			jsr chrin
			sta (addr),y

			iny	
			cpy #$00
			bne +
			inc addr+1
+		

			; msb of current address equals msb of end address?
			lda addr+1
			cmp endaddr+1
			bne - ; no? read next byte

			; yes? compare y to lsb of endaddr
			cpy endaddr
			bne - ; no? read next byte

			; yes? write OK and jump to start addr	
			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout

			jmp (startaddr)
txt			!text "Send data!", $00

main	
		    lda #<hellomsg
			sta msgptr

			lda #>hellomsg
			sta msgptr+1

			jsr strout


			jsr lcdclear
			
			lda #<readymsg
			sta msgptr

			lda #>readymsg
			sta msgptr+1

			jsr lcdstring


			stz linebuf

--			ldx #$00 
			jsr prompt
-           jsr chrin
            cmp #$0d
            beq +
            jsr chrout
            jsr lcdprint
            sta linebuf,x
            inx
            lda #$00
            sta linebuf,x
            bra -

+			ldx #$00
			jsr handlecommand			

			bra --

hellomsg	!text $0a, $0d
			!text "65c02 CPU @ 2MHz", $0a, $0d
			!text "32k RAM   @ $0000-$7FFF", $0a, $0d
			!text "8k  ROM   @ $E000-$FFFF", $0a, $0d
			!text "IO        @ $D000-$DFFF", $0a, $0d
			!text "   ACIA   @ $D000-$D003", $0a, $0d
			!text "   VIA    @ $D100-$D103", $0a, $0d
			!text "   LCD    @ $D300-$D301", $0a, $0d
readymsg	!text "READY.", 0
crlf		!text $0a, $0d, $00
memfail     !text "MEMORY CHECK FAILED!", $00


handlecommand
			pha

			lda #$0a
			jsr chrout

			lda #$0d
			jsr chrout

			lda linebuf

+			cmp #'c'
			bne +

			jsr clock_out
+			cmp #'z'
			bne +

			jsr dump_zp			

+			cmp #'r'
			bne +

			jsr dump_regs
					
+			cmp #'u'
			bne +

			jmp read_data

+			cmp #'x'
			bne +

			jmp main

+			lda #$0a
		    jsr chrout
		    lda #$0d
		    jsr chrout

			lda #<linebuf
			sta msgptr

			lda #>linebuf
			sta msgptr+1

			jsr strout

			pla
			rts


prompt	    pha
            lda #<+
            sta msgptr
            lda #>+
            sta msgptr+1
               
            jsr strout

            pla
            rts
+	        !text $0a, $0d, "> ", $00

dump_regs
			pha
			lda #'A'
			jsr chrout
			lda #':'
			jsr chrout

			pla
			jsr chrhex
			
			pha
			lda #' '
			jsr chrout
			lda #'X'
			jsr chrout
			lda #':'
			jsr chrout

			txa
			jsr chrhex

			lda #' '
			jsr chrout
			lda #'Y'
			jsr chrout
			lda #':'
			jsr chrout

			tya
			jsr chrhex

			lda #<crlf
			sta msgptr

			lda #>crlf
			sta msgptr+1

			jsr strout
			pla
			rts

dump_zp		pha
			phx
			phy


			ldx #$00
			ldy #$08
			sty tmp0

			; our IO-routines will alter the ZP, so copy the current ZP to somewhere else
-			lda $00,x
			sta $0300,x
			
			cpx #$ff
			inx
			bne -
			
-			txa 		; Output ZP address
			jsr chrhex

			lda #':'
			jsr chrout

			lda $0300,x ; output byte
			jsr chrhex

			lda #' '
			jsr chrout

			dec tmp0 
			bne +

			jsr newline
			ldy #$08
			sty tmp0

+			inx
			bne -

			jsr newline

			ply
			plx
			pla
			rts

newline		pha

			lda #$0a
			jsr chrout

			lda #$0d
			jsr chrout

			pla
			rts
;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------
do_reset
			sei

			; init IO devices
			jsr init_lcd
			jsr init_via1
			jsr init_uart


			; Set IRQ Vector
			lda #<irqhandler
			sta irqvec

			lda #>irqhandler
			sta irqvec+1
			
			stz hours
			stz minutes
			stz seconds
			
			cli 

			jmp read_data
			
;----------------------------------------------------------------------------------------------
; init VIA1
;----------------------------------------------------------------------------------------------
init_via1
			pha
			; VIA1
			lda #%00000000
			sta via1ddra
			sta via1ddrb

			lda #$01
			sta via1portb

			lda #<count
			sta via1t1cl            ; set low byte of count
			lda #>count
			sta via1t1ch            ; set high byte of count
			
			lda #%11000000
			sta via1ier             ; enable VIA1 T1 interrupts

			lda #%01000000
		 	sta via1acr             ; T1 continuous, PB7 disabled
		 	
		 	pla
		 	rts



;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
do_nmi 
			jsr dump_zp
			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
do_irq
			jmp (irqvec)
			

i_irqhandler
			pha

			; VIA1 T1 will overflow 100 times per second.
			lda #%01000000      ; via1 timer1
			and via1ifr
			beq +				; not via1? bye or check for other interrupts

			bit via1t1cl            ; clears interrupt
			
			jsr clock

+			pla
			rti

;----------------------------------------------------------------------------------------------
; CLOCK Routine. Update Clock variables every 100 times.
;----------------------------------------------------------------------------------------------
clock
			pha

			inc jiffies
			lda jiffies
		    cmp #100            ; reached 1 second?
		    bne +            ; if not, done for now

			;lda #$00
			;sta jiffies	
			stz jiffies
			
			inc seconds
			lda seconds
			cmp #60
			bne +

			stz seconds

			inc minutes
			lda minutes
			cmp #60
			bne +

			stz minutes

			inc hours
			lda hours
			cmp #24
			bne +

			stz hours

+			pla
			rts

clock_out	pha
			lda hours
			jsr lcddec

			lda #':'
			jsr lcdprint

			lda minutes
			jsr lcddec

			lda #':'
			jsr lcdprint

			lda seconds
			jsr lcddec

			pla
			rts

;----------------------------------------------------------------------------------------------
; Test memory (zeropage only atm)
;----------------------------------------------------------------------------------------------
memtest
			lda #$ff
			jsr check_zeropage
			rts

;----------------------------------------------------------------------------------------------
; Check zeropage. A contains 0 if ok, != 0 if error
;----------------------------------------------------------------------------------------------

check_zeropage
			phx

			ldx #$00
-			sta $00,x
			cmp $00,x
			bne stop
			inx
			cpx #$ff
			bne -
			
			plx
			rts
stop
			txa
			plx 
			rts

;----------------------------------------------------------------------------------------------
; STROUT - Output string
;----------------------------------------------------------------------------------------------
i_strout	pha                 ;save a, y to stack
			phy
		
			ldy #$00
- 		  	lda (msgptr),y
          	beq +
          	jsr chrout
          	iny
          	bne -
+		   	ply                 ;restore a, y
          	pla
          	rts

;----------------------------------------------------------------------------------------------
; CHRHEX - ouuput binary as hex string 
;----------------------------------------------------------------------------------------------
i_chrhex 	pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr chrout
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr chrout        ;print value on the lcd

			pla
			rts


;----------------------------------------------------------------------------------------------
; *** LCD initialisation
;----------------------------------------------------------------------------------------------
init_lcd  	ldx #$04            ;do function set 4 times
-		  	lda #$38            ;function set: 8 bit, 2 lines, 5x7
			sta lcdctl
			jsr lcdbusy         ;wait for busy flag to clear
			dex
			bne -
			lda #$06            ;entry mode set: increment, no shift
			sta lcdctl
			jsr lcdbusy
			lda #$0e            ;display on, cursor on, blink off
			sta lcdctl
			jsr lcdbusy
			lda #$01            ;clear display
			sta lcdctl
			jsr lcdbusy
			lda #$80            ;ddram address set: $00
			sta lcdctl
			jsr lcdbusy
			rts

; *** Clear LCD display and return cursor to home
; registers preserved
i_lcdclear  pha
			lda #$01
			sta lcdctl
			jsr lcdbusy
			lda #$80
			sta lcdctl
			jsr lcdbusy
			pla
			rts

; *** Wait for LCD busy bit to clear
; registers preserved
i_lcdbusy   pha
-			lda lcdctl            ;read from lcd register 0
			and #$80            ;check bit 7 (busy)
			bne -
			pla
			rts

; *** Print character on LCD (40 character)
; registers preserved
i_lcdprint  pha
			sta lcddata            ;output the character
			jsr lcdbusy
			lda lcdctl            ;get current ddram address
			and #$7f
			cmp #$28          	;wrap from pos $13 (line 1 char 20)...
			bne +
			lda #$c0            	;...to $40 (line 2 char 1)
			sta lcdctl
			jsr lcdbusy
+			pla
			rts

; *** print string on lcd
; registers preserved
i_lcdstring pha                 ;save a, y to stack
			tya
			pha
			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr lcdprint
			iny
			bne -
+			pla                 ;restore a, y
			tay
			pla
			rts

; *** Print 2 digit hex number on LCD
; A, X registers preserved
i_lcdhex    pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla
			rts

; *** Lookup table for HEX to ASCII
hexascii	!text "0123456789ABCDEF"

;----------------------------------------------------------------------------------------------
; init UART
;----------------------------------------------------------------------------------------------
init_uart
	; ok, we detected a 16550A, i.e. a chip 
	; with working FIFO
	lda #%10000000
	sta uart1lcr


	ldx #17*2	; 38400 BAUD
	;ldx #11*2	; 2400 BAUD

	lda uart_divisor,x
	sta uart1dll	

	lda uart_divisor+1,x
	sta uart1dlh

	lda #%00000011	; 8N1

	sta uart1lcr

 	;lda #87		; no FIFO enable and 
 	;lda #7		; no FIFO enable and 
				; clear FIFOs, 
	;sta uart1fcr	; trigger at 1 byte
	; The above will not disable the fifo.
	; This will:
	lda #0
	sta uart1fcr	; FIFO off

	sta uart1ier	; polled mode (so far) 
	sta uart1mcr	; reset DTR, RTS
	and #%00001100			; keep OUT1, OUT2 values
	sta uart1mcr		; reset DTR, RTS
	clc

	rts
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; send byte in A 
;----------------------------------------------------------------------------------------------
uart_tx
	pha

-	lda uart1lsr
	and #$20
	beq -

	pla
	sta uart1rxtx
	
	rts
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; receive byte, store in A 
;----------------------------------------------------------------------------------------------

uart_rx
-	lda uart1lsr 
	and #$1f
	cmp #$01
	bne -
	
	lda uart1rxtx
 
	rts

;----------------------------------------------------------------------------------------------
; init ACIA
;----------------------------------------------------------------------------------------------
init_acia
			pha
		    ; ACIA
		    ; set 1 stop bit, 8 bit data, internal clock, 19200bps
		    lda #%00011111
		    sta aciactl
			
			; set no parity, no echo, no tx interrupts, rts low, no rx interrupts, dtr low  
		    lda #%00001011
		    sta aciacmd

		    pla
			rts
;----------------------------------------------------------------------------------------------
; RXBYTE - receive byte from ACIA and store it in A
;----------------------------------------------------------------------------------------------
rxbyte		lda #$08
rxfull		bit aciast
			beq rxfull
			lda rxdata
			rts

;----------------------------------------------------------------------------------------------
; TXBYTE - send byte in A via ACIA
;----------------------------------------------------------------------------------------------
txbyte		pha
    		lda #$10
txfull	 	bit aciast ; wait for tdre bit = 1
		    beq txfull
		    pla
		    sta txdata
		    rts
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; LCDDECZ - output byte in A as decimal ASCII with leading zeros
;----------------------------------------------------------------------------------------------
i_lcddecz
   phx
   phy
   ldx #2
   ldy #$4c
-- sty tmp0
   lsr
-  rol
   bcs +
   cmp dec_tbl,x
   bcc ++
+  sbc dec_tbl,x
   sec
++ rol tmp0
   bcc -
   tay
   lda tmp0
   jsr lcdprint
   tya
   ldy #$13
   dex
   bpl --
   ply
   plx
   rts

;----------------------------------------------------------------------------------------------
; LCDDEC - output byte in A as decimal ASCII without leading zeros
;----------------------------------------------------------------------------------------------
i_lcddec
   phx
   phy
   ldx #1
   stx tmp1
   inx
   ldy #$40
-- sty tmp0
   lsr
-  rol
   bcs ++
   cmp dec_tbl,x
   bcc +
++ sbc dec_tbl,x
   sec
+  rol tmp0
   bcc -
   tay
   cpx tmp1
   lda tmp0
   bcc +
   beq ++
   stx tmp1
+  eor #$30
   jsr lcdprint
++ tya
   ldy #$10
   dex
   bpl --
   ply
   plx

   rts

dec_tbl		!byte 128,160,200

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00
strout 		jmp i_strout
chrhex 		jmp i_chrhex
chrout		jmp uart_tx
chrin		jmp uart_rx
lcdbusy 	jmp i_lcdbusy
lcdclear	jmp i_lcdclear
lcdprint 	jmp i_lcdprint
lcdstring 	jmp i_lcdstring
lcdhex 		jmp i_lcdhex 
lcddec 		jmp i_lcddec
irqhandler  jmp i_irqhandler
clockout    jmp clock_out
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!byte <do_nmi
!byte >do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!byte <do_reset
!byte >do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!byte <do_irq
!byte >do_irq
