!initmem $ff
!cpu 65c02
!set bios=1
!src <defs.h.a>
!src <via.h.a>
!src <sdcard.h.a>
!src <uart.h.a>
!src <fat32.h.a>
!src <errors.h.a>
!src <params.h.a>
!src <ym3812.h.a>
!src <t9929.h.a>
;--------------------------------------------------------------------------------------------------------------
!address {
	.target = $00
	.nvram  = $0800
	.start_check = $0280
	.blocks = $a0
	.filesize = $a1
}
; Address pointers for serial upload
.startaddr	= ptr1
.endaddr	= ptr2
.length		= tmp0

.ROWS=23
.COLS=32
*= $e000			; ROM Start
charset_8x8
;!src "../charsets/char.ascii.vc20.h.a"
!src "../charsets/ati_8x8.h.a"
*=$f000
.upload
			+PrintString .crlf
			+PrintString .serial_upload
			ldy #param_baud
			lda (paramvec),y

			jsr .hexout
			+PrintString .crlf

			; load start address
			jsr .uart_rx
			sta .startaddr
			
			jsr .uart_rx
			sta .startaddr+1


			lda .startaddr+1
			jsr .hexout
			lda .startaddr
			jsr .hexout

			lda #' '
			jsr chrout

			jsr .upload_ok

			; load number of bytes to be uploaded
			jsr .uart_rx
			sta .length
				
			jsr .uart_rx
			sta .length+1

			; calculate end address
			clc
			lda .length
			adc .startaddr
			sta .endaddr

			lda .length+1
			adc .startaddr+1
			sta .endaddr+1

			lda .endaddr+1
			jsr .hexout

			lda .endaddr
			jsr .hexout
			
			lda #' '
			jsr chrout

			lda .startaddr
			sta addr
			lda .startaddr+1
			sta addr+1	

			jsr .upload_ok

			ldy #$00
-			jsr .uart_rx
			sta (addr),y

			iny	
			cpy #$00
			bne +
			inc addr+1
+		

			; msb of current address equals msb of end address?
			lda addr+1
			cmp .endaddr+1
			bne - ; no? read next byte

			; yes? compare y to lsb of endaddr
			cpy .endaddr
			bne - ; no? read next byte

			; yes? write OK 

			jsr .upload_ok

			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout

			rts
.upload_ok
			lda #'O'
			jsr .uart_tx
			lda #'K'
			jmp .uart_tx
			;rts
			
;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------

.do_reset
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs

   			; Check zeropage and Memory
.check_zp
		    ; Start at $ff
			ldy #$ff
			; Start with pattern $03 : $ff
-			ldx #.num_patterns
--			lda .pattern,x
			sta addr($00),y
			cmp addr($00),y
			bne .zp_broken

			dex
			bne --

			dey
			bne -


.check_stack
			ldy #$ff
-			ldx #.num_patterns
--			lda .pattern,x
			sta addr($0100),y
			cmp addr($0100),y
			bne .stack_broken

			dex
			bne --

			dey
			bne --	


			; Check Memory
.check_memory
			lda #>.start_check
			sta ptr1h
			ldy #<.start_check
			stz ptr1l

-		    ldx #.num_patterns  ; 2 cycles
--			lda .pattern,x      ; 4 cycles
	  		sta (ptr1l),y   ; 6 cycles
			cmp (ptr1l),y   ; 5 cycles
			bne +				  ; 2 cycles, 3 if taken

			dex  				  ; 2 cycles
			bne --			  ; 2 cycles, 3 if taken

			iny  				  ; 2 cycles		
			bne -				  ; 2 cycles, 3 if taken

			; Stop at $e000 to prevent overwriting BIOS Code when ROMOFF
			ldx ptr1h		  ; 3 cycles
			inx				  ; 2 cycles
			stx ptr1h		  ; 3 cycles
			cpx #$e0			  ; 2 cycles

			bne - 			  ; 2 cycles, 3 if taken
+	  		sty ptr1l		  ; 3 cycles
		
	  					  ; 42 cycles

	  		; save end address
	  		lda ptr1l
	  		sta ram_end_l
	  		lda ptr1h
	  		sta ram_end_h
	  		
	  	    bra .mem_ok

.mem_broken
 			lda #$c0
 			sta memctl
-			jmp -

			; Broken ZP 
.zp_broken	lda #$80
			sta memctl
-			jmp -

			; Broken stack
.stack_broken
			lda #$40
			sta memctl
-			jmp -

.mem_ok	
			
			; Set IRQ Vector
			+SetVector default_irqhandler, irqvec

			; Set NMI Vector
			+SetVector default_nmihandler, nmivec

			; Set input vector
			+SetVector .kbd_chrin, invec
			
			; Set output vector
			+SetVector vdp_chrout, outvec
			
			; set parameter vector
			+SetVector .default_params, paramvec
			
			; init IO devices
			jsr init_uart
			jsr	.init_vdp

			jsr init_via1
			; jsr .init_opl2

			jsr .read_nvram

			+PrintString biosversion
			+PrintString .crlf
			
			+PrintString .ramend ; display ram end
			lda ram_end_h
			jsr .hexout
			lda ram_end_l
			jsr .hexout
			+PrintString .crlf

			jsr .init_sdcard

			lda errno
			beq +

			; SD Card init failed
 			cmp #$ff
 			bne ++

			+PrintString .nocard

++			cmp #$0f
 			bne ++

			+PrintString .invalidcard
++			cmp #$ef 
			bne ++
			+PrintString .unsupportedcard
++			cmp #$1f
			bne ++

			+PrintString .initfail
			bra ++
+
			jsr .boot_from_card

++		
; 			;bra	++	
; seed=$00
; 			lda	#13
; 			sta seed
; -			bit	a_vreg
; 			bpl	-
; 			jsr	rnd
; 			jsr .hexout
; 			bra	-
			
; rnd		   lda seed
; 		   beq doEor
; 		   asl
; 		   beq noEor ;if the input was $80, skip the EOR
; 		   bcc noEor
; 		doEor:    
; 			eor #$1d
; 		noEor:  
; 			sta seed
; 			rts

			
++		
			jsr .upload
			
			; re-init stack pointer
.startup	ldx #$ff
			txs

			; jump to new code
			jmp (.startaddr)

.boot_from_card
			+PrintString .bootup_txt

			lda #%01111110
			sta via1portb

			jsr .fat_mount
			lda errno
			bne .fat_end

			lda paramvec+1
			sta filenameptr+1
			lda paramvec
			clc
			adc #param_filename
			sta filenameptr

			+SetVector .filename, filenameptr
			+SetVector steckos_start, .startaddr

			jsr .fat_find_first
			bcs +
			
		
			jmp .upload
+
			; jsr .fat_open
			; lda errno 
			; bne .fat_end

			ldy #$00
-			lda (filenameptr),y
			beq +
			jsr chrout
			iny
			bne -
+

			ldy #DIR_FstClusHI + 1
			lda (dirptr),y
			sta root_dir_first_clus + 3
			ldy #DIR_FstClusHI 
			lda (dirptr),y
			sta root_dir_first_clus + 2
			ldy #DIR_FstClusLO + 1
			lda (dirptr),y
			sta root_dir_first_clus + 1
			ldy #DIR_FstClusLO 
			lda (dirptr),y
			sta root_dir_first_clus
			jsr .calc_lba_addr


			!for .i,3,0 {
				ldy #DIR_FileSize + .i
				lda (dirptr),y
				sta .filesize + .i
			}



			
			+SetVector steckos_start, sd_blkptr
			jsr .fat_read
			lda errno 
			bne .fat_end

			; jsr .fat_close
			; jsr .sd_deselect_card

			jmp .startup
			
.fat_end	
			; jsr .sd_deselect_card
			+PrintString .bootup_failed
			lda errno 
			jsr .hexout
			rts


;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
.do_nmi 
			jmp (nmivec)
			

default_nmihandler
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs
		
			jmp .mem_ok
;			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
.do_irq
			jmp (irqvec)
default_irqhandler			
			rti


;----------------------------------------------------------------------------------------------
; Output string on active output device
;----------------------------------------------------------------------------------------------
.strout
strout
			pha                 ;save a, y to stack
			phy

			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr chrout
			iny
			bne -

+			ply                 ;restore a, y
			pla
			rts

;----------------------------------------------------------------------------------------------
; Output byte as hex string on active output device
;----------------------------------------------------------------------------------------------

.hexout
	pha
	phx

	tax
	lsr
	lsr
	lsr
	lsr				
	jsr .hexdigit
	txa 
	jsr .hexdigit
	plx
	pla
	rts

.hexdigit
	and     #%00001111      ;mask lsd for hex print
	ora     #"0"            ;add "0"
	cmp     #"9"+1          ;is it a decimal digit?
	bcc     +	            ;yes! output it
	adc     #6              ;add offset for letter a-f
+	jmp		chrout

	; rts
			
.init_vdp
    ;display off
    lda		#v_reg1_16k	;enable 16K ram, disable screen
    ldy	  	#v_reg1
	+vdp_sreg
    +SyncBlank

	lda	#<ADDRESS_GFX_SPRITE
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX_SPRITE
	+vdp_sreg
	lda	#$d0					;sprites off, at least y=$d0 will disable the sprite subsystem
    +vnops
    +vnops
    sta a_vram
    
	lda	#<ADDRESS_GFX1_SCREEN
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN
	+vdp_sreg
	ldy   #$00      ;2
	ldx	#$03                    ;3 pages - 3x256 byte
	lda	#' '					;fill vram screen with blank
-   +vnops          ;8
    nop             
    nop
	iny             ;2
	sta   a_vram    ;
	bne   -         ;3
	dex
	bne   -
    
    stz crs_x
    stz crs_y
    
    lda #<ADDRESS_GFX1_PATTERN
    ldy #.WRITE_ADDRESS + >ADDRESS_GFX1_PATTERN
	+vdp_sreg
    ldx #$08                    ;load charset
	ldy   #$00     ;2
    +SetVector    charset, addr
-  	lda   (addr),y ;5
	iny            ;2
    +vnops         ;8
	sta   a_vram   ;1 opcode fetch	
	bne   -        ;3
	inc   adrh
	dex
	bne   -
    
	lda	#<ADDRESS_GFX1_COLOR
	ldy	#.WRITE_ADDRESS + >ADDRESS_GFX1_COLOR	;color vram
    +vdp_sreg
    lda #Gray<<4|Black          ;enable gfx 1 with cyan on black background
	ldx	#$20
-   +vnops      ;8
    nop
    nop
    dex         ;2
    sta a_vram  ;
    bne -       ;3
    
	ldx	#$00
	ldy	#v_reg0
-  	lda .vdp_init_bytes_gfx1,x
    +vdp_sreg
    iny
	inx
	cpx	#$08
	bne   -
	rts

.inc_cursor_y
	lda crs_y
	cmp	#.ROWS		;last line ?
	bne	+
	bra	.vdp_scroll_up	; scroll up, dont inc y, exit
+	inc crs_y
	rts
	
;
; vdp direct char out, no backbuffer is used. vdp vram is accessed directly
;
.KEY_CR=$0d
.KEY_LF=$0a
.KEY_BACKSPACE=$08
vdp_chrout
	cmp	#.KEY_CR			;cariage return ?
	bne	+
	stz	crs_x
	rts
+	cmp	#.KEY_LF			;line feed
	bne	+
	bra	.inc_cursor_y
+	cmp	#.KEY_BACKSPACE
	bne	+
	lda	crs_x
	beq	++
	dec	crs_x
	bra +++
++	lda	crs_y			; cursor y=0, no dec
	beq	++
	dec	crs_y
	lda	#(.COLS-1)		; set x to end of line above
	sta	crs_x
+++ lda #' '
    bra	vdp_putchar
+	jsr	vdp_putchar
	lda	crs_x
	cmp	#(.COLS-1)
	beq +
	inc	crs_x
++	rts
+	stz	crs_x
	bra	.inc_cursor_y
    
vdp_putchar
	pha
	jsr .vdp_set_addr
	pla
	sta a_vram
    rts

.vdp_scroll_up
	+SetVector	ADDRESS_GFX1_SCREEN+.COLS, ptr1		        ; +.COLS - offset second row
	+SetVector	ADDRESS_GFX1_SCREEN+(.WRITE_ADDRESS<<8), ptr2	; offset first row
	lda	a_vreg  ; clear v-blank bit, we dont know where we are...
--	bit	a_vreg  ; sync with next v-blank, so that we have the full 4,3µs
	bpl	--
-	lda	ptr1l	; 3cl
	sta	a_vreg
	lda	ptr1h	; 3cl
	sta	a_vreg
	nop			; wait 2µs, 4Mhz = 8cl => 4 nop
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	ldx	a_vram	;
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	lda	ptr2l	; 3cl
	sta	a_vreg
	lda	ptr2h	; 3cl
	sta a_vreg
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
	nop			; 2cl
    stx	a_vram
	inc	ptr1l	; 5cl
	bne	+		; 3cl
	inc	ptr1h
	lda	ptr1h
	cmp	#>(ADDRESS_GFX1_SCREEN+(.COLS * 24))	;screen ram $1800 - $1b00
	beq	++
+	inc	ptr2l  ; 5cl
	bne	-		; 3cl
	inc	ptr2h
	bra	--
++	ldx	#.COLS	; write address is already setup from loop
	lda	#' '
-	sta	a_vram
    nop
	dex
	bne	-
	rts

.vdp_set_addr			; set the vdp vram adress to write one byte afterwards
	lda	crs_y   		; * 32
	asl
	asl
	asl
	asl
	asl
	ora	crs_x
	sta	a_vreg
    
	lda crs_y   		; * 32
	lsr					; div 8 -> page offset 0-2
	lsr
	lsr
	ora	#.WRITE_ADDRESS + >ADDRESS_GFX1_SCREEN
	sta a_vreg
	rts

.vdp_init_bytes_gfx1
	!byte 	0
	!byte	v_reg1_16k|v_reg1_display_on|v_reg1_spr_size
	!byte 	(ADDRESS_GFX1_SCREEN / $400)	; name table - value * $400					--> characters 
	!byte 	(ADDRESS_GFX1_COLOR /  $40)	; color table - value * $40 (gfx1), 7f/ff (gfx2)
	!byte 	(ADDRESS_GFX1_PATTERN / $800) ; pattern table (charset) - value * $800  	--> offset in VRAM 
	!byte	(ADDRESS_GFX1_SPRITE / $80)	; sprite attribute table - value * $80 		--> offset in VRAM
	!byte 	(ADDRESS_GFX1_SPRITE_PATTERN / $800)  ; sprite pattern table - value * $800  		--> offset in VRAM
	!byte	Black




; !src "vdp.a"
!src "via.a"
!src "uart.a"
; !src <ym3812.a>
; !src <srcpi.a>
; !src <sdcard.a>
!src "kbd.a"

;----------------------------------------------------------------------------------------------
; Transmit byte VIA SPI
; Byte to transmit in A, received byte in A at exit
; Destructive: A,X,Y
;----------------------------------------------------------------------------------------------

.spi_rw_byte
	sta tmp0	; zu transferierendes byte im akku nach tmp0 retten

	ldx #$08
	
	lda via1portb	; Port laden
	and #$fe        ; SPICLK loeschen

	asl		; Nach links rotieren, damit das bit nachher an der richtigen stelle steht
	tay		 ; bunkern

-	
	rol tmp0
	tya		; portinhalt
	ror		; datenbit reinschieben

	sta via1portb	; ab in den port
	inc via1portb	; takt an
	sta via1portb	; takt aus 

	dex
	bne -		; schon acht mal?
	
	lda via1sr	; Schieberegister auslesen

	rts

;---------------------------------------------------------------------
; Init SD Card 
; Destructive: A, X, Y
;---------------------------------------------------------------------
.init_sdcard
       ; 80 Taktzyklen
       ldx #74

       ; set ALL CS lines and DO to HIGH 
       lda #%11111110
       sta via1portb

       tay
       iny

-      sty via1portb
       sta via1portb
       dex
       bne -

       jsr .sd_select_card
       
       jsr .sd_param_init

       ; CMD0 needs CRC7 checksum to be correct
       lda #$95
       sta sd_cmd_chksum

       ; send CMD0 - init SD card to SPI mode
       lda #cmd0
       jsr .sd_cmd

       ; get result
       lda #$ff
       jsr .spi_rw_byte

       ; jsr hexout

       cmp #$01
       beq +

       ; No Card     
       lda #$ff
       sta errno
       rts

+      
       lda #$01
       sta sd_cmd_param+2
       lda #$aa
       sta sd_cmd_param+3
       lda #$87
       sta sd_cmd_chksum

       jsr .sd_busy_wait

       lda #cmd8
       jsr .sd_cmd

       ldx #$00
-      
       lda #$ff
       phx
       jsr .spi_rw_byte
       plx
       sta sd_cmd_result,x
       inx
       cpx #$05
       bne -

       lda sd_cmd_result
       cmp #$01
       beq +
       
       ; Invalid Card (or card we can't handle yet)
       lda #$0f
       sta errno
       jsr .sd_deselect_card 
       rts
+

-
       
       jsr .sd_param_init
       jsr .sd_busy_wait
       lda #cmd55
       jsr .sd_cmd

       lda #$ff
       jsr .spi_rw_byte

       ; jsr hexout

       cmp #$01
       beq + 

       ; Init failed
       lda #$f1      
       sta errno
       rts 

+      
       jsr .sd_param_init

       lda #$40
       sta sd_cmd_param

       lda #$10
       sta sd_cmd_param+1

       jsr .sd_busy_wait
       lda #acmd41
       jsr .sd_cmd

       lda #$ff
       jsr .spi_rw_byte

       cmp #$00
       beq +

       cmp #$01
       beq -

       lda #$42
       sta errno
       rts
+

       stz sd_cmd_param

       jsr .sd_busy_wait

       lda #cmd58
       jsr .sd_cmd

       ldx #$00
-      
       lda #$ff
       phx
       jsr .spi_rw_byte
       plx
       sta sd_cmd_result,x
       inx
       cpx #$05
       bne -

       bit sd_cmd_result+1
       bvs +

       jsr .sd_param_init

       ; Set block size to 512 bytes
       lda #$02
       sta sd_cmd_param+2

       jsr .sd_busy_wait
       
       lda #cmd16
       jsr .sd_cmd

       lda #$ff
       jsr .spi_rw_byte
+      
       ; SD card init successful
       stz errno
       rts


;---------------------------------------------------------------------
; Send SD Card Command
; cmd byte in A
; parameters in sd_cmd_param
;---------------------------------------------------------------------
.sd_cmd

       ; transfer command byte
       jsr .spi_rw_byte
       
       ; transfer parameter buffer
       ldx #$00
-      lda sd_cmd_param,x
       phx
       jsr .spi_rw_byte
       plx
       inx
       cpx #$05
       bne -

       ; send 8 clocks with DI 1
       lda #$ff
       jsr .spi_rw_byte             

       rts
       
;---------------------------------------------------------------------
; Read block from SD Card
;---------------------------------------------------------------------
.sd_read_block 
       jsr .sd_select_card
       jsr .sd_busy_wait
       
       ; Send CMD17 command byte
       lda #cmd17
       jsr .spi_rw_byte

       ; Send lba_addr in reverse order
       ldx #$03
-      lda lba_addr,x
	   phx
       jsr .spi_rw_byte
       plx
       dex
       bpl -
       ; !for .i, 3, 0 {
       ;      lda lba_addr + .i
       ;      jsr spi_rw_byte      
       ; }

       ; Send stopbit
       lda #$01
       jsr .spi_rw_byte

       ; wait for sd card data token
-      lda #$ff
       jsr .spi_rw_byte                         
       cmp #sd_data_token
       bne -

       ldy #$00
       lda via1portb   ; Port laden
       AND #$fe        ; Takt ausschalten
       TAX             ; aufheben
       ORA #$01
       sta tmp0

-      lda tmp0
       !for .i,0,7 {
			STA via1portb ; Takt An 
			STX via1portb ; Takt aus
       }
       lda via1sr
       sta (sd_blkptr),y
       iny
       bne -

       inc sd_blkptr+1

-      lda tmp0

       !for .i,0,7 {
              STA via1portb ; Takt An 
              STX via1portb ; Takt aus
       }

       lda via1sr

       sta (sd_blkptr),y
       iny
       bne -

       ; dec sd_blkptr+1

       ; Read CRC bytes     
       ; !for .i,0,15 {
       ;        STA via1portb ; Takt An 
       ;        STX via1portb ; Takt aus
       ; }
       lda #$ff
       jsr .spi_rw_byte
	   lda #$ff
       jsr .spi_rw_byte

       jmp .sd_deselect_card
       ; rts

;---------------------------------------------------------------------
; wait while sd card is busy
;---------------------------------------------------------------------
.sd_busy_wait
-      lda #$ff
       jsr .spi_rw_byte
       cmp #$ff
       bne -
       rts

;---------------------------------------------------------------------
; select sd card, pull CS line to low
;---------------------------------------------------------------------
.sd_select_card
       pha
; -      lda via1portb ; wait for spi bus to become free
;        and #%01111110
;        cmp #$7e
;        bne -
       ; set CS line to LOW
       lda #%01111100
       sta via1portb
       pla

       rts

;---------------------------------------------------------------------
; deselect sd card, puSH CS line to HI and generate few clock cycles 
; to allow card to deinit
;---------------------------------------------------------------------
.sd_deselect_card
       pha
       phx
       ; set CS line to HI
       lda #%01111110
       sta via1portb

       ldx #$04
-      
       ; lda #$ff
       phx
       jsr .spi_rw_byte
       plx
       dex
       bne -       
       plx
       pla
       rts

;---------------------------------------------------------------------
; clear sd card parameter buffer
;---------------------------------------------------------------------
.sd_param_init
       stz sd_cmd_param
       stz sd_cmd_param+1
       stz sd_cmd_param+2
       stz sd_cmd_param+3
       stz sd_cmd_chksum
       inc sd_cmd_chksum
       rts


;---------------------------------------------------------------------
; FAT32 routines
;---------------------------------------------------------------------

;---------------------------------------------------------------------
; Mount FAT32 on Partition 0
;---------------------------------------------------------------------
.fat_mount
	+save

	; set lba_addr to $00000000 since we want to read the bootsector
	!for .i,0,3 {
		stz lba_addr + .i	
	}
	

	+SetVector sd_blktarget, sd_blkptr

	jsr .sd_read_block
	
	jsr .fat_check_signature

	lda errno
	beq +
	jmp .end_mount
+
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	lda #fat_invalid_partition_type
	sta errno
	jmp .end_mount

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta lba_addr,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	; +SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr	
	; Read FAT Volume ID at LBABegin and Check signature
	jsr .sd_read_block

	jsr .fat_check_signature
	lda errno
	beq +
	jmp .end_mount
+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +
	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	lda #fat_invalid_sector_size
	sta errno
	jmp .end_mount
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	; add number of reserved sectors to fat_begin_lba. store in cluster_begin_lba
	clc

!for .i,0,1 {
	lda lba_addr + .i
	adc sd_blktarget + BPB_RsvdSecCnt + .i
	sta cluster_begin_lba + .i	
	; sta fat_first_block + .i	
}
!for .i,2,3 {
	lda lba_addr + .i
	adc #$00
	sta cluster_begin_lba + .i
	; sta fat_first_block + .i	m
}

	ldy #$02
-	clc
	ldx #$00	
--	ror ; get carry flag back
	lda sd_blktarget + BPB_FATSz32,x ; sectors per fat
	adc cluster_begin_lba,x
	sta cluster_begin_lba,x
	inx
	rol ; save status register before cpx to save carry
	cpx #$04	
	bne --
	dey
	bne -

	; init file descriptor area
	; jsr .fat_init_fdarea

	+Copy sd_blktarget + BPB_RootClus, root_dir_first_clus, 3


	; now we have the lba address of the first sector of the first cluster

.end_mount
	; jsr .sd_deselect_card
	+restore
	; rts

	; fall through to open_rootdir
	
.fat_open_rootdir
	; Open root dir
	; +Copy root_dir_first_clus, current_dir_first_cluster, 3
	jmp .calc_lba_addr


	; rts

.fat_check_signature
	lda #$55
	cmp sd_blktarget + BS_Signature
	bne ++
	asl ; $aa
	cmp sd_blktarget + BS_Signature+1
	beq +
++	lda #fat_bad_block_signature
	sta errno
+	rts

; calculate LBA address of first block from cluster number found in file descriptor entry
; file descriptor index must be in x
.calc_lba_addr
	pha

	
	; lda fd_area + FD_start_cluster +3, x 

	
	; cmp #$ff
	; beq .file_not_open
	
	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
	sec
	lda root_dir_first_clus
	sbc #$02
	sta tmp0 

	!for .i,1,3 {
		lda root_dir_first_clus + .i 
		sbc #$00
		sta tmp0 + .i
	}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster
-	clc
	!for .i,0,3 {
		lda tmp0 + .i
		adc lba_addr + .i
		sta lba_addr + .i	
	}
	dex
	bne -

.calc_end
	pla

	rts

.inc_lba_address:
	inc lba_addr + 0
	bne +
	inc lba_addr + 1
	bne +
	inc lba_addr + 2
	bne +
	inc lba_addr + 3
+
	rts


.fat_find_first

	+SetVector sd_blktarget, sd_blkptr
	ldx #$00
	jsr .calc_lba_addr
	
-	+SetVector sd_blktarget, dirptr	
	jsr .sd_read_block
	dec sd_blkptr+1

--	
	lda (dirptr)
	bne +
	clc 				; first byte of dir entry is $00?
	rts   				; we are at the end, clear carry and return
+	
	ldy #DIR_Attr		; else check if long filename entry
	lda (dirptr),y 		; we are only going to filter those here (or maybe not?)
	cmp #$0f

	beq .fat_find_next
	
	jsr .match
	bcs +

.fat_find_next
	lda dirptr
	clc
	adc #$20
	sta dirptr
	bcc ++
	inc dirptr+1
++	

	lda dirptr+1 	; end of block?
	cmp #$06
	bcc --			; no, show entr
	; increment lba address to read next block 
	jsr .inc_lba_address	
	bra -

+	
	rts
.match
	phy
	ldy #$00
-	lda (dirptr),y
	cmp .filename,y
	bne +
	iny
	cpy #$0b
	bne -
	sec
	ply
	rts
+	ply
	clc
	rts

.calc_blocks
	pha
	lda .filesize+3,x
	lsr
	lda .filesize+2,x
	ror
	lda .filesize+1,x
	ror
	sta .blocks
	bcs +
	lda .filesize,x
	beq ++
+	inc .blocks
++  pla
	rts

.fat_read
	jsr .calc_lba_addr
	jsr .calc_blocks

-	jsr .sd_read_block
	inc sd_blkptr+1 ; 3 bytes, 6 cycles

	jsr .inc_lba_address
	
	dec .blocks
	bne -
	; jmp .sd_read_multiblock	
	rts






;---------------------------------------------------------------------
; read 96 bytes from RTC as parameter buffer
;---------------------------------------------------------------------
.read_nvram
	+save
	; select RTC
	lda #%01110110
	sta via1portb

	lda #$20
	jsr .spi_rw_byte

	ldx #$00
-		
	phx
	lda #$ff
	jsr .spi_rw_byte
	plx
	sta .nvram,x
	inx
	cpx #96
	bne -

	; deselect all SPI devices
	lda #%01111110
	sta via1portb


	lda #$42 
	cmp .nvram + param_sig
	bne .nvram_invalid_sig					; Wrong signature? stick to the default

; 	stz <CRC
; -	lda .nvram,x
; 	jsr crc8
; 	inx
; 	cpx #param_checksum
; 	bne -
	
	
; 	cmp .nvram + param_checksum - 1
	
; 	bne .nvram_crc_error					; Wrong checksum? defaults

	+SetVector .nvram, paramvec

-	+restore
	rts
.nvram_invalid_sig
	+PrintString .txt_nvram_invalid_sig
	bra -
.nvram_crc_error
	+PrintString .txt_nvram_crc_error
	bra -


; stolen from 
; http://6502.org/source/integers/crc-more.html
; !address CRC  = $f8
; ; CRC     EQU $6          ; current value of CRC
; crc8:
;         EOR addr(<CRC)    ; A contained the data
;         STA addr(<CRC)    ; XOR it with the byte
;         ASL               ; current contents of A will become x^2 term
;         BCC +             ; if b7 = 1
;         EOR #$07          ; then apply polynomial with feedback
; +		EOR addr(<CRC)    ; apply x^1
;         ASL               ; C contains b7 ^ b6
;         BCC +
;         EOR #$07
; +		EOR addr(<CRC)    ; apply unity term
;         STA addr(<CRC)    ; save result
;         RTS
chrout		jmp (outvec)
chrin		jmp (invec)


;----------------------------------------------------------------------------------------------
; Tables and lookup data
;----------------------------------------------------------------------------------------------

; SD Card init status messages
; .cardok		!text "SD Card OK", $00
.ramend					!text "RAM end : $", $0
.crlf					!byte $0a, $0d, $00
.txt_nvram_invalid_sig 	!text "NVRAM invalid signature",$0a, $0d, $00
.txt_nvram_crc_error	!text "NVRAM CRC error", $0a, $0d, $00
.serial_upload			!text "Serial upload. baud rate: $", $00
.nocard					!text "NO SD Card ", $00
.invalidcard			!text "Invalid SD Card!", $00
.unsupportedcard		!text "Unsupp. SD Card!", $00
.initfail				!text "SD Init failed!", $00
; .fat_err_signature 		!text "bad block signature", $00
; .fat_err_partition 		!text "invalid partition type", $00
; .fat_err_bad_sect_size 	!text "sector size unsupported", $00
; .fat_err_num_fats	  	!text "invalid number of FATs (!= 2)", $00
.bootup_txt 			!text "Boot ", $00
.bootup_failed 			!text "failed: ", $00
; .filename				!text "loader.bin",$00
.filename				!text "LOADER  BIN",$00
biosversion				!text "BIOS    : V160605s", $00	; Version String
; .ok 					!text "OK",$00

;----------------------------------------------------------------------------------------------
;	divisor values for 1.8432 MHz Crystal
;	value		; baud	; #
; .uart_divisor	
; 	!word -1 	; dunno	; 0
; 	!word 2304	; 50	; 1
; 	!word 1536	; 75	; 2	
; 	!word 1047	; 110	; 3
; 	!word 857	; 134.5	; 4
; 	!word 768	; 150	; 5
; 	!word 384 	; 300	; 6
; 	!word 192	; 600	; 7
; 	!word 96	; 1200	; 8
; 	!word 64	; 1800	; 9
; 	!word 58	; 2000	; 10
; 	!word 48	; 2400	; 11
; 	!word 32	; 3600	; 12
; 	!word 24	; 4800	; 13
; 	!word 16	; 7200	; 14
; 	!word 12	; 9600	; 15
; 	!word 6		; 19200	; 16
; 	!word 3		; 38400	; 17
; 	!word 2		; 56000	; 18
; 	!word 1 	; 115200; 19
;----------------------------------------------------------------------------------------------
.default_params
	!byte $42
	!byte $00
	!text "loader.bin",$00 
;	!byte $0f
	!byte $13
	!byte %00000011
	!fill .default_params + param_checksum - *, $00
	!byte $00

;----------------------------------------------------------------------------------------------
; Memcheck patterns
;----------------------------------------------------------------------------------------------
.num_patterns = $01
.pattern  !byte $aa,$55

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
; *=$ff00
; sys_chrout
; chrout		jmp (outvec)
; sys_chrin
; chrin		jmp (invec)

; sys_irqhandler
; irqhandler  jmp default_irqhandler
; ;nmihandler  jmp default_nmihandler
; sys_spi_rw_byte	
; spi_rw_byte	jmp .spi_rw_byte

; sys_spi_r_byte	
; spi_r_byte	jmp .spi_r_byte

; sys_upload	jmp .upload

; sys_init_sdcard
; init_sdcard jmp .init_sdcard

; sys_sd_read_block
; sd_read_block 	jmp .sd_read_block

; sys_sd_param_init
; sd_param_init 	jmp .sd_param_init

; sys_sd_deselect_card
; sd_deselect_card 	jmp .sd_deselect_card
; sys_sd_select_card
; sd_select_card 	jmp .sd_select_card

; sys_sd_cmd
; sd_cmd 		jmp .sd_cmd

; sys_strout
; strout 		jmp .strout
; sys_hexout
; hexout 		jmp .hexout
; sys_uart_rx
; uart_rx     jmp .uart_rx
; sys_uart_tx
; uart_tx     jmp .uart_tx
; sys_fat_mount
; fat_mount   jmp .fat_mount
; !ifdef experimental {
; sys_sd_read_multiblock
; sd_read_multiblock 	jmp .sd_read_multiblock	
; }


;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!word .do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!word .do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!word .do_irq
