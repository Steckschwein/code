*= $e000			; ROM Start
!src "defs.h.a"

read_data
			lda #<txt
			sta msgptr

			lda #>txt
			sta msgptr+1

			jsr lcdstring

			lda #$c0
			sta lcdctl
			jsr i_lcdbusy

			; load start address
			jsr chrin
			sta startaddr
			
			jsr chrin
			sta startaddr+1


			lda startaddr+1
			jsr i_lcdhex
			lda startaddr
			jsr i_lcdhex

			lda #' '
			jsr lcdprint

			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout

			;jsr strout

			; load number of bytes to be uploaded
			jsr chrin
			sta length
			
			jsr chrin
			sta length+1

			lda length+1
			jsr i_lcdhex

			lda length
			jsr i_lcdhex
			
			lda #' '
			jsr lcdprint

			; calculate end address
			clc
			lda length
			adc startaddr
			sta endaddr

			lda length+1
			adc startaddr+1
			sta endaddr+1

			lda endaddr+1
			jsr i_lcdhex

			lda endaddr
			jsr i_lcdhex
			
			lda #' '
			jsr lcdprint

			lda startaddr
			sta addr
			lda startaddr+1
			sta addr+1	

			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout


			ldy #$00
-			jsr chrin
			sta (addr),y

			iny	
			cpy #$00
			bne +
			inc addr+1
+		

			; msb of current address equals msb of end address?
			lda addr+1
			cmp endaddr+1
			bne - ; no? read next byte

			; yes? compare y to lsb of endaddr
			cpy endaddr
			bne - ; no? read next byte

			; yes? write OK and jump to start addr	
			lda #'O'
			jsr chrout
			lda #'K'
			jsr chrout

			; jsr strout

			jmp (startaddr)
txt			!text "BIOS 1304 "
			!byte $00


;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------
do_reset
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs

			; init IO devices
			jsr init_lcd
			jsr init_via1
			jsr init_uart


			; Set IRQ Vector
			lda #<irqhandler
			sta irqvec

			lda #>irqhandler
			sta irqvec+1


			
;			cli 

			jmp read_data
		


;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
do_nmi 
			;jmp read_data
			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
do_irq
			jmp (irqvec)
			

i_irqhandler
			pha

+			pla
			rti

;----------------------------------------------------------------------------------------------
; init VIA1 - set all ports to input
;----------------------------------------------------------------------------------------------
init_via1
			pha
			; VIA1
			lda #%00000000
			sta via1ddra
			sta via1ddrb

			lda #$00
			sta via1ier             ; enable VIA1 T1 interrupts


			; lda #<count
			; sta via1t1cl            ; set low byte of count
			; lda #>count
			; sta via1t1ch            ; set high byte of count
			
			; lda #%11000000
			; sta via1ier             ; enable VIA1 T1 interrupts

			; lda #%01000000
		 ; 	sta via1acr             ; T1 continuous, PB7 disabled
		 	
		 	pla
		 	rts

;----------------------------------------------------------------------------------------------
; init UART
;----------------------------------------------------------------------------------------------
init_uart
	; ok, we detected a 16550A, i.e. a chip 
	; with working FIFO
	lda #%10000000
	sta uart1lcr

	ldx #19*2	; 115200 BAUD

;	ldx #17*2	; 38400 BAUD
;	ldx #15*2	; 9600 BAUD

	;ldx #11*2	; 2400 BAUD

	lda uart_divisor,x
	sta uart1dll	

	lda uart_divisor+1,x
	sta uart1dlh

	lda #%00000011	; 8N1

	sta uart1lcr

 	;lda #87		; no FIFO enable and 
  	lda #7		; no FIFO enable and 
	; 			; clear FIFOs, 
	sta uart1fcr	; trigger at 1 byte
	; ; The above will not disabl e the fifo.
	; This will:
	lda #0
	sta uart1fcr	; FIFO off

	sta uart1ier	; polled mode (so far) 
	sta uart1mcr	; reset DTR, RTS
	and #%00001100			; keep OUT1, OUT2 values
	sta uart1mcr		; reset DTR, RTS
	clc

	rts

;----------------------------------------------------------------------------------------------
; *** LCD initialisation
;----------------------------------------------------------------------------------------------
init_lcd  	ldx #$04            ;do function set 4 times
-		  	lda #$38            ;function set: 8 bit, 2 lines, 5x7
			sta lcdctl
			jsr i_lcdbusy         ;wait for busy flag to clear
			dex
			bne -
			lda #$06            ;entry mode set: increment, no shift
			sta lcdctl
			jsr i_lcdbusy
			lda #$0e            ;display on, cursor on, blink off
			sta lcdctl
			jsr i_lcdbusy
			lda #$01            ;clear display
			sta lcdctl
			jsr i_lcdbusy
			lda #$80            ;ddram address set: $00
			sta lcdctl
			jsr i_lcdbusy
			rts

; *** Clear LCD display and return cursor to home
; registers preserved
i_lcdclear  pha
			lda #$01
			sta lcdctl
			jsr i_lcdbusy
			lda #$80
			sta lcdctl
			jsr i_lcdbusy
			pla
			rts

; *** Wait for LCD busy bit to clear
; registers preserved
i_lcdbusy   pha
-			lda lcdctl            ;read from lcd register 0
			and #$80            ;check bit 7 (busy)
			bne -
			pla
			rts

; *** Print character on LCD (40 character)
; registers preserved
i_lcdprint  pha
			sta lcddata            ;output the character
			jsr i_lcdbusy
			lda lcdctl            ;get current ddram address
			and #$7f
			cmp #$28          	;wrap from pos $13 (line 1 char 20)...
			bne +
			lda #$c0            	;...to $40 (line 2 char 1)
			sta lcdctl
			jsr i_lcdbusy
+			pla
			rts

; *** print string on lcd
; registers preserved
i_lcdstring pha                 ;save a, y to stack
			tya
			pha
			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr lcdprint
			iny
			bne -
+			pla                 ;restore a, y
			tay
			pla
			rts

; *** Print 2 digit hex number on LCD
; A, X registers preserved
i_lcdhex    pha
			phy
			phx
			
			tax
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			
			txa                 ;restore original value
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			
			plx
			ply
			pla
			rts



;----------------------------------------------------------------------------------------------
; send byte in A 
;----------------------------------------------------------------------------------------------
i_uart_tx
	pha
	phx

	tax

-	lda uart1lsr
	and #$20
	beq -

	stx uart1rxtx
	
	plx
	pla
	rts

;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; receive byte, store in A 
;----------------------------------------------------------------------------------------------

i_uart_rx
-	lda uart1lsr 
	and #$1f
	cmp #$01
	bne -
	
	lda uart1rxtx
 
	rts

;----------------------------------------------------------------------------------------------
; LCDDECZ - output byte in A as decimal ASCII with leading zeros
;----------------------------------------------------------------------------------------------
i_lcddecz
   phx
   phy
   ldx #2
   ldy #$4c
-- sty tmp0
   lsr
-  rol
   bcs +
   cmp dec_tbl,x
   bcc ++
+  sbc dec_tbl,x
   sec
++ rol tmp0
   bcc -
   tay
   lda tmp0
   jsr lcdprint
   tya
   ldy #$13
   dex
   bpl --
   ply
   plx
   rts

;----------------------------------------------------------------------------------------------
; LCDDEC - output byte in A as decimal ASCII without leading zeros
;----------------------------------------------------------------------------------------------
i_lcddec
   phx
   phy
   ldx #1
   stx tmp1
   inx
   ldy #$40
-- sty tmp0
   lsr
-  rol
   bcs ++
   cmp dec_tbl,x
   bcc +
++ sbc dec_tbl,x
   sec
+  rol tmp0
   bcc -
   tay
   cpx tmp1
   lda tmp0
   bcc +
   beq ++
   stx tmp1
+  eor #$30
   jsr lcdprint
++ tya
   ldy #$10
   dex
   bpl --
   ply
   plx

   rts

;----------------------------------------------------------------------------------------------
; Tables and lookup data
;----------------------------------------------------------------------------------------------
; Lookup table for HEX to ASCII
hexascii	!text "0123456789ABCDEF"

; Lookup table for decimal to ASCII
dec_tbl		!byte 128,160,200

;----------------------------------------------------------------------------------------------
;	divisor values for 1.8432 MHz Crystal
;	value		; baud	; #
uart_divisor	
	!word -1 	; dunno	; 0
	!word 2304	; 50	; 1
	!word 1536	; 75	; 2	
	!word 1047	; 110	; 3
	!word 857	; 134.5	; 4
	!word 768	; 150	; 5
	!word 384 	; 300	; 6
	!word 192	; 600	; 7
	!word 96	; 1200	; 8
	!word 64	; 1800	; 9
	!word 58	; 2000	; 10
	!word 48	; 2400	; 11
	!word 32	; 3600	; 12
	!word 24	; 4800	; 13
	!word 16	; 7200	; 14
	!word 12	; 9600	; 15
	!word 6		; 19200	; 16
	!word 3		; 38400	; 17
	!word 2		; 56000	; 18
	!word 1 	; 115200; 19
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00
chrout		jmp i_uart_tx
chrin		jmp i_uart_rx
lcdclear	jmp i_lcdclear
lcdprint 	jmp i_lcdprint
lcdstring 	jmp i_lcdstring
lcdhex 		jmp i_lcdhex 
lcddec 		jmp i_lcddec
lcddecz 	jmp i_lcddecz
irqhandler  jmp i_irqhandler
lcdbusy 	jmp i_lcdbusy

;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!byte <do_nmi
!byte >do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!byte <do_reset
!byte >do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!byte <do_irq
!byte >do_irq
