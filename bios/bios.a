!initmem $ff
!cpu 65c02

!src <defs.h.a>
!src <via.h.a>
!src <sdcard.h.a>
!src <uart.h.a>
!src <lcd.h.a>
!src <fat32.h.a>
!address	.target = $00
*= $e000			; ROM Start
charset_8x8
!src "../charsets/char.ascii.vc20.h.a"
!align 255,0
charset_5x8
!src "../charsets/char.ascii.5x8.h.a"		; mirrored
biosversion	!text "V0905", $00	; Version String

.start_msg
!text "SteckBIOS 0.1", $0d
!text "BIOS    : V1804", $0d
;!text "Clock   :", $0d
!text "RAM end : ", $0
.ready_msg
!text $0d,$0d,"READY.", $0d
!text $0
.crlf	!byte $0d, $00
*=$f000




.upload
			ldx #$00
			ldy #$01
			jsr .lcdxy

			lda #$c0
			sta lcdctl
			jsr .lcdbusy

			; load start address
			jsr .uart_rx
			sta .startaddr
			
			jsr .uart_rx
			sta .startaddr+1


			lda .startaddr+1
			jsr .lcdhex
			lda .startaddr
			jsr .lcdhex

			lda #' '
			jsr .lcdprint

			lda #'O'
			jsr .uart_tx
			lda #'K'
			jsr .uart_tx

			; load number of bytes to be uploaded
			jsr .uart_rx
			sta .length
				
			jsr .uart_rx
			sta .length+1

			; calculate end address
			clc
			lda .length
			adc .startaddr
			sta .endaddr

			lda .length+1
			adc .startaddr+1
			sta .endaddr+1

			lda .endaddr+1
			jsr .lcdhex

			lda .endaddr
			jsr .lcdhex
			
			lda #' '
			jsr .lcdprint

			lda .startaddr
			sta .addr
			lda .startaddr+1
			sta .addr+1	

			lda #'O'
			jsr .uart_tx
			lda #'K'
			jsr .uart_tx

			ldy #$00
-			jsr .uart_rx
			sta (.addr),y

			iny	
			cpy #$00
			bne +
			inc .addr+1
+		

			; msb of current address equals msb of end address?
			lda .addr+1
			cmp .endaddr+1
			bne - ; no? read next byte

			; yes? compare y to lsb of endaddr
			cpy .endaddr
			bne - ; no? read next byte

			; yes? write OK and jump to start addr	

			lda #'O'
			jsr .uart_tx
			lda #'K'
			jsr .uart_tx

			lda #'O'
			jsr .lcdprint
			lda #'K'
			jsr .lcdprint

			rts
			
;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------
!address 	.start_check = $0300
.do_reset
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs

   			; Check zeropage and Memory
.check_zp
		    ; Start at $ff
			ldy #$ff
			; Start with pattern $03 : $ff
-			ldx #.num_patterns
--			lda .pattern,x
			sta addr($00),y

			cmp addr($00),y
			bne .zp_broken

			dex
			bne --

			dey
			bne -


.check_stack
			ldy #$ff
-			ldx #.num_patterns
--			lda .pattern,x
			sta addr($0100),y
			cmp addr($0100),y
			bne .stack_broken

			dex
			bne --

			dey
			bne --	


			; Copy self modifying memcheck routine to ZP
			ldx #.selfmod_end - .selfmod_start
-			lda .selfmod_start - 1, x
			sta addr(<(.target - 1)) , x
			dex
			bne -
 			jmp .target ; Execute memcheck routine in ZP

.mem_broken
 			lda #$c0
 			sta memctl
-			jmp -

			; Broken ZP 
.zp_broken	lda #$80
			sta memctl
-			jmp -

			; Broken stack
.stack_broken
			lda #$40
			sta memctl
-			jmp -




.back_from_memcheck

			stz chn_out
			stz chn_in 

			; init IO devices
			jsr init_lcd
			jsr init_via1
			jsr init_uart

			; Set IRQ Vector
			+SetVector .irqhandler, irqvec

			lda #dev_lcd
			sta chn_out

			+PrintStringAt biosversion, $00, $01

			ldx #$06
			jsr .lcdxy

			lda #'$'
			jsr .chrout

			lda ram_end_l
			jsr .hexout
			lda ram_end_h
			jsr .hexout

		
			ldy #$02
			ldx #$00
			jsr .lcdxy

			jsr .init_sdcard

			lda sd_cmd_errno
			beq +

			; SD Card init failed
			cmp #$ff
			bne ++

			+PrintString .nocard               

++			cmp #$0f
			bne ++




			+PrintString .invalidcard
++			cmp #$ef 
			bne ++
			+PrintString .unsupportedcard
++			cmp #$1f
			bne ++

			+PrintString .initfail

			bra ++


+
			jsr .boot_from_card

++			
			jsr .upload
			
			; re-init stack pointer
.startup	ldx #$ff
			txs

			

			; jump to new code
			jmp (.startaddr)

.boot_from_card
			+PrintString .bootup_txt

			lda #%01111110
			sta via1portb

			jsr .fat_mount
			lda fat_errno
			bne .fat_end


			; just use cluster_begin_lba if reading root dir cluster
			+Copy cluster_begin_lba, lba_addr, 4
			; +Copy root_dir_first_clus, cluster_number,4
			; Calculate cluster LBA address for anything else
			; jsr .calc_lba_addr

			jsr .fat_bootfile
	
.fat_end
			jsr .sd_deselect_card

			+PrintString .bootup_failed

++			rts
	

.bootup_txt 	!text "Boot ", $00
.bootup_failed 	!text "failed ", $00
;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
.do_nmi 
			; disable interrupt
			sei

			; clear decimal flag
			cld

			; init stack pointer
			ldx #$ff
			txs
		
			jmp .back_from_memcheck
;			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
.do_irq
			jmp (irqvec)
			

.irqhandler
			pha
			phy
			; lda a_vreg

			; jsr vdp_cursor
			pla
			ply
			rti

;----------------------------------------------------------------------------------------------
; IO Wrapper
;----------------------------------------------------------------------------------------------
.chrin
		pha
		lda chn_in
		bne +  ; $00 - keyboard
		pla
		jmp .kbd_chrin
+		cmp #dev_uart
		bne +
		pla
		jmp .uart_rx
+
		pla
		rts
;----------------------------------------------------------------------------------------------
; Output character on active output device
;----------------------------------------------------------------------------------------------
.chrout
		pha
		lda chn_out
		bne +
		pla
		; jmp	vdp_chrout

+		; LCD
		cmp #dev_lcd
		bne +
		pla
		jmp .lcdprint

+		; UART
		cmp #dev_uart
		bne +

		pla
		jmp .uart_tx

+		
		rts
;----------------------------------------------------------------------------------------------
; Output string on active output device
;----------------------------------------------------------------------------------------------
.strout 	pha                 ;save a, y to stack
			lda chn_out
			bne +

			pla
			; jmp vdp_print

+			phy

			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr .chrout
			iny
			bne -

+			ply                 ;restore a, y
			pla
			rts

;----------------------------------------------------------------------------------------------
; Output byte as hex string on active output device
;----------------------------------------------------------------------------------------------
; .hexout    pha
; 			phy
; 			phx
			
; 			tax
; 			lsr                ;shift high nybble into low nybble
; 			lsr 
; 			lsr 
; 			lsr 
; 			tay
; 			lda hexascii,y      ;convert to ascii
; 			jsr .chrout        ;print value 
			
; 			txa                 ;restore original value
; 			and #$0f            ;select low nybble
; 			tay
; 			lda hexascii,y      ;convert to ascii
; 			jsr .chrout        ;print value 
			
; 			plx
; 			ply
; 			pla
; 			rts

.hexout
	pha
	phx

	tax
	lsr
	lsr
	lsr
	lsr				
	and     #%00001111      ;mask lsd for hex print
	ora     #"0"            ;add "0"
	cmp     #"9"+1          ;is it a decimal digit?
	bcc     +	            ;yes! output it
	adc     #6              ;add offset for letter a-f
+	jsr		.chrout

	txa 
	and     #%00001111      ;mask lsd for hex print
	ora     #"0"            ;add "0"
	cmp     #"9"+1          ;is it a decimal digit?
	bcc     +	            ;yes! output it
	adc     #6              ;add offset for letter a-f
+	jsr		.chrout

	plx
	pla
	rts

			



!src "via.a"



!src "lcd.a"


;----------------------------------------------------------------------------------------------
; LCDDECZ - output byte in A as decimal ASCII with leading zeros
;----------------------------------------------------------------------------------------------
.decoutz
   phx
   phy
   ldx #2
   ldy #$4c
-- sty tmp0
   lsr
-  rol
   bcs +
   cmp .dec_tbl,x
   bcc ++
+  sbc .dec_tbl,x
   sec
++ rol tmp0
   bcc -
   tay
   lda tmp0
   jsr .chrout
   tya
   ldy #$13
   dex
   bpl --
   ply
   plx
   rts

;----------------------------------------------------------------------------------------------
; LCDDEC - output byte in A as decimal ASCII without leading zeros
;----------------------------------------------------------------------------------------------
.decout
   phx
   phy
   ldx #1
   stx tmp1
   inx
   ldy #$40
-- sty tmp0
   lsr
-  rol
   bcs ++
   cmp .dec_tbl,x
   bcc +
++ sbc .dec_tbl,x
   sec
+  rol tmp0
   bcc -
   tay
   cpx tmp1
   lda tmp0
   bcc +
   beq ++
   stx tmp1
+  eor #$30
   jsr .chrout
++ tya
   ldy #$10
   dex
   bpl --
   ply
   plx

   rts

!src "uart.a"
!src "spi.a"
!src "sdcard.a"
!src "kbd.a"




;---------------------------------------------------------------------
; FAT32 routines
;---------------------------------------------------------------------
!src "fat32.a"




;----------------------------------------------------------------------------------------------
; Tables and lookup data
;----------------------------------------------------------------------------------------------
; Lookup table for HEX to ASCII
;hexascii	!text "0123456789ABCDEF"

; Lookup table for decimal to ASCII
.dec_tbl		!byte 128,160,200

; SD Card init status messages
; .cardok		!text "SD Card OK", $00
.nocard					!text "NO SD Card ", $00
.invalidcard			!text "Invalid SD Card!", $00
.unsupportedcard		!text "Unsupp. SD Card!", $00
.initfail				!text "SD Init failed!", $00
.fat_err_signature 		!text "bad block signature", $00
.fat_err_partition 		!text "invalid partition type", $00
.fat_err_bad_sect_size 	!text "sector size unsupported", $00
.fat_err_num_fats	  	!text "invalid number of FATs (!= 2)", $00

;----------------------------------------------------------------------------------------------
;	divisor values for 1.8432 MHz Crystal
;	value		; baud	; #
.uart_divisor	
	!word -1 	; dunno	; 0
	!word 2304	; 50	; 1
	!word 1536	; 75	; 2	
	!word 1047	; 110	; 3
	!word 857	; 134.5	; 4
	!word 768	; 150	; 5
	!word 384 	; 300	; 6
	!word 192	; 600	; 7
	!word 96	; 1200	; 8
	!word 64	; 1800	; 9
	!word 58	; 2000	; 10
	!word 48	; 2400	; 11
	!word 32	; 3600	; 12
	!word 24	; 4800	; 13
	!word 16	; 7200	; 14
	!word 12	; 9600	; 15
	!word 6		; 19200	; 16
	!word 3		; 38400	; 17
	!word 2		; 56000	; 18
	!word 1 	; 115200; 19
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Memcheck routine to be copied to ZP
;----------------------------------------------------------------------------------------------
.num_patterns = $03
.pattern  !byte $aa,$55,$ff,$00

.selfmod_start
!pseudopc .target {

      stz ram_end_h
      
-     ldx #.num_patterns
--    lda .pattern,x
.a     sta .start_check   ; Start at $0200. skip stack for now      
.b     cmp .start_check
      bne +
      
      dex 
      bne --

      inc .a+1
      inc .b+1
      bne -

      ; Stop at $e000 to prevent overwriting BIOS Code when ROMOFF
      ldx .a+2
      inx
      stx .a+2
      stx .b+2
      cpx #$e0
      
      bne -

+	  
	  lda .a+2
	  sta ram_end_l
	  lda .a+1
	  sta ram_end_h

      jmp .back_from_memcheck
}
.selfmod_end

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00


sys_chrout
chrout		jmp .chrout
sys_chrin
chrin		jmp .chrin
sys_lcdclear
lcdclear	jmp .lcdclear
sys_lcdprint
lcdprint 	jmp .lcdprint
sys_lcdstring
lcdstring 	jmp .lcdstring
sys_lcdhex
lcdhex 		jmp .lcdhex 
sys_decout
decout 		jmp .decout
sys_decoutz
decoutz 	jmp .decoutz
sys_irqhandler
irqhandler  jmp .irqhandler
sys_lcdbusy
lcdbusy 	jmp .lcdbusy
sys_lcdxy
lcdxy 		jmp .lcdxy

sys_spi_rw_byte	
spi_rw_byte	jmp .spi_rw_byte

sys_spi_r_byte	
spi_r_byte	jmp .spi_r_byte

sys_upload	jmp .upload

sys_sd_write_block
sd_write_block 	jmp .sd_write_block

sys_sd_read_block
sd_read_block 	jmp .sd_read_block


sys_sd_param_init
sd_param_init 	jmp .sd_param_init

sys_sd_deselect_card
sd_deselect_card 	jmp .sd_deselect_card
sys_sd_select_card
sd_select_card 	jmp .sd_select_card
sys_sd_cmd
sd_cmd 		jmp .sd_cmd
sys_strout
strout 		jmp .strout
sys_hexout
hexout 		jmp .hexout
sys_uart_rx
uart_rx     jmp .uart_rx
sys_uart_tx
uart_tx     jmp .uart_tx
sys_fat_mount
fat_mount   jmp .fat_mount
sys_getkey
getkey 		jmp .kbd_getkey	
sys_sd_read_multiblock
sd_read_multiblock 	jmp .sd_read_multiblock

;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!word .do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!word .do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!word .do_irq
