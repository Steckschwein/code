*= $e000			; ROM Start

; Ring buffer for ACIA Receive
recvbuf		= $0700
; Read pointer
rd_ptr		= $e2
; write pointer
wr_ptr		= $e3

linebuf		= $0800

;----------------------------------------------------------------------------------------------
; zeropage locations 
;----------------------------------------------------------------------------------------------
; IRQ vector
irqvec		= $e0


; general purpose temp variables
tmp0		= $f0
tmp1		= $f1
tmp2		= $f2
tmp3		= $f3
tmp4		= $f4
tmp5		= $f5
tmp6		= $f6
tmp7		= $f7

; pointer for string output functions 
msgptr 		= $fe
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; ACIA 
;----------------------------------------------------------------------------------------------
acia 		= $d000
txdata		= acia
rxdata		= acia
aciast		= acia+1 	; ACIA status register
aciacmd		= acia+2 	; ACIA command register
aciactl		= acia+3 	; ACIA control register
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; VIA1 
;----------------------------------------------------------------------------------------------
via1		= $d100
via1porta	= via1+1
via1portb	= via1
via1ddrb 	= via1+2
via1ddra	= via1+3
via1t1cl	= via1+4
via1t1ch	= via1+5
via1acr		= via1 + $0b
via1ifr		= via1 + $0d
via1ier		= via1 + $0e
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; LCD 
;----------------------------------------------------------------------------------------------
lcdctl		= $d200
lcddata		= lcdctl+1
;----------------------------------------------------------------------------------------------

main
		
			lda #<txt
			sta msgptr

			lda #>txt
			sta msgptr+1

			jsr lcdstring

			lda #$00
			sta tmp0
			lda #$10
			sta tmp1

;			jsr init_buf
			jsr lcdclear
			; wait for data
-			
			jsr buf_dif
			cmp #$0
			beq -

			ldy #$00
-			ldx #$00

;--			jsr rxbyte
--			jsr rd_buf
			sta (tmp0),y

	;		jsr lcdprint

			
			JSR  buf_dif     ; How many bytes are left to read?
        	CMP  #$E0        ; Is it at least 224?
        	BCS  +    ; If so, leave the sending end turned off.
        	LDA  #%00001001  ; Else, tell the sending end that it's ok to start
        	STA aciacmd   ; sending data again, by setting its CTS line true.
+              ; Continue...
			
			iny
			cpy #$00
			bne +
			inc tmp1
+			

			cmp #$00	; is it $00?
			bne - 		; no? reset counter and read next one

			inx		; count $00
			cpx #$05	; 5 $00 in a row?
			bne --		; read next

			; 5 in a row, we are done
			jmp $1000
txt			!text "Send data!", $00

;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------
do_reset
			sei

			; init IO devices
			jsr init_lcd
			jsr init_buf

			jsr init_via1
			jsr init_acia
			
			jsr memtest

			; Set IRQ Vector
			lda #<irqhandler
			sta irqvec

			lda #>irqhandler
			sta irqvec+1
				
			cli 

			jmp main

;----------------------------------------------------------------------------------------------
; init VIA1
;----------------------------------------------------------------------------------------------
init_via1
			pha
			; VIA1
			lda #%00000001
			sta via1ddra

			lda #$01
			sta via1porta

			
;			lda #%11000000
;			sta via1ier             ; enable VIA1 T1 interrupts
			stz via1ier
;			lda #%01000000
;		 	sta via1acr             ; T1 continuous, PB7 disabled
		 	
		 	pla
		 	rts



;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
do_nmi 
			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
do_irq
			jmp (irqvec)
			rts

irqhandler
			pha



			; VIA1 T1 will overflow 100 times per second.
			lda #%01000000      ; via1 timer1
			and via1ifr
			beq +				; not via1? bye or check for other interrupts

			bit via1t1cl            ; clears interrupt
			
			
+			jsr service_acia

			pla
			rti

service_acia
        	pha
        	phx

        	lda  aciast   	; get the contents of the acia's status register.
        	bpl  +         ; if acia didn't call, just exit.
        	and  #%00000111  ; check for error conditions by anding with 7.
        	bne  report_err  ; if there was any error condx, go report it.

        	lda  rxdata   	; get the data from the acia
        	jsr lcdhex
        	jsr  wr_buf      ; and store it in the buffer.

        	jsr  buf_dif     ; now see how full the buffer is.
        	cmp  #$f0        ; if it has less than 240 bytes unread,
        	bcc  +         ; just exit the isr here.

        	lda  #1          ; else, tell the other end to stop sending data before
        	sta  aciacmd   ; the buffer overflows, by storing 1 in the acia's
                          ; command register.  (see text.)
+    		plx
			rts
report_err
			lda #'X'
			jsr lcdprint
			rts


;----------------------------------------------------------------------------------------------
; Test memory (zeropage only atm)
;----------------------------------------------------------------------------------------------
memtest
			lda #$ff
			jsr check_zeropage
			rts

;----------------------------------------------------------------------------------------------
; Check zeropage. A contains 0 if ok, != 0 if error
;----------------------------------------------------------------------------------------------

check_zeropage
			phx

			ldx #$00
-			sta $00,x
			cmp $00,x
			bne stop
			inx
			cpx #$ff
			bne -
			
			plx
			rts
stop
			txa
			plx 
			rts

;----------------------------------------------------------------------------------------------
; STROUT - Output string
;----------------------------------------------------------------------------------------------
i_strout	pha                 ;save a, y to stack
			phy
		
			ldy #$00
- 		  	lda (msgptr),y
          	beq +
          	jsr chrout
          	iny
          	bne -
+		   	ply                 ;restore a, y
          	pla
          	rts

;----------------------------------------------------------------------------------------------
; CHRHEX - ouuput binary as hex string 
;----------------------------------------------------------------------------------------------
i_chrhex 	pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr chrout
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr chrout        ;print value on the lcd

			pla
			rts


;----------------------------------------------------------------------------------------------
; *** LCD initialisation
;----------------------------------------------------------------------------------------------
init_lcd  	ldx #$04            ;do function set 4 times
-		  	lda #$38            ;function set: 8 bit, 2 lines, 5x7
			sta lcdctl
			jsr lcdbusy         ;wait for busy flag to clear
			dex
			bne -
			lda #$06            ;entry mode set: increment, no shift
			sta lcdctl
			jsr lcdbusy
			lda #$0e            ;display on, cursor on, blink off
			sta lcdctl
			jsr lcdbusy
			lda #$01            ;clear display
			sta lcdctl
			jsr lcdbusy
			lda #$80            ;ddram address set: $00
			sta lcdctl
			jsr lcdbusy
			rts

; *** Clear LCD display and return cursor to home
; registers preserved
i_lcdclear  pha
			lda #$01
			sta lcdctl
			jsr lcdbusy
			lda #$80
			sta lcdctl
			jsr lcdbusy
			pla
			rts

; *** Wait for LCD busy bit to clear
; registers preserved
i_lcdbusy   pha
-			lda lcdctl            ;read from lcd register 0
			and #$80            ;check bit 7 (busy)
			bne -
			pla
			rts

; *** Print character on LCD (40 character)
; registers preserved
i_lcdprint  pha
			sta lcddata            ;output the character
			jsr lcdbusy
			lda lcdctl            ;get current ddram address
			and #$7f
			cmp #$28          	;wrap from pos $13 (line 1 char 20)...
			bne +
			lda #$c0            	;...to $40 (line 2 char 1)
			sta lcdctl
			jsr lcdbusy
+			pla
			rts

; *** print string on lcd
; registers preserved
i_lcdstring pha                 ;save a, y to stack
			tya
			pha
			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr lcdprint
			iny
			bne -
+			pla                 ;restore a, y
			tay
			pla
			rts

; *** Print 2 digit hex number on LCD
; A, X registers preserved
i_lcdhex    pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla
			rts

; *** Lookup table for HEX to ASCII
hexascii	!text "0123456789ABCDEF"

;----------------------------------------------------------------------------------------------
; init ACIA
;----------------------------------------------------------------------------------------------
init_acia
			pha
			; ACIA
		    ; Reset ACIA
			stz aciast

		    ; set 1 stop bit, 8 bit data, internal clock, 19200bps
;		    lda #%00011111
		    lda #%00011010 ; 2400bps

		    sta aciactl
			
			; set no parity, no echo, no tx interrupts, rts low, no rx interrupts, dtr low  
;		    lda #%00001011
		    lda #%00001001

		    sta aciacmd

		    pla
			rts

init_buf
			stz rd_ptr
			stz wr_ptr
			rts

wr_buf
  			ldx  wr_ptr     ; start with a containing the byte to put in the buffer.
        	sta  recvbuf,x   ; get the pointer value and store the data where it says,
        	inc  wr_ptr     ; then increment the pointer for the next write.
        	rts
 ;-------------
rd_buf
			ldx  rd_ptr     ; ends with a containing the byte just read from buffer.
        	lda  recvbuf,x   ; get the pointer value and read the data it points to.

         	inc  rd_ptr     ; then increment the pointer for the next read.
        	rts
 ;-------------
buf_dif
			lda  wr_ptr     ; find difference between number of bytes written
        	sec             ; and how many read.
        	sbc  rd_ptr     ; ends with a showing the number of bytes left to read.
        	rts
 ;-------------

;----------------------------------------------------------------------------------------------
; RXBYTE - receive byte from ACIA and store it in A
;----------------------------------------------------------------------------------------------
rxbyte		lda #$08
rxfull		bit aciast
			beq rxfull
			lda rxdata
			rts

;----------------------------------------------------------------------------------------------
; TXBYTE - send byte in A via ACIA
;----------------------------------------------------------------------------------------------
txbyte		pha
    		lda #$10
txfull	 	bit aciast ; wait for tdre bit = 1
		    beq txfull
		    pla
		    sta txdata
		    rts
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; LCDDECZ - output byte in A as decimal ASCII with leading zeros
;----------------------------------------------------------------------------------------------
i_lcddecz
   phx
   phy
   ldx #2
   ldy #$4c
-- sty tmp0
   lsr
-  rol
   bcs +
   cmp dec_tbl,x
   bcc ++
+  sbc dec_tbl,x
   sec
++ rol tmp0
   bcc -
   tay
   lda tmp0
   jsr lcdprint
   tya
   ldy #$13
   dex
   bpl --
   ply
   plx
   rts

;----------------------------------------------------------------------------------------------
; LCDDEC - output byte in A as decimal ASCII without leading zeros
;----------------------------------------------------------------------------------------------
i_lcddec
   phx
   phy
   ldx #1
   stx tmp1
   inx
   ldy #$40
-- sty tmp0
   lsr
-  rol
   bcs ++
   cmp dec_tbl,x
   bcc +
++ sbc dec_tbl,x
   sec
+  rol tmp0
   bcc -
   tay
   cpx tmp1
   lda tmp0
   bcc +
   beq ++
   stx tmp1
+  eor #$30
   jsr lcdprint
++ tya
   ldy #$10
   dex
   bpl --
   ply
   plx

   rts

dec_tbl		!byte 128,160,200

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00
strout 		jmp i_strout
chrhex 		jmp i_chrhex
chrout		jmp txbyte
chrin		jmp rxbyte
lcdbusy 	jmp i_lcdbusy
lcdclear	jmp i_lcdclear
lcdprint 	jmp i_lcdprint
lcdstring 	jmp i_lcdstring
lcdhex 		jmp i_lcdhex 
lcddec 		jmp i_lcddec
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!byte <do_nmi
!byte >do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!byte <do_reset
!byte >do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!byte <do_irq
!byte >do_irq
