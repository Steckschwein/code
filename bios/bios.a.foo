*= $e000			; ROM Start
count 		= 19998 ; jiffy count 100Hz for 2MHz system
;count		= 29997 ; jiffy count 100Hz for 3MHz system

linebuf		= $0800

;----------------------------------------------------------------------------------------------
; zeropage locations 
;----------------------------------------------------------------------------------------------
; IRQ vector
irqvec		= $e0

; general purpose temp variables
tmp0		= $f0
tmp1		= $f1
tmp2		= $f2
tmp3		= $f3
tmp4		= $f4
tmp5		= $f5
tmp6		= $f6
tmp7		= $f7

; memcheck result
memcheck    = $f8

; time variables
hours	  	= $f9
minutes   	= $fa
seconds	  	= $fb
jiffies   	= $fc

; pointer for string output functions 
msgptr 		= $fe
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; ACIA 
;----------------------------------------------------------------------------------------------
acia 		= $d000
txdata		= acia
rxdata		= acia
aciast		= acia+1 	; ACIA status register
aciacmd		= acia+2 	; ACIA command register
aciactl		= acia+3 	; ACIA control register
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; VIA1 
;----------------------------------------------------------------------------------------------
via1		= $d100
via1porta	= via1+1
via1portb	= via1
via1ddrb 	= via1+2
via1ddra	= via1+3
via1t1cl	= via1+4
via1t1ch	= via1+5
via1acr		= via1 + $0b
via1ifr		= via1 + $0d
via1ier		= via1 + $0e
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; LCD 
;----------------------------------------------------------------------------------------------
lcdctl		= $d200
lcddata		= lcdctl+1
;----------------------------------------------------------------------------------------------

read_data
		
			lda #<txt
			sta msgptr

			lda #>txt
			sta msgptr+1

			jsr lcdstring

			lda #$00
			sta tmp0
			lda #$10
			sta tmp1

			ldy #$00
-			ldx #$00

--			jsr rxbyte

			sta $1000,x
			; sta (tmp0,x)
			pha
			lda #'*'
			jsr txbyte
			pla
			inx
		;	cpx #$00
		;	bne +
		;	inc tmp1
;+			

			cmp #$00	; is it $00?
			bne - 		; no? reset counter and read next one

			iny		; count $00
			cpy #$05	; 5 $00 in a row?
			bne --		; read next

			; 5 in a row, we are done
			jmp $1000
txt			!text "Send data!", $00

main	
		    lda #<hellomsg
			sta msgptr

			lda #>hellomsg
			sta msgptr+1

			jsr strout


			jsr lcdclear
			
			lda #<readymsg
			sta msgptr

			lda #>readymsg
			sta msgptr+1

			jsr lcdstring


			stz linebuf

--			ldx #$00 
			jsr prompt
-           jsr chrin
            cmp #$0d
            beq +
            jsr chrout
            jsr lcdprint
            sta linebuf,x
            inx
            lda #$00
            sta linebuf,x
            bra -

+			ldx #$00
			jsr handlecommand			

			bra --

hellomsg	!text $0a, $0d
			!text "65c02 CPU @ 2MHz", $0a, $0d
			!text "32k RAM   @ $0000-$7FFF", $0a, $0d
			!text "8k  ROM   @ $E000-$FFFF", $0a, $0d
			!text "IO        @ $D000-$DFFF", $0a, $0d
			!text "   ACIA   @ $D000-$D003", $0a, $0d
			!text "   VIA    @ $D100-$D103", $0a, $0d
			!text "   LCD    @ $D300-$D301", $0a, $0d
readymsg	!text "READY.", 0
crlf		!text $0a, $0d, $00
memfail     !text "MEMORY CHECK FAILED!", $00


handlecommand
			pha

			lda #$0a
			jsr chrout

			lda #$0d
			jsr chrout

			lda linebuf

+			cmp #'c'
			bne +

			jsr clock_out
+			cmp #'z'
			bne +

			jsr dump_zp			

+			cmp #'r'
			bne +

			jsr dump_regs
					
+			cmp #'u'
			bne +

			jmp read_data

+			cmp #'x'
			bne +

			jmp main

+			lda #$0a
		    jsr chrout
		    lda #$0d
		    jsr chrout

			lda #<linebuf
			sta msgptr

			lda #>linebuf
			sta msgptr+1

			jsr strout

			pla
			rts


prompt	    pha
            lda #<+
            sta msgptr
            lda #>+
            sta msgptr+1
               
            jsr strout

            pla
            rts
+	        !text $0a, $0d, "> ", $00

dump_regs
			pha
			lda #'A'
			jsr chrout
			lda #':'
			jsr chrout

			pla
			jsr chrhex
			
			pha
			lda #' '
			jsr chrout
			lda #'X'
			jsr chrout
			lda #':'
			jsr chrout

			txa
			jsr chrhex

			lda #' '
			jsr chrout
			lda #'Y'
			jsr chrout
			lda #':'
			jsr chrout

			tya
			jsr chrhex

			lda #<crlf
			sta msgptr

			lda #>crlf
			sta msgptr+1

			jsr strout
			pla
			rts

dump_zp		pha
			phx
			phy


			ldx #$00
			ldy #$08
			sty tmp0

			; our IO-routines will alter the ZP, so copy the current ZP to somewhere else
-			lda $00,x
			sta $0300,x
			
			cpx #$ff
			inx
			bne -
			
-			txa 		; Output ZP address
			jsr chrhex

			lda #':'
			jsr chrout

			lda $0300,x ; output byte
			jsr chrhex

			lda #' '
			jsr chrout

			dec tmp0 
			bne +

			jsr newline
			ldy #$08
			sty tmp0

+			inx
			bne -

			jsr newline

			ply
			plx
			pla
			rts

newline		pha

			lda #$0a
			jsr chrout

			lda #$0d
			jsr chrout

			pla
			rts
;----------------------------------------------------------------------------------------------
; RESET Routine. Call subroutines to init all components 
;----------------------------------------------------------------------------------------------
do_reset
			sei

			; init IO devices
			jsr init_lcd
			jsr init_via1
			jsr init_acia
			
			jsr memtest

			; Set IRQ Vector
			lda #<irqhandler
			sta irqvec

			lda #>irqhandler
			sta irqvec+1
			
			stz hours
			stz minutes
			stz seconds
			
			cli 

			jmp read_data

;----------------------------------------------------------------------------------------------
; init VIA1
;----------------------------------------------------------------------------------------------
init_via1
			pha
			; VIA1
			lda #%00000001
			sta via1ddra

			lda #$01
			sta via1porta

			lda #<count
			sta via1t1cl            ; set low byte of count
			lda #>count
			sta via1t1ch            ; set high byte of count
			
			lda #%11000000
			sta via1ier             ; enable VIA1 T1 interrupts

			lda #%01000000
		 	sta via1acr             ; T1 continuous, PB7 disabled
		 	
		 	pla
		 	rts



;----------------------------------------------------------------------------------------------
; IO_NMI Routine. Handle NMI
;----------------------------------------------------------------------------------------------
do_nmi 
			jsr dump_zp
			rti

;----------------------------------------------------------------------------------------------
; IO_IRQ Routine. Handle IRQ
;----------------------------------------------------------------------------------------------
do_irq
			jmp (irqvec)
			rts

irqhandler
			pha

			; VIA1 T1 will overflow 100 times per second.
			lda #%01000000      ; via1 timer1
			and via1ifr
			beq +				; not via1? bye or check for other interrupts

			bit via1t1cl            ; clears interrupt
			
			jsr clock

+			pla
			rti

;----------------------------------------------------------------------------------------------
; CLOCK Routine. Update Clock variables every 100 times.
;----------------------------------------------------------------------------------------------
clock
			pha

			inc jiffies
			lda jiffies
		    cmp #100            ; reached 1 second?
		    bne +            ; if not, done for now

			;lda #$00
			;sta jiffies	
			stz jiffies
			
			inc seconds
			lda seconds
			cmp #60
			bne +

			stz seconds

			inc minutes
			lda minutes
			cmp #60
			bne +

			stz minutes

			inc hours
			lda hours
			cmp #24
			bne +

			stz hours

+			pla
			rts

clock_out	pha
			lda hours
			jsr lcddec

			lda #':'
			jsr lcdprint

			lda minutes
			jsr lcddec

			lda #':'
			jsr lcdprint

			lda seconds
			jsr lcddec

			pla
			rts

;----------------------------------------------------------------------------------------------
; Delay loop. burn cycles like hell
;----------------------------------------------------------------------------------------------
!zone cyclewaster {
waste_cycles
			phx
			phy
			ldy #$1f
--			ldx #$ff
-			!for i,10{
			nop
			}
			DEX
			bne -
			dey
			bne --
			plx
			ply
			rts
}

;----------------------------------------------------------------------------------------------
; Test memory (zeropage only atm)
;----------------------------------------------------------------------------------------------
memtest
			lda #$ff
			jsr check_zeropage
			rts

;----------------------------------------------------------------------------------------------
; Check zeropage. A contains 0 if ok, != 0 if error
;----------------------------------------------------------------------------------------------

check_zeropage
			phx

			ldx #$00
-			sta $00,x
			cmp $00,x
			bne stop
			inx
			cpx #$ff
			bne -
			
			plx
			rts
stop
			txa
			plx 
			rts

;----------------------------------------------------------------------------------------------
; STROUT - Output string
;----------------------------------------------------------------------------------------------
i_strout	pha                 ;save a, y to stack
			phy
		
			ldy #$00
- 		  	lda (msgptr),y
          	beq +
          	jsr chrout
          	iny
          	bne -
+		   	ply                 ;restore a, y
          	pla
          	rts

;----------------------------------------------------------------------------------------------
; CHRHEX - ouuput binary as hex string 
;----------------------------------------------------------------------------------------------
i_chrhex 	pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr chrout
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr chrout        ;print value on the lcd

			pla
			rts


;----------------------------------------------------------------------------------------------
; *** LCD initialisation
;----------------------------------------------------------------------------------------------
init_lcd  	ldx #$04            ;do function set 4 times
-		  	lda #$38            ;function set: 8 bit, 2 lines, 5x7
			sta lcdctl
			jsr lcdbusy         ;wait for busy flag to clear
			dex
			bne -
			lda #$06            ;entry mode set: increment, no shift
			sta lcdctl
			jsr lcdbusy
			lda #$0e            ;display on, cursor on, blink off
			sta lcdctl
			jsr lcdbusy
			lda #$01            ;clear display
			sta lcdctl
			jsr lcdbusy
			lda #$80            ;ddram address set: $00
			sta lcdctl
			jsr lcdbusy
			rts

; *** Clear LCD display and return cursor to home
; registers preserved
i_lcdclear  pha
			lda #$01
			sta lcdctl
			jsr lcdbusy
			lda #$80
			sta lcdctl
			jsr lcdbusy
			pla
			rts

; *** Wait for LCD busy bit to clear
; registers preserved
i_lcdbusy   pha
-			lda lcdctl            ;read from lcd register 0
			and #$80            ;check bit 7 (busy)
			bne -
			pla
			rts

; *** Print character on LCD (40 character)
; registers preserved
i_lcdprint  pha
			sta lcddata            ;output the character
			jsr lcdbusy
			lda lcdctl            ;get current ddram address
			and #$7f
			cmp #$28          	;wrap from pos $13 (line 1 char 20)...
			bne +
			lda #$c0            	;...to $40 (line 2 char 1)
			sta lcdctl
			jsr lcdbusy
+			pla
			rts

; *** print string on lcd
; registers preserved
i_lcdstring pha                 ;save a, y to stack
			tya
			pha
			ldy #$00
-		  	lda (msgptr),y
			beq +
			jsr lcdprint
			iny
			bne -
+			pla                 ;restore a, y
			tay
			pla
			rts

; *** Print 2 digit hex number on LCD
; A, X registers preserved
i_lcdhex    pha
			lsr                ;shift high nybble into low nybble
			lsr 
			lsr 
			lsr 
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla                 ;restore original value
			pha
			and #$0f            ;select low nybble
			tay
			lda hexascii,y      ;convert to ascii
			jsr lcdprint        ;print value on the lcd
			pla
			rts

; *** Lookup table for HEX to ASCII
hexascii	!text "0123456789ABCDEF"

;----------------------------------------------------------------------------------------------
; init ACIA
;----------------------------------------------------------------------------------------------
init_acia
			pha
		    ; ACIA
		    ; set 1 stop bit, 8 bit data, internal clock, 19200bps
		    lda #%00011111
		    sta aciactl
			
			; set no parity, no echo, no tx interrupts, rts low, no rx interrupts, dtr low  
		    lda #%00001011
		    sta aciacmd

		    pla
			rts
;----------------------------------------------------------------------------------------------
; RXBYTE - receive byte from ACIA and store it in A
;----------------------------------------------------------------------------------------------
rxbyte		lda #$08
rxfull		bit aciast
			beq rxfull
			lda rxdata
			rts

;----------------------------------------------------------------------------------------------
; TXBYTE - send byte in A via ACIA
;----------------------------------------------------------------------------------------------
txbyte		pha
    		lda #$10
txfull	 	bit aciast ; wait for tdre bit = 1
		    beq txfull
		    pla
		    sta txdata
		    rts
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; LCDDECZ - output byte in A as decimal ASCII with leading zeros
;----------------------------------------------------------------------------------------------
i_lcddecz
   phx
   phy
   ldx #2
   ldy #$4c
-- sty tmp0
   lsr
-  rol
   bcs +
   cmp dec_tbl,x
   bcc ++
+  sbc dec_tbl,x
   sec
++ rol tmp0
   bcc -
   tay
   lda tmp0
   jsr lcdprint
   tya
   ldy #$13
   dex
   bpl --
   ply
   plx
   rts

;----------------------------------------------------------------------------------------------
; LCDDEC - output byte in A as decimal ASCII without leading zeros
;----------------------------------------------------------------------------------------------
i_lcddec
   phx
   phy
   ldx #1
   stx tmp1
   inx
   ldy #$40
-- sty tmp0
   lsr
-  rol
   bcs ++
   cmp dec_tbl,x
   bcc +
++ sbc dec_tbl,x
   sec
+  rol tmp0
   bcc -
   tay
   cpx tmp1
   lda tmp0
   bcc +
   beq ++
   stx tmp1
+  eor #$30
   jsr lcdprint
++ tya
   ldy #$10
   dex
   bpl --
   ply
   plx

   rts

dec_tbl		!byte 128,160,200

;----------------------------------------------------------------------------------------------
; Jump table
;----------------------------------------------------------------------------------------------
*=$ff00
strout 		jmp i_strout
chrhex 		jmp i_chrhex
chrout		jmp txbyte
chrin		jmp rxbyte
lcdbusy 	jmp i_lcdbusy
lcdclear	jmp i_lcdclear
lcdprint 	jmp i_lcdprint
lcdstring 	jmp i_lcdstring
lcdhex 		jmp i_lcdhex 
lcddec 		jmp i_lcddec
clockout    jmp clock_out
;----------------------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------------
; Interrupt vectors
;----------------------------------------------------------------------------------------------
; $FFFA/$FFFB NMI Vector
*= $fffa
!byte <do_nmi
!byte >do_nmi
; $FFFC/$FFFD reset vector
;*= $fffc
!byte <do_reset
!byte >do_reset
; $FFFE/$FFFF IRQ vector
;*= $fffe
!byte <do_irq
!byte >do_irq
