!source <t9929.h.a>
;
;	TODO	
;		improve some functions,  avoid nop for vdp write delay 2Âµs by opcode reordering
;		investigate the difference between wdc and rockwell if no nop is used
;
vdp_sreg:
	sta	a_vreg
	+vnops
	nop
	sty   a_vreg
	rts

vdp_display_off:
;	jsr	.vdp_wait_blank
	lda		#v_reg1_16k	;enable 16K ram, disable screen
	sta 	a_vreg
	+vnops
	lda	  	#v_reg1
	sta   	a_vreg
	rts

;	input:
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of bytes to fill with pattern
;	adrl - pattern
vdp_fills:
	jsr   vdp_sreg
	lda   .adrl
-  	+vnops
	sta   a_vram
	dex
	bne	-
	rts
	
; fill vram with pattern
;
vdp_fill:
;	a - low byte vram adress
;	y - high byte vram adress
;	x - amount of 256byte blocks (page counter)
;	adrl - pattern
	jsr   vdp_sreg
	ldy   #$00
	lda   .adrl
-  	+vnops
	iny
	sta   a_vram
	bne   -
	dex
	bne   -
	rts

;	input:
;	adrl/adrh vector set
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of 256byte blocks (page counter)
vdp_memcpy:
	jsr   vdp_sreg
	ldy   #$00
-  	lda   (.adrl),y
	+vnops
	iny
	sta   a_vram
	bne   -
	inc   .adrh
	dex
	bne   -
	rts
	
;	input:
;	adrl/adrh vector set
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of bytes to copy
vdp_memcpys:
	jsr	vdp_sreg
	ldy   #$00
-  	lda   (.adrl),y
	+vnops
	sta   a_vram
	iny
	dex
	bne	-
	rts

vdp_mode_text_blank
	ldx	#$04				; 4 x 256 bytes
	bra	+
vdp_mode_gfx1_blank:		; 3 x 256 bytes
	ldx	#$03
+	lda	#' '					;fill vram screen with blank
	sta	.adrl
	lda	#$00
	ldy	#.WRITE_ADDRESS+$18
	jmp	vdp_fill

vdp_mode_gfx1_sprites_off
vdp_mode_sprites_off
	lda	#$d0					;sprites off, at least y=$d0 will disable the sprite subsystem
	sta	.adrl
	ldx	#$32*4
	lda	#$00
	ldy	#.WRITE_ADDRESS+$3c
	jmp	vdp_fills

.vdp_init_bytes_gfx1
	!byte 	0
	!byte	v_reg1_16k|v_reg1_display_on|v_reg1_spr_size|v_reg1_int
	!byte 	($1800 / $400)	; name table - value * $400					--> characters 
	!byte 	($2000 / $40)	; color table - value * $40 (gfx1), 7f/ff (gfx2)
	!byte 	($0000 / $800) ; pattern table (charset) - value * $800  	--> offset in VRAM 
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 		--> offset in VRAM
	!byte 	($0800 / $800)  ; sprite pattern table - value * $800  		--> offset in VRAM
	!byte	Black

;
;	gfx mode 1 - 32x24 character mode, 16 colors with same color for 8 characters in a block
;
vdp_mode_gfx1:
	sta	.adrl		;set character color
	ldx	#$20
	lda	#$00
	ldy	#.WRITE_ADDRESS+$20	;color vram
	jsr	vdp_fills
	
	+SetVector .vdp_init_bytes_gfx1, .adrl
	
; setup video registers upon given table
;	input:
;	adrl/adrh vector set to vdp init table for al 8 vdp registers
vdp_init_reg
;	jsr		.vdp_wait_blank
	ldy	#$00
	ldx	#v_reg0
-  	lda (.adrl),y
	sta a_vreg
	iny				;iny first, burn cycle to avoid vdp nop
	stx a_vreg
	inx
	cpy	#$08
	bne   -
	rts

vdp_irq_off
	lda #v_reg1_16k|v_reg1_display_on	;switch interupt off
	ldy	#v_reg1
	jmp	vdp_sreg

;	
;
!ifndef bios_stuff {
;
;	gfx 2 - each pixel can be adressed - e.g. for image
;	
vdp_mode_gfx2
	jsr	.vdp_fill_name_table
	+SetVector	vdp_init_bytes_gfx2, .adrl
	bra	vdp_init_reg

;
;	gfx 3 - 4x4 color block - multicolor mode
;	
vdp_mode_gfx3
	jsr	.vdp_fill_name_table
	+SetVector	vdp_init_bytes_gfx3, .adrl
	bra	vdp_init_reg

;
;	text mode - 40x24 character mode, 16 colors with same color for 8 characters in a block
;
vdp_mode_text
	+SetVector vdp_init_bytes_text, .adrl
	bra	vdp_init_reg

.vdp_wait_blank
	php
	sei
-	bit	a_vreg
	bpl -	   ; wait until blank - irq flag set?
	pla
	and	#$04	;check interupt was set?
	bne	+
	cli
+	rts

;
;	requires	gfx2_mode_bitmap_address and gfx2_mode_ptr_bitmap_color_address setup correctly with the adresses to image and color data
;
gfx2_mode_bitmap_address 			!word $1000	;default data adress $1000
gfx2_mode_ptr_bitmap_color_address	!word $2800	;default data adress $2800
vdp_mode_gfx2_load_bitmap
	lda	gfx2_mode_bitmap_address
	sta	.adrl
	lda	gfx2_mode_bitmap_address+1
	sta	.adrh
	lda	#$00
	ldy	#.WRITE_ADDRESS+$00
	ldx	#$18	;6k bitmap - $1800
	jsr	vdp_memcpy					;load the pic data --> pattern table at vram $0000
	; load color
	lda	gfx2_mode_ptr_bitmap_color_address
	sta	.adrl
	lda	gfx2_mode_ptr_bitmap_color_address+1
	sta	.adrh
	lda	#$00
	ldy	#.WRITE_ADDRESS+$20
	ldx	#$18	;6k color map - $1800
	jmp	vdp_memcpy					;load the pic data --> color table at vram $2000

gfx3_mode_bitmap_address		!word	$1800
vdp_mode_gfx3_load_bitmap
	lda	gfx3_mode_bitmap_address
	sta	.adrl
	lda	gfx3_mode_bitmap_address+1
	sta	.adrh
	lda	#$00
	ldy	#.WRITE_ADDRESS+$00
	ldx	#$03	;768 byte
	jsr	vdp_memcpy					;load the pic data --> pattern table at vram $0000
	rts
	
.vdp_fill_name_table
	;set 768 different patterns --> name table
	lda	#$00
	ldy	#.WRITE_ADDRESS+$38
	jsr	vdp_sreg
	ldy	#$03
	ldx	#$00
-	+vnops
	stx	a_vram
	inx
	bne	-
	dey
	bne	-
rts
	
vdp_init_bytes_text
	!byte 0
	!byte v_reg1_16k|v_reg1_display_on|v_reg1_int|v_reg1_m1
	!byte 	(ADDRESS_GFX1_SCREEN / $400)	; name table - value * $400					--> characters 
	!byte 	0	; not used
	!byte 	($0000 / $800) ; pattern table (charset) - value * $800  	--> offset in VRAM 
	!byte	0	; not used
	!byte 	0	; not used
	!byte	Medium_Green<<4|Black

vdp_init_bytes_gfx2
	!byte 	v_reg0_m3		; 
	!byte 	v_reg1_16k|v_reg1_display_on|v_reg1_spr_size; |v_reg1_int
	!byte 	($3800 / $400)	; name table - value * $400
	!byte	$ff				; color table setting for gfx mode 2 --> only Bit 7 is taken into account 0 => at vram $0000, 1 => at vram $2000, Bit 6-0 AND to character number
	!byte	$03 			; pattern table - either at vram $0000 (Bit 2 = 0) or at vram $2000 (Bit 2=1), Bit 0,1 are AND to select the pattern array
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 --> offset in VRAM
	!byte	($1800 / $800)	; sprite pattern table - value * $800  --> offset in VRAM
	!byte	Black

vdp_init_bytes_gfx3
	!byte 	0		; 
	!byte 	v_reg1_16k|v_reg1_display_on|v_reg1_m2|v_reg1_spr_size; |v_reg1_int
	!byte 	($3800 / $400)	; name table - value * $400
	!byte	$ff				; color table setting for gfx mode 2 --> only Bit 7 is taken into account 0 => at vram $0000, 1 => at vram $2000, Bit 6-0 AND to character number
	!byte	$03 			; pattern table - either at vram $0000 (Bit 2 = 0) or at vram $2000 (Bit 2=1), Bit 0,1 are AND to select the pattern array
	!byte	($3c00 / $80)	; sprite attribute table - value * $80 --> offset in VRAM
	!byte	($1800 / $800)	; sprite pattern table - value * $800  --> offset in VRAM
	!byte	Black
	
;
;   input:	a - color
;
vdp_bgcolor
	sta   a_vreg
	+vnops
	lda   #v_reg7
	sta   a_vreg
	rts

vdp_load_sprites16x16
vdp_load_sprites16
;	input:
;	adrl/adrh vector set to sprite table
;	a - low byte vram adress
;	y - high byte vram adress
;  	x - amount of sprites
	jsr	vdp_sreg
--	ldy	#$00
-	lda	(.adrl),y	
	+vnops
	sta a_vram
	iny
	iny
	cpy	#$20
	bne	-
	ldy	#$00
	inc	.adrl
-	lda	(.adrl),y	
	+vnops
	sta a_vram
	iny
	iny
	cpy	#$20
	bne	-
	lda	.adrl
	clc	
	adc	#$1f
	sta	.adrl
	dex
	bne   --
	rts
}

;
;direct vram access - used i.e. in bios
;
!ifdef bios_stuff {

.inc_cursor_y
	lda crs_y
	cmp	#23		;last line
	bne	+
;	jmp	.textui_scroll_up	; scroll and exit
	stz	crs_y ; goto y position 0 - TODO improve, maybe scroll
	rts
+	inc crs_y
	rts

.KEY_CR=$0a
.KEY_LF=$0d
.KEY_BACKSPACE=$08
vdp_chrout
	cmp	#.KEY_CR			;cariage return ?
	bne	+
	stz	crs_x
	bra	+++
+	cmp	#.KEY_LF			;line feed
	bne	+
	jsr	.inc_cursor_y
	bra	+++
+	cmp	#.KEY_BACKSPACE
	bne	+
	lda	crs_x
	beq	++
	dec	crs_x
	bra +++
++	lda	crs_y			; cursor y=0, no dec
	beq	+++
	dec	crs_y
	lda	#(.COLS-1)			; set x to end of line above
	sta	crs_x
	bra	+++
+	jsr	.vdp_write_char
	lda	crs_x
	cmp	#(.COLS-1)
	beq +
	inc	crs_x
	bra	+++
+	stz	crs_x
	jsr	.inc_cursor_y
+++	rts

.vdp_write_char
	pha
-	bit	a_vreg
	bpl	-
	jsr .vdp_set_addr
	pla
	sta a_vram
	rts
	
.vdp_set_addr
	lda     crs_y   ; * 32
	asl
	asl
	asl
	asl
	asl
	clc
	adc     crs_x
	sta     a_vreg

	lda     crs_y   ; * 32
	lsr                     ; div 8 -> page offset 0-2
	lsr
	lsr
	clc
	adc     #.WRITE_ADDRESS + $18;>ADDRESS_GFX1_SCREEN
	sta     a_vreg
	rts
}