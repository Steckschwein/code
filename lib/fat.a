!src <sdcard.h.a>
!src <errors.h.a>


FD_start_cluster = $00
FD_file_size = $08


!macro saveClusterNo .where {
	ldy #DIR_FstClusHI +1
	lda (sd_blkptr),y
	sta .where +3

	dey
	lda (sd_blkptr),y
	sta .where +2

	; stz .where +3
	; stz .where +2
	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta .where +1
	
	dey
	lda (sd_blkptr),y
	sta .where

} 

.blocks = tmp7

.fat_read

	jsr .calc_lba_addr
	jsr .calc_blocks


!ifdef experimental {
	jsr sd_read_multiblock
}
!ifndef experimental {

-	jsr sd_read_block

	inc sd_blkptr+1 ; 3 bytes, 6 cycles

	jsr .inc_lba_address
	
	dec .blocks
	bne -

}
	
	rts

; .fat_dir_find_entry
; 	ldy #DIR_Name
; -
; 	lda (dirptr),y
; 	cmp filename_buf,y
; 	bne +
; 	iny
; 	cpy #$0b 
; 	bne -

; 	; bra .fat_open_found
; 	sec
; 	rts
; +	clc
; 	rts


.fat_open
	pha
	phy



	stz errno

	; +SetVector .fat_dir_filter_open, 	fat_dir_filter_hook


	ldx #$00
	jsr .calc_lba_addr


	; jsr .convert_filename

	; +SetVector .fat_dir_find_entry, fat_dir_action_hook

	; jsr .fat_dir_scan




	jsr .fat_find_first
	bcs .fat_open_found
	
.fat_no_such_file
	lda #fat_file_not_found
	sta errno
	jmp .end_open

.fat_open_error
	lda #fat_open_error
	sta errno
	jmp .end_open

; found
.fat_open_found
	ldy #DIR_Attr
	lda (dirptr),y
	bit #$10 ; Is a directory
    beq +

    ldx #$00 ; direcories always go to fd #0
    ; +saveClusterNo curr_dir_cluster_no
    ; bra .end_open 
    bra ++

+	bit #$20 ; Is file
	beq .fat_open_error

	jsr .fat_alloc_fd
	cpx #$ff
	beq .fat_open_error
	

++	

	ldy #DIR_FstClusHI +1
	lda (dirptr),y
	sta fd_area + FD_start_cluster +3, x

	dey	
	lda (dirptr),y
	sta fd_area + FD_start_cluster +2, x
	
	ldy #DIR_FstClusLO +1
	lda (dirptr),y
	sta fd_area + FD_start_cluster +1, x
	
	dey
	lda (dirptr),y
	sta fd_area + FD_start_cluster +0, x

	; Cluster no = 0? assume its root dir and add 2
	!for .i,3,0 {
		lda fd_area + FD_start_cluster + .i, x
		bne +
	}

	lda root_dir_first_clus +1
	sta fd_area + FD_start_cluster +1, x
	lda root_dir_first_clus +0
	sta fd_area + FD_start_cluster +0, x

+	
	!for .i,3,0 {
		ldy #DIR_FileSize + .i
		lda (dirptr),y
		sta fd_area + FD_file_size + .i, x
	}

.end_open
	ply
	pla

	rts

.inc_blkptr
	; Increment blkptr by 32 bytes, jump to next dir entry
	clc
	lda sd_blkptr
	adc #32
	sta sd_blkptr
	bcc +
	inc sd_blkptr+1	
+	rts

; .fat_dir_filter
; 	jmp (fat_dir_filter_hook)

; .fat_dir_display
; 	jmp (fat_dir_display_hook)

; .fat_dir_action
; 	jmp (fat_dir_action_hook)
; default filter hook, skips long filenames and hidden files
; carry flag is set on match
; .fat_dir_filter_default
; 	cmp #$0f ; Long filename, skip this one
; 	beq +
; 	bit #$02 ; Hidden attribute set, skip
; 	bne +
; 	clc
; 	rts
; +	sec
; 	rts
; ; filter for open routine, skips long filenames and volume id
; .fat_dir_filter_open
; 	cmp #$0f ; Long filename, skip this one
; 	beq +
; 	bit #$08 ; is volume id, we cant open this. skip, too
; 	bne +
; 	clc
; 	rts
; +	sec
; 	rts


.fat_check_signature
	lda #$55
	cmp sd_blktarget + BS_Signature
	bne ++
	asl ; $aa
	cmp sd_blktarget + BS_Signature+1
	beq +
++	lda #fat_bad_block_signature
	sta errno
+	rts


.calc_blocks
	pha
	lda fd_area + FD_file_size+3,x
	lsr
	lda fd_area + FD_file_size+2,x
	ror
	lda fd_area + FD_file_size+1,x
	ror
	sta .blocks
	bcs +
	lda fd_area + FD_file_size+0,x
	beq ++
+	inc .blocks
++  pla
	rts


; calculate LBA address of first block from cluster number found in file descriptor entry
; file descriptor index must be in x
.calc_lba_addr
	pha
	phx
	
	lda fd_area + FD_start_cluster +3, x 

	
	cmp #$ff
	beq .file_not_open
	
	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
	sec
	lda fd_area + FD_start_cluster, x 
	sbc #$02
	sta tmp0 

	!for .i,1,3 {
		lda fd_area + FD_start_cluster + .i,x 
		sbc #$00
		sta tmp0 + .i
	}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster
-	clc
	!for .i,0,3 {
		lda tmp0 + .i
		adc lba_addr + .i
		sta lba_addr + .i	
	}
	dex
	bne -

.calc_end
	plx
	pla

	rts

.file_not_open
	lda #fat_file_not_open
	sta errno
	bra .calc_end

.inc_lba_address
	inc lba_addr + 0
	bne +
	sec
	lda lba_addr + 1
	adc #$00
	sta lba_addr + 1
	lda lba_addr + 2
	adc #$00
	sta lba_addr + 2
	bcc +
	inc lba_addr + 3
+
	rts











;---------------------------------------------------------------------
; Mount FAT32 on Partition 0
;---------------------------------------------------------------------
.fat_mount
	+save

	; set lba_addr to $00000000 since we want to read the bootsector
	!for .i,0,3 {
		stz lba_addr + .i	
	}
	

	+SetVector sd_blktarget, sd_blkptr

	jsr sd_read_block
	
	jsr .fat_check_signature

	lda errno
	beq +
	jmp .end_mount
+
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	lda #fat_invalid_partition_type
	sta errno
	jmp .end_mount

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta lba_addr,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	; +SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr	
	; Read FAT Volume ID at LBABegin and Check signature
	jsr sd_read_block

	jsr .fat_check_signature
	lda errno
	beq +
	jmp .end_mount
+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +
	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	lda #fat_invalid_sector_size
	sta errno
	jmp .end_mount
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	; add number of reserved sectors to fat_begin_lba. store in cluster_begin_lba
	clc
!for .i,0,1 {
	lda lba_addr + .i
	adc sd_blktarget + BPB_RsvdSecCnt + .i
	sta cluster_begin_lba + .i	
	sta fat_first_block + .i	
}
!for .i,2,3 {
	lda lba_addr + .i
	adc #$00
	sta cluster_begin_lba + .i
	sta fat_first_block + .i	
}

; 	+Copy fat_first_block, lba_addr,4
; 	+SetVector sd_blktarget, sd_blkptr

; 	jsr sd_read_block

; 	lda #$02
; 	asl
; 	asl
; 	tax
; -	lda sd_blktarget,x
; 	jsr hexout
; 	inx
; 	cpx #$0c 
; 	bne -
; ; -	jmp -

	; Number of FATs. Must be 2
	; lda sd_blktarget + BPB_NumFATs	
	; add sectors_per_fat * 2 to cluster_begin_lba

	ldy #$02
-	clc
	ldx #$00	
--	ror ; get carry flag back
	lda sd_blktarget + BPB_FATSz32,x ; sectors per fat
	adc cluster_begin_lba,x
	sta cluster_begin_lba,x
	inx
	rol ; save status register before cpx to save carry
	cpx #$04	
	bne --
	dey
	bne -

	; init file descriptor area
	jsr .fat_init_fdarea

	+Copy sd_blktarget + BPB_RootClus, root_dir_first_clus, 3

	; now we have the lba address of the first sector of the first cluster

.end_mount
	; jsr .sd_deselect_card
	+restore
	; rts

	; fall through to open_rootdir
	
.fat_open_rootdir
	; Open root dir
	+Copy root_dir_first_clus, fd_area + FD_start_cluster, 3
	jmp .calc_lba_addr
	rts

.fat_init_fdarea
;	jsr chrin
	ldx #$00
-	lda #$ff
	sta fd_area + FD_start_cluster +3 , x

	txa ; 2 cycles
	clc ; 2 cycles
	adc #$08 ; 2  cycles
	tax ; 2 cycles

	cpx #$80
	bne -

	rts

.fat_alloc_fd
	ldx #$08
	
-	lda fd_area + FD_start_cluster +3, x
	cmp #$ff
	beq +

	txa ; 2 cycles
	clc ; 2 cycles
	adc #$08 ; 2  cycles
	tax ; 2 cycles

	cpx #$80
	bne -

	; Too many open files, no free file descriptor found
	lda #fat_too_many_files
	sta errno
	
	
+
	rts

.fat_close
	lda #$ff
	sta fd_area + FD_start_cluster +3 , x
	rts

.convert_filename	
	ldx #$00
	ldy #$00
-	lda (filenameptr),y
	beq +
	cmp #'.' ; is it a dot
	bne ++   ; not a dot
	cpy #$02 ; is it at pos 0 or 1?
	bcc ++	 ; a dot at pos 0 or 1 is not the dot we are looking for
	
	; the dot we are looking for denotes the end of the filename and the begin of the filename extension
	; fill buffer with spaces until position $08 to continue writing to buffer at that pos.
	; then, read next char from input

	lda #' '
--	cpx #$08
	bcc .fill

	iny
	bne - ; replace with bra

++	
	+toUpper
	sta filename_buf,x
	inx
	iny
	bne - ; replace with bra
+	
	; are we at the end of the buffer? 
	; fill with spaces if not
	lda #' '
	cpx #$0b
	bcc .fill2
	rts
.fill
	sta filename_buf,x
	inx
	bne -- ; replace with bra
	
.fill2
-	sta filename_buf,x
  	inx
  	cpx #$0b
  	bne -
	rts


.fat_find_first

	ldy #$00
-	lda (filenameptr),y
	sta filename_buf,y
	beq +
	iny
	cpy #12
	bne -	
+

	+SetVector sd_blktarget, sd_blkptr
	ldx #$00
	jsr .calc_lba_addr
	
-	+SetVector sd_blktarget, dirptr	
	jsr sd_read_block
	dec sd_blkptr+1

--	
	lda (dirptr)
	bne +
	clc 				; first byte of dir entry is $00?
	rts   				; we are at the end, clear carry and return
+	
	ldy #DIR_Attr		; else check if long filename entry
	lda (dirptr),y 		; we are only going to filter those here (or maybe not?)
	cmp #$0f
	beq .fat_find_next

	jsr .match_ext
	bcc .fat_find_next

	jsr .match_name
	bcs +

.fat_find_next
	lda dirptr
	clc
	adc #$20
	sta dirptr
	bcc ++
	inc dirptr+1
++	

	lda dirptr+1 	; end of block?
	cmp #$06
	bcc --			; no, show entr
	; increment lba address to read next block 
	jsr .inc_lba_address	
	bra -

+	
	rts

.match_ext:

	ldy #DIR_Ext
	ldx #$00
-	lda filename_buf,x
	beq ++
	inx
	cmp #"."
	bra -

	bra .match

.match_name:
	ldy #DIR_Name
	ldx #$00
.match
-	
	lda filename_buf,x
	beq ++
	
	; a dot is ok if it
	cmp #'.'
	bne +
	cpx #$03 
	bcc +
	beq ++
+
	
	cmp #'*'
	beq ++

	cmp #'?'
	beq +
	cmp #'_'
	beq +

	cmp #$61
	bcc ++++
	and #!$20     ; make uppercase
++++	
	cmp (dirptr),y 
	bne +++

+	iny
	inx 
	bra -

++	sec
	rts

+++	clc
	rts 


; .fat_dir_scan
; 	; +save

; 	+SetVector sd_blktarget, sd_blkptr
; 	ldx #$00
; 	jsr .calc_lba_addr

	
; -	+SetVector sd_blktarget, dirptr	
; 	jsr sd_read_block
; 	dec sd_blkptr+1

; --	
; !ifndef bios {
; 	jsr .getkey
; 	cmp #$03 ; CTRL-C?
; 	beq +
; }

; 	lda #DIR_Name
; 	lda (dirptr)
; 	beq +

; 	cmp #$e5
; 	beq ++

; 	ldy #DIR_Attr
; 	lda (dirptr),y

; 	cmp #$0f 		; Long filename?
; 	beq ++			; skip

; 	ror 			; skip read only bit

; 	ror 			; Hidden attribute set?
; 	bcs ++			; skip

; 	ror 			; system attribute set?
; 	bcs ++			; skip

; 	ror 			; volume id?
; 	bcs ++			; skip


; 	jsr .fat_dir_action
; 	bcs +
; ++	
; ---	
; 	lda dirptr
; 	clc
; 	adc #$20
; 	sta dirptr
; 	bcc ++
; 	inc dirptr+1
; ++	

; 	lda dirptr+1 	; end of block?
; 	cmp #$06
; 	bcc --			; no, show entr





; 	; increment lba address to read next block 
; 	jsr .inc_lba_address	
; 	bra -
; +	
; 	; +restore
; 	rts