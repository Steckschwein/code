!src <sdcard.h.a>
!src <errors.h.a>


; *=$c000
FD_start_cluster = $00
FD_file_size = $08


!macro saveClusterNo .where {
 ;    ldy #DIR_FstClusHI +1
	; lda (sd_blkptr),y
	; sta .where +3

	; dey
	; lda (sd_blkptr),y
	; sta .where +2

	stz .where +3
	stz .where +2
	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta .where +1
	
	dey
	lda (sd_blkptr),y
	sta .where

} 

.blocks = tmp7

.fat_read

	jsr .calc_lba_addr

	; ldy #DIR_FileSize + 3
	; lda (sd_blkptr),y
	; lsr
	; ldy #DIR_FileSize + 2
	; lda (sd_blkptr),y
	; ror
	; ldy #DIR_FileSize + 1
	; lda (sd_blkptr),y
	; ror 

	; enough for files up to 65535 bytes


	lda fd_area + FD_file_size+1,x
	lsr
	sta .blocks
	bcs +
	lda fd_area + FD_file_size+0,x
	beq ++
+	inc .blocks
++  
	; jsr sd_read_multiblock
-	jsr sd_read_block

	inc sd_blkptr+1 ; 3 bytes, 6 cycles
	; inc sd_blkptr+1 ; 3 bytes, 6 cycles

	jsr .inc_lba_address
	dec .blocks
	bne -

	rts

.fat_open
	pha
	phy

	stz errno

	+SetVector .fat_dir_filter_open, 	fat_dir_filter_hook

	ldx #$00
	jsr .calc_lba_addr

	jsr .convert_filename

-	+SetVector sd_blktarget, sd_blkptr
	jsr sd_read_block
	dec sd_blkptr+1

--  ldy #DIR_Attr
	lda (sd_blkptr),y

	jsr .fat_dir_filter
	bcs +

	ldy #DIR_Name
	lda (sd_blkptr),y
	beq .fat_no_such_file ; end of dir 
	
	cmp #$e5 ; deleted file
	beq +   ; skip

---	
	lda (sd_blkptr),y
	cmp filename_buf,y
	bne +
	iny
	cpy #$0b 
	beq ++
	bra ---

+
	; Increment blkptr by 32 bytes, jump to next dir entry
	jsr .inc_blkptr

	; end of block?
	lda sd_blkptr+1
	cmp #06
	bne -- ; no

	; yes, increase lba_addr and go again
	; +SetVector sd_blktarget, sd_blkptr
	jsr .inc_lba_address
	bra -

.fat_no_such_file
	lda #fat_file_not_found
	sta errno
	bra .end_open

.fat_open_error
	lda #fat_open_error
	sta errno
	bra .end_open

; found
++	ldy #DIR_Attr
	lda (sd_blkptr),y
	bit #$10 ; Is a directory
    beq +

    ldx #$00 ; direcories always go to fd #0
    ; +saveClusterNo curr_dir_cluster_no
    ; bra .end_open 
    bra ++

+	bit #$20 ; Is file
	beq .fat_open_error

	jsr .fat_alloc_fd
	cpx #$ff
	beq .fat_open_error
	

++	stz fd_area + FD_start_cluster +3, x
	stz fd_area + FD_start_cluster +2, x
	
	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta fd_area + FD_start_cluster +1, x
	
	dey
	lda (sd_blkptr),y
	sta fd_area + FD_start_cluster +0, x

	; Cluster no = 0? assume its root dir and add 2
	lda fd_area + FD_start_cluster +1, x
	bne +
	lda fd_area + FD_start_cluster +0, x
	bne +

	lda root_dir_first_clus +1
	sta fd_area + FD_start_cluster +1, x
	lda root_dir_first_clus +0
	sta fd_area + FD_start_cluster +0, x

+	!for .i,3,0 {
		ldy #DIR_FileSize + .i
		lda (sd_blkptr),y
		sta fd_area + FD_file_size + .i, x
	}


.end_open
	ply
	pla
	rts

.inc_blkptr
	; Increment blkptr by 32 bytes, jump to next dir entry
	clc
	lda sd_blkptr
	adc #32
	sta sd_blkptr
	bcc +
	inc sd_blkptr+1	
+	rts

.fat_dir_filter
	jmp (fat_dir_filter_hook)

.fat_dir_display
	jmp (fat_dir_display_hook)

; default filter hook, skips long filenames and hidden files
; carry flag is set on match
.fat_dir_filter_default
	cmp #$0f ; Long filename, skip this one
	beq +
	bit #$02 ; Hidden attribute set, skip
	bne +
	clc
	rts
+	sec
	rts
; filter for open routine, skips long filenames and volume id
.fat_dir_filter_open
	cmp #$0f ; Long filename, skip this one
	beq +
	bit #$08 ; is volume id, we cant open this. skip, too
	bne +
	clc
	rts
+	sec
	rts



.fat_read_dir
	pha
	phy

	ldx #$00
	jsr .calc_lba_addr

-	jsr .getkey
	cmp #$04 ; CTRL-C?
	beq ++
	+SetVector sd_blktarget, sd_blkptr
	jsr sd_read_block
	dec sd_blkptr+1

--	ldy #DIR_Attr
	lda (sd_blkptr),y

	jsr .fat_dir_filter
	bcs +

    ldy #DIR_Name
	lda (sd_blkptr),y
	beq ++ ; end of dir 
	
	cmp #$e5 ; deleted file
	beq +   ; skip

	; jsr .fat_list_entry
	jsr .fat_dir_display

+	; Increment blkptr by 32 bytes, jump to next dir entry
	jsr .inc_blkptr
	; end of block?
	lda sd_blkptr+1
	cmp #06
	bne -- ; no

	; yes, increase lba_addr and go again
	jsr .inc_lba_address
	bra -

++	ply
	pla

	rts

.fat_check_signature
	lda sd_blktarget + BS_Signature
	cmp #$55
	bne ++
	lda sd_blktarget + BS_Signature+1
	cmp #$aa
	beq +
++	lda #fat_bad_block_signature
	sta errno
+	rts



; calculate LBA address of first block from cluster number found in file descriptor entry
; file descriptor index must be in x
.calc_lba_addr
	pha
	phx
	
	lda fd_area + FD_start_cluster +3, x 

	cmp #$ff
	beq .file_not_open
	

	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
	sec
	lda fd_area + FD_start_cluster, x 
	sbc #$02
	sta tmp0 

	!for .i,1,3 {
		lda fd_area + FD_start_cluster + .i,x 
		sbc #$00
		sta tmp0 + .i
	}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster
-	clc
	!for .i,0,3 {
		lda tmp0 + .i
		adc lba_addr + .i
		sta lba_addr + .i	
	}
	dex
	bne -

.calc_end
	plx
	pla

	rts

.file_not_open
	lda #fat_file_not_open
	sta errno
	bra .calc_end

.inc_lba_address
	inc lba_addr + 0
	bne +
	sec
	lda lba_addr + 1
	adc #$00
	sta lba_addr + 1
	lda lba_addr + 2
	adc #$00
	sta lba_addr + 2
	bcc +
	inc lba_addr + 3
+
	rts

.fat_list_entry_short
	pha
	jsr .print_filename
	+PrintChar ' '
	+PrintChar ' '
	dec .entries
	bne +	
	+ShellPrintString .crlf
	lda #$03
	sta .entries
+
	pla
	rts

.fat_list_entry
	pha
	jsr .print_filename
	+PrintChar ' '

	ldy #DIR_Attr
	lda (sd_blkptr),y

 	bit #$10 ; Is a directory
    beq +
    lda #'D'
    bra ++ 

+	bit #$04 ; Is system
	beq +
    lda #'S'
    bra ++
 
+	bit #$08 ; Is volume ID
	beq +
    lda #'V'
    bra ++ 
+	
	lda #'F'
++	+ShellPrint

	+PrintChar ' '
	ldy #DIR_FileSize + 1 +1
-	dey
	lda (sd_blkptr),y
	+ShellPrintHex
	cpy #DIR_FileSize
	bne -	

	+PrintChar ' '

	; day
	ldy #DIR_WrtDate 
	lda (sd_blkptr),y
	and #%00011111
	jsr .decoutz
	
	; +PrintChar '.'
	; month
	iny
	lda (sd_blkptr),y
	lsr
	tax
	dey
	lda (sd_blkptr),y
	ror
	lsr
	lsr
	lsr
	lsr
	
	jsr .decoutz
	
	; +PrintChar '.'
	; year
	txa
	clc 
	adc #80   	; add begin of msdos epoch (1980)
	cmp #100	
	bcc +		; greater than 100 (post-2000)
	sec 		; yes, substract 100
	sbc #100
+	jsr .decoutz ; there we go

	

	+PrintChar ' '

	ldy #DIR_WrtTime +1
	lda (sd_blkptr),y
	tax
	lsr
	lsr
	lsr
	
	jsr .decoutz

	+PrintChar ':'

	txa
	and #%00000111
	sta tmp1
	dey
	lda (sd_blkptr),y
	
	!for .i,0,4 {
		lsr tmp1
		ror 
	}	


	jsr .decoutz


	; Bits 11–15: Hours, valid value range 0–23 inclusive.
	
	+ShellPrintString .crlf
	pla
	rts	










;---------------------------------------------------------------------
; Mount FAT32 on Partition 0
;---------------------------------------------------------------------
.fat_mount
	+save

	; set lba_addr to $00000000 since we want to read the bootsector
	!for .i,0,3 {
		stz lba_addr + .i	
	}
	

	+SetVector sd_blktarget, sd_blkptr

	jsr sd_read_block
	
	jsr .fat_check_signature

	lda errno
	beq +
	jmp .end_mount
+
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	lda #fat_invalid_partition_type
	sta errno
	jmp .end_mount

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta lba_addr,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	; +SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr	
	; Read FAT Volume ID at LBABegin and Check signature
	jsr sd_read_block

	jsr .fat_check_signature
	lda errno
	beq +
	jmp .end_mount
+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +
	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	lda #fat_invalid_sector_size
	sta errno
	jmp .end_mount
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	; add number of reserved sectors to fat_begin_lba. store in cluster_begin_lba
	clc
!for .i,0,1 {
	lda lba_addr + .i
	adc sd_blktarget + BPB_RsvdSecCnt + .i
	sta cluster_begin_lba + .i	
}
!for .i,2,3 {
	lda lba_addr + .i
	adc #$00
	sta cluster_begin_lba + .i
}


	; Number of FATs. Must be 2
	; lda sd_blktarget + BPB_NumFATs	
	; add sectors_per_fat * 2 to cluster_begin_lba

	ldy #$02
-	clc
	ldx #$00	
--	ror ; get carry flag back
	lda sd_blktarget + BPB_FATSz32,x ; sectors per fat
	adc cluster_begin_lba,x
	sta cluster_begin_lba,x
	inx
	rol ; save status register before cpx to save carry
	cpx #$04	
	bne --
	dey
	bne -

	; init file descriptor area
	jsr .fat_init_fdarea

	+Copy sd_blktarget + BPB_RootClus, root_dir_first_clus, 3

	jsr .fat_open_rootdir

	; now we have the lba address of the first sector of the first cluster

.end_mount
	; jsr .sd_deselect_card
	+restore
	rts

	
.fat_open_rootdir
	; Open root dir
	+Copy root_dir_first_clus, fd_area + FD_start_cluster, 3
	rts

.fat_init_fdarea
;	jsr chrin
	ldx #$00
-	lda #$ff
	sta fd_area + FD_start_cluster +3 , x

	txa ; 2 cycles
	clc ; 2 cycles
	adc #$08 ; 2  cycles
	tax ; 2 cycles

	cpx #$80
	bne -

	rts

.fat_alloc_fd
	ldx #$08
	
-	lda fd_area + FD_start_cluster +3, x
	cmp #$ff
	beq +

	txa ; 2 cycles
	clc ; 2 cycles
	adc #$08 ; 2  cycles
	tax ; 2 cycles

	cpx #$80
	bne -

	; Too many open files, no free file descriptor found
	lda #fat_too_many_files
	sta errno
	
	
+
	rts

.fat_close
	lda #$ff
	sta fd_area + FD_start_cluster +3 , x
	rts

.print_filename
	ldy #DIR_Name
-	lda (sd_blkptr),y
	+ShellPrint	
	iny
	cpy #$0b
	bne -
	rts

.convert_filename	
	ldx #$00
	ldy #$00
-	lda (filenameptr),y
	beq +
	cmp #'.' ; is it a dot
	bne ++   ; not a dot
	cpy #$02 ; is it at pos 0 or 1?
	bcc ++	 ; a dot at pos 0 or 1 is not the dot we are looking for
	
	; the dot we are looking for denotes the end of the filename and the begin of the filename extension
	; fill buffer with spaces until position $08 to continue writing to buffer at that pos.
	; then, read next char from input

	lda #' '
--	cpx #$08
	bcc .fill

	iny
	bne - ; replace with bra

++	
	+toUpper
	sta filename_buf,x
	inx
	iny
	bne - ; replace with bra
+	
	; are we at the end of the buffer? 
	; fill with spaces if not
	lda #' '
	cpx #$0b
	bcc .fill2
	rts
.fill
	sta filename_buf,x
	inx
	bne -- ; replace with bra
	
.fill2
-	sta filename_buf,x
  	inx
  	cpx #$0b
  	bne -
	rts

!src <util.a>
