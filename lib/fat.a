; *=$c000
FD_start_cluster = $00
FD_file_size = $08



!macro saveClusterNo .where {
 ;    ldy #DIR_FstClusHI +1
	; lda (sd_blkptr),y
	; sta .where +3

	; dey
	; lda (sd_blkptr),y
	; sta .where +2

	stz .where +3
	stz .where +2
	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta .where +1
	
	dey
	lda (sd_blkptr),y
	sta .where

} 

.blocks = tmp7
; .rest   = tmp6

.fat_read

	tax
	jsr .calc_lba_addr

	; ldy #DIR_FileSize + 3
	; lda (sd_blkptr),y
	; lsr
	; ldy #DIR_FileSize + 2
	; lda (sd_blkptr),y
	; ror
	; ldy #DIR_FileSize + 1
	; lda (sd_blkptr),y
	; ror 

	; enough for files up to 65535 bytes


	lda fd_area + FD_file_size+1,x
	lsr
	sta .blocks
	bcs +
	lda fd_area + FD_file_size+0,x
	beq ++
+	inc .blocks
++  
	jsr .sd_read_multiblock
+	
	rts


.fat_read_singleblock
	jsr .sd_select_card
	jsr sd_param_init

	tax
	jsr .calc_lba_addr

	; ldy #DIR_FileSize + 3
	; lda (sd_blkptr),y
	; lsr
	; ldy #DIR_FileSize + 2
	; lda (sd_blkptr),y
	; ror
	; ldy #DIR_FileSize + 1
	; lda (sd_blkptr),y
	; ror 

	; enough for files up to 65535 bytes


	lda fd_area + FD_file_size+1,x
	lsr
	sta .blocks
	bcs +
	lda fd_area + FD_file_size+0,x
	beq ++
+	inc .blocks
++  
-	+SDBlockAddr lba_addr
	jsr sd_read_block


	; +ShellPrintChar '.'
	
	dec .blocks
	beq + ; zero, we're done

	; increase lba_addy by 1
	jsr .inc_lba_address

	inc sd_blkptr + 1
	inc sd_blkptr + 1
	bne ++
	inc sd_blkptr + 0
++

	; ready to read next block
	bra -

+	

	jsr .sd_deselect_card

	rts


.fat_open
	; pha
	phx
	phy

	stz fat_errno

	jsr .sd_select_card
	jsr sd_param_init

	+SetVector sd_blktarget, sd_blkptr

	lda #$00
	jsr .calc_lba_addr

-	+SDBlockAddr lba_addr

	jsr sd_read_block

--  ldy #DIR_Attr
	lda (sd_blkptr),y
	cmp #$0f ; Long filename, skip this one
	beq .open_next
	bit #$08 ; is volume id, we cant open this. skip, too
	bne .open_next


	ldy #DIR_Name
	lda (sd_blkptr),y
	beq .fat_no_such_file ; end of dir 
	
	cmp #$e5 ; deleted file
	beq .open_next   ; skip

	ldx #$00
.find
	lda .filename,x
	beq .found
	cmp (sd_blkptr),y
	bne .open_next
	inx
	iny
	bra .find

.open_next
	; Increment blkptr by 32 bytes, jump to next dir entry
	jsr .inc_blkptr

	; end of block?
	lda sd_blkptr+1
	cmp #06
	bne -- ; no

	; yes, increase lba_addr and go again
	+SetVector sd_blktarget, sd_blkptr
	jsr .inc_lba_address
	jmp -

.fat_no_such_file
	+ShellPrintString .fat_err_no_such_file
	inc fat_errno
	bra .end_open

.fat_open_error
	+ShellPrintString .fat_err_open
	inc fat_errno

	
.end_open
	jsr .sd_deselect_card
	ply
	plx
	; pla
	rts

.found
	jsr .print_filename
	+ShellPrintString .fat_ok

	ldy #DIR_Attr
	lda (sd_blkptr),y
	bit #$10 ; Is a directory
    beq +

    ldx #$00 ; direcories always go to fd #0
    ; +saveClusterNo curr_dir_cluster_no
    ; bra .end_open 
    bra ++

+	bit #$20 ; Is file
	beq .fat_open_error

	jsr .fat_alloc_fd
	cmp #$ff
	beq .fat_open_error
	tax

++	stz fd_area + FD_start_cluster +3, x
	stz fd_area + FD_start_cluster +2, x
	
	ldy #DIR_FstClusLO +1
	lda (sd_blkptr),y
	sta fd_area + FD_start_cluster +1, x
	
	dey
	lda (sd_blkptr),y
	sta fd_area + FD_start_cluster +0, x

	; Cluster no = 0? assume its root dir and add 2
	lda fd_area + FD_start_cluster +1, x
	bne +
	lda fd_area + FD_start_cluster +0, x
	bne +

	; lda #$02
	lda root_dir_first_clus +1
	sta fd_area + FD_start_cluster +1, x
	lda root_dir_first_clus +0
	sta fd_area + FD_start_cluster +0, x

+	!for .i,3,0 {
		ldy #DIR_FileSize + .i
		lda (sd_blkptr),y
		sta fd_area + FD_file_size + .i, x
	}


	txa
    bra .end_open

	

.inc_blkptr
	; Increment blkptr by 32 bytes, jump to next dir entry
	clc
	lda sd_blkptr
	adc #32
	sta sd_blkptr
	bcc +
	inc sd_blkptr+1	
+	rts


.fat_read_dir
	pha
	phy
	phx

	jsr sd_param_init
	jsr .sd_select_card

	lda #$00
	jsr .calc_lba_addr

	+SetVector sd_blktarget, sd_blkptr
-	+SDBlockAddr lba_addr
	jsr sd_read_block
	
	
--	ldy #DIR_Attr
	lda (sd_blkptr),y
	cmp #$0f ; Long filename, skip this one
	beq .nextentry
	bit #$02 ; Hidden attribute set, skip
	bne .nextentry

	tax
    ldy #DIR_Name
	lda (sd_blkptr),y
	beq .end ; end of dir 
	
	cmp #$e5 ; deleted file
	beq .nextentry   ; skip

	jsr .fat_list_entry

.nextentry
	; Increment blkptr by 32 bytes, jump to next dir entry
	jsr .inc_blkptr
	; end of block?
	lda sd_blkptr+1
	cmp #06
	bne -- ; no

	; yes, increase lba_addr and go again
	+SetVector sd_blktarget, sd_blkptr
	jsr .inc_lba_address
	jmp -

.end
	jsr .sd_deselect_card
	plx
	ply
	pla

	rts

.fat_check_signature
	; pha
	stz fat_errno

	lda sd_blktarget + BS_Signature
	cmp #$55
	bne ++
	lda sd_blktarget + BS_Signature+1
	cmp #$aa
	beq +
++	inc fat_errno
+	rts



.calc_lba_addr
	pha
	phx
	tax
	lda fd_area + FD_start_cluster +3, x 

	cmp #$ff
	beq .file_not_open
	

	; lba_addr = cluster_begin_lba + (cluster_number - 2) * sectors_per_cluster;
	sec
	lda fd_area + FD_start_cluster, x 
	sbc #$02
	sta tmp0 

	!for .i,1,3 {
		lda fd_area + FD_start_cluster + .i,x 
		sbc #$00
		sta tmp0 + .i
	}

	+Copy cluster_begin_lba, lba_addr, 3
	
	ldx sectors_per_cluster
-	clc
	!for .i,0,3 {
		lda tmp0 + .i
		adc lba_addr + .i
		sta lba_addr + .i	
	}
	dex
	bne -

.calc_end
	plx
	pla

	rts

.file_not_open
	+ShellPrintString .fat_err_file_not_open
	inc fat_errno
	bra .calc_end

.inc_lba_address
	inc lba_addr + 0
	bne +
	sec
	lda lba_addr + 1
	adc #$00
	sta lba_addr + 1
	lda lba_addr + 2
	adc #$00
	sta lba_addr + 2
	bcc +
	inc lba_addr + 3
+
	rts

.fat_list_entry
	pha
	jsr .print_filename
	+ShellPrintChar ' '

	ldy #DIR_Attr
	lda (sd_blkptr),y

 	bit #$10 ; Is a directory
    beq +
    lda #'D'
    bra ++ 

+	bit #$04 ; Is system
	beq +
    lda #'S'
    bra ++
 
+	bit #$08 ; Is volume ID
	beq +
    lda #'V'
    bra ++ 
+	
	lda #'F'
++	+ShellPrint

	+ShellPrintChar ' '
	ldy #DIR_FileSize + 1 +1
-	dey
	lda (sd_blkptr),y
	+ShellPrintHex
	cpy #DIR_FileSize
	bne -	

	+ShellPrintChar ' '

	; day
	ldy #DIR_WrtDate 
	lda (sd_blkptr),y
	and #%00011111
	+ShellPrintDec

	; +ShellPrintChar '.'
	; month
	iny
	lda (sd_blkptr),y
	lsr
	tax
	dey
	lda (sd_blkptr),y
	ror
	lsr
	lsr
	lsr
	lsr
	+ShellPrintDec
	
	; +ShellPrintChar '.'
	; year
	txa
	clc 
	adc #80   	; add begin of msdos epoch (1980)
	cmp #100	
	bcc +		; greater than 100 (post-2000)
	sec 		; yes, substract 100
	sbc #100
+	+ShellPrintDec  ; there we go

	

	+ShellPrintChar ' '

	ldy #DIR_WrtTime +1
	lda (sd_blkptr),y
	tax
	lsr
	lsr
	lsr
	+ShellPrintDec

	+ShellPrintChar ':'

	txa
	and #%00000111
	sta tmp1
	dey
	lda (sd_blkptr),y
	
	!for .i,0,4 {
		lsr tmp1
		ror 
	}	

	+ShellPrintDec


	; Bits 11–15: Hours, valid value range 0–23 inclusive.
	
	+ShellPrintString .crlf
	pla
	rts	




!src <sdcard.h.a>

.sd_select_card
   	pha
- 	lda via1portb	; wait for spi bus to become free
   	and #%01111110
   	cmp #$7e
   	bne -
	; set CS line to LOW
	lda #%01111100
	sta via1portb
	pla

	rts


.sd_deselect_card
       pha
       ; set CS line to HI
       lda #%01111110
       sta via1portb

       lda #$ff
       jsr spi_rw_byte
       
       pla
       rts

;---------------------------------------------------------------------
; Read multiple blocks from SD Card
;---------------------------------------------------------------------
.sd_read_multiblock
		+save

-		lda via1portb	; wait for spi bus to become free
		and #%01111110
		cmp #$7e
		bne -

		; set CS line to LOW
		lda #%01111100
		sta via1portb
       
		+SDBusyWait

       	; Send CMD18 command byte
       	lda #cmd18
       	jsr spi_rw_byte

       	; Send lba_addr in reverse order
		!for .i, 3, 0 {
			lda lba_addr + .i
			jsr spi_rw_byte	
		}

		; Send stopbit
       	lda #$01
       	jsr spi_rw_byte

       ; Wait for data token
-		
		lda #$ff
		jsr spi_rw_byte             
		cmp #$fe
		bne -

		ldy #$00
    
		lda via1portb   ; Port laden
		AND #$7e  		;    * Daten und Takt ausschalten
		TAX             ; aufheben
		ORA #$01
		sta tmp0
 
       ; read 256 bytes twice, increase blkptr in between
       !for .i,0,1 {
       		
--     		lda tmp0

			!for .j,0,7 {
			      STA via1portb ; Takt An 
			      STX via1portb ; Takt aus
			}
			lda via1sr
			sta (sd_blkptr),y

			iny
			bne --

			inc sd_blkptr+1		
		}
		
		lda tmp0
		; Read CRC bytes     
		!for .i,0,15 {
			sta via1portb 
			stx via1portb 
		}


		dec .blocks
		beq +
		jmp -
+
		
		+SDBusyWait

		; all blocks read, send cmd12 to end transmission
		; jsr sd_param_init
		lda #cmd12
		jsr sd_cmd

		+SDBusyWait

		; Deselect card 
		lda #%01111110
		sta via1portb

		lda #$ff
		jsr spi_rw_byte

		+restore
		rts

;---------------------------------------------------------------------
; Mount FAT32 on Partition 0
;---------------------------------------------------------------------
.fat_mount
	pha
	phx
	phy

	jsr .sd_select_card
	jsr sd_param_init

	+SetVector sd_blktarget, sd_blkptr

	jsr sd_read_block

	jsr .fat_check_signature

	lda fat_errno
	beq +
	+ShellPrintString .fat_err_signature
	jmp .end_mount

+	
	part0 = sd_blktarget + BS_Partition0

	lda part0 + PE_TypeCode
	cmp #$0b
	beq +
	cmp #$0c
	beq +

	; type code not $0b or $0c
	+ShellPrintString .fat_err_partition
	inc fat_errno
	jmp .end_mount

+
	ldx #$00
-	
	lda part0 + PE_LBABegin,x
	sta fat_begin_lba,x
	inx
	cpx #$04
	bne -


	; Write LBA start address to sd param buffer
	+SDBlockAddr fat_begin_lba

	+SetVector sd_blktarget, sd_blkptr
	; Read FAT Volume ID at LBABegin and Check signature
	jsr sd_read_block

	jsr .fat_check_signature
	lda fat_errno
	beq +
	+ShellPrintString .fat_err_signature
	jmp .end_mount

+
	; Bytes per Sector, must be 512 = $0200
	lda sd_blktarget + BPB_BytsPerSec
	bne +
	lda sd_blktarget + BPB_BytsPerSec + 1
	cmp #$02
	beq ++
+	+ShellPrintString .fat_err_bad_sect_size
	inc fat_errno
	jmp .end_mount
++
	; Sectors per Cluster. Valid: 1,2,4,8,16,32,64,128
	lda sd_blktarget + BPB_SecPerClus
	sta sectors_per_cluster
	
	; cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);

	; add number of reserved sectors to fat_begin_lba. store in cluster_begin_lba
	clc
!for .i,0,1 {
	lda fat_begin_lba + .i
	adc sd_blktarget + BPB_RsvdSecCnt + .i
	sta cluster_begin_lba + .i	
}
!for .i,2,3 {
	lda fat_begin_lba + .i
	adc #$00
	sta cluster_begin_lba + .i
}


	; Number of FATs. Must be 2
	; lda sd_blktarget + BPB_NumFATs	
	; add sectors_per_fat * 2 to cluster_begin_lba

	ldy #$02
-	clc
	ldx #$00	
--	ror ; get carry flag back
	lda sd_blktarget + BPB_FATSz32,x ; sectors per fat
	adc cluster_begin_lba,x
	sta cluster_begin_lba,x
	inx
	rol ; save status register before cpx to save carry
	cpx #$04	
	bne --
	dey
	bne -

	; init file descriptor area
	jsr .fat_init_fdarea

	+Copy sd_blktarget + BPB_RootClus, root_dir_first_clus, 3

	jsr .fat_open_rootdir

	; now we have the lba address of the first sector of the first cluster

.end_mount
	jsr .sd_deselect_card
	plx
	ply
	pla

	rts
.fat_open_rootdir
	; Open root dir
	+Copy root_dir_first_clus, fd_area + FD_start_cluster, 3
	rts

.fat_init_fdarea
;	jsr chrin
	ldx #$00
-	lda #$ff
	sta fd_area + FD_start_cluster +3 , x

	txa ; 2 cycles
	clc ; 2 cycles
	adc #$08 ; 2  cycles
	tax ; 2 cycles

	cpx #$80
	bne -

	rts

.fat_alloc_fd
	stz fat_errno
	ldx #$08
	
-	lda fd_area + FD_start_cluster +3, x
	cmp #$ff
	beq +

	txa ; 2 cycles
	clc ; 2 cycles
	adc #$08 ; 2  cycles
	tax ; 2 cycles

	cpx #$80
	bne -

	; Too many open files, no free file descriptor found
	+ShellPrintString .fat_err_too_many_open
	ldx #$ff
+	txa
	+ShellPrintHex
	rts

.fat_close
	phx
	tax 
	lda #$ff
	sta fd_area + FD_start_cluster +3 , x
	plx
	rts

.print_filename
	ldy #DIR_Name
-	lda (sd_blkptr),y
	+ShellPrint
	iny
	cpy #$0b
	bne -
	rts
;fat_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors;
;cluster_begin_lba = Partition_LBA_Begin + Number_of_Reserved_Sectors + (Number_of_FATs * Sectors_Per_FAT);
.fat_err_signature 		!text "bad block signature", $00
.fat_err_partition 		!text "invalid partition type", $00
.fat_err_bad_sect_size 	!text "sector size unsupported", $00
.fat_err_num_fats	  	!text "invalid number of FATs (!= 2)", $00
.fat_err_open			!text "open error",$00
.fat_err_no_such_file	!text "no such file or directory",$00
.fat_err_file_not_open	!text "file not open error",$00
.fat_err_too_many_open	!text "too many open files",$00

.fat_ok					!text " OK",$00
; .fat_loading		  	!text "Loading ",$00
; .fat_loading_done  		!text " done.",$00
; .crlf					!byte $0a,$0d,$00

;s
