*=$1000
!src "defs.h.a"
!src "bios.h.a"
	
status  	= $40
uart1		= $d300
uart1rxtx	= uart1+0
uart1ier	= uart1+0
uart1dll	= uart1+0
uart1dlh	= uart1+1
uart1iir	= uart1+2
uart1fcr	= uart1+2
uart1lcr	= uart1+3
uart1mcr	= uart1+4
uart1lsr	= uart1+5
uart1msr	= uart1+6
uart1scr	= uart1+7

DC_SW_RX  	= %10000000
DC_SW_TX  	= %01000000

main
	sei 
	jsr lcdclear

	lda #<uart_text
	sta msgptr
	
	lda #>uart_text
	sta msgptr+1
	
	jsr lcdstring

	jsr uart_init

;	jsr rxon		
;	jsr txoff
-
	lda 'x'
	jsr uart_tx
	lda 'X'
	jsr uart_tx

	jmp -
uart_text	!text "Uart: ", $00

dtroff
	lda uart1mcr
	and #%11111110
	sta uart1mcr
	lda #0
	sta uart1ier
	rts

dtron
	lda uart1mcr
	ora #%00000001
	sta uart1mcr
	lda #3
	sta uart1ier
	rts

rtsoff
	lda uart1mcr
	and #%11111101
	sta uart1mcr
	lda status,x
	ora #%00100000
	sta status,x
	rts

rtson
	lda uart1mcr
	ora #%00000010
	sta uart1mcr
	lda status,x
	and #%11011111
	sta status,x
	rts


rxon
	jsr rtson
	jsr dtron
    lda #DC_SW_RX
    bne o2a
txon
	jsr dtron
    lda #DC_SW_TX
o2a       
	ora status
    sta status
    bne ok

rxoff     
	lda status
    and #DC_SW_RX
    beq devoff
	jsr rtsoff
	; signal eof to software FIFO here
    lda status
    and #255-DC_SW_RX
    sta status
	jmp checkdtr

txoff  
    lda status
    and #DC_SW_TX
    beq devoff
	; signal close to software FIFO here
	lda status
	and #255-DC_SW_TX
	sta status,x
checkdtr
	and #DC_SW_TX+DC_SW_RX
	bne active
	jsr dtroff
active 	  
	jmp ok

ok        lda #0
          !byte $2c
devon     lda #<-9
          !byte $2c
devoff    lda #<-10
          !byte $2c
onotimp   lda #<-1
          cmp #1
          rts




uart_tx
	pha

-	lda uart1lsr
	cmp #$20
	bne -

	pla
	sta uart1rxtx
	
	rts

uart_rx
-	lda uart1lsr ; DATA READY bit set?
	and #$01
	beq - ; No

	lda uart1rxtx
 
	rts

uart_init
  	lda #0
    sta status

	; check if there's something like an UART at 
 	; all
	ldy uart1mcr
	lda #$10
	sta uart1mcr
	lda uart1msr
	and #$f0
	bne nodev
	lda #$1f
	sta uart1mcr
	lda uart1msr
	and #$f0
	cmp #$f0
	bne nodev
	sty uart1mcr

	; check if it has a scratchpad register 
        ; if not then it's plain 8250
	ldy uart1scr
	lda #%10101010
	sta uart1scr
	cmp uart1scr
	bne dev8250
	lsr
	sta uart1scr
	cmp uart1scr
	bne dev8250
	sty uart1scr


	; now check the 16xxx versions
	lda #1
	sta uart1fcr
	lda uart1iir 
	ldy #0
	sty uart1fcr
	asl
	bcc dev16450
	asl
	bcc dev16550
	; else dev16550A; currently only this one 
	; is supported


	; ok, we detected a 16550A, i.e. a chip 
	; with working FIFO
	lda #%10000000
	sta uart1lcr
;	ldx #14*2	; 9600 BAUD
;	lda divisor,x

;;	lda #6  ;19200 BAUD
	lda #48 ; 2400 baud 
	sta uart1dll	
;	lda divisor+1,x
	lda #$00
	sta uart1dlh
	lda #%00000011	; 8N1
	;lda #$1b	; 8N1

	sta uart1lcr

 	lda #7		; no FIFO enable and 
				; clear FIFOs, 
	sta uart1fcr	; trigger at 1 byte
	lda #0
	sta uart1ier	; polled mode (so far) 
	sta uart1mcr	; reset DTR, RTS
	and #%00001100			; keep OUT1, OUT2 values
	sta uart1mcr		; reset DTR, RTS
    clc

	lda #'Y'
	jsr lcdprint
	rts

nodev
	lda #'N'
	jsr lcdprint
	rts

dev8250
	lda #'8'
	jsr lcdprint
	rts

dev16450
	lda #'4'
	jsr lcdprint
	rts

dev16550
	lda #'5'
	jsr lcdprint
	rts

divisor	!word 	-1, 2304, 1536, 1047, 857, 768, 384 
		!word   192, 96, 64, 48, 32, 24, 16, 12, 6
!byte $00
!byte $00
!byte $00
!byte $00
!byte $00