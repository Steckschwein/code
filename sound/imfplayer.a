!source <defs.h.a>
!src <kernel.h.a>

!source <shell.h.a>
!source <bios.h.a>
!source <ym3812.h.a>
;!source <t9929.h.a>

!source <via.h.a>


CPU_CLOCK=clockspeed * 1000000


.delayh=tmp0
.delayl=tmp1
imfptr =tmp2

*=$1000

main	
	
	+copyPointer paramptr, filenameptr


	jsr open
 	phx

	lda errno
	beq +
	jmp .error
+

	+SetVector imf_data, sd_blkptr

	jsr read
	lda errno
	beq +
	jmp .error
+

	plx

	lda fd_area + FD_file_size + 0, x
	clc
	adc #<imf_data 
	sta imf_end

	lda fd_area + FD_file_size + 1, x
	adc #>imf_data
	sta imf_end+1

	jsr close


	; +Println
	sei
	bit	a_vreg

	jsr vdp_irq_off
	+SetVector	imf_data, adrl
	stz .delayl
	stz .delayh

	jsr .init_opl2

	sei
	; TODO - set clockspeed according to filename extension
	; 560 for imf
	; 700 for wlf

	; tempo is one of 280Hz (DN2), 560Hz (imf), 700Hz (.wlf) -> 4Mhz
	; 280 Hz --> 14280
	; 560 Hz -->  7140
	; 700 Hz -->  5714
	; tempo = 560	
	ldx #$02 ; select 560 Hz from table below
	lda .tempo+0,x
	; lda #<(CPU_CLOCK/tempo)
	sta via1t1cl  
	lda .tempo+1,x
	          ; set low byte of count
	; lda #>(CPU_CLOCK/tempo)
	sta via1t1ch            ; set high byte of count
 
	lda #%11000000
	sta via1ier             ; enable VIA1 T1 interrupts
	lda #%01000000
	sta via1acr             ; T1 continuous, PB7 disabled  
	
	+SetVector .irq, irqvec
	cli


; -	
; 	jsr .getkey
; 	cmp #'x'
; 	beq +
; 	jmp -

; +
; 	jsr .init_opl2
-	jmp -

.irq
	; +save
	
	bit via1ifr		; Interrupt from VIA?
	bpl +++

	bit via1t1cl	; Acknowledge timer interrupt by reading channel low
	

	; delay counter zero? 
	lda .delayh
	clc
	adc .delayl
	beq ++ 

	
+	
	; if no, 16bit decrement and exit routine
	+dec16 .delayh



	bra +++

++	

	ldy #$00
	lda (adrl),y
	sta opl_stat
	
	
	iny
	lda (adrl),y

	jsr opl2_delay_register

	sta opl_data		


	; jsr opl2_delay_data

	iny
	lda (adrl),y
	sta .delayh

	iny
	lda (adrl),y
	sta .delayl

	; song data end reached? then jump back to the beginning
	lda adrh
	cmp >imf_end
	bne +
	lda adrl
	cmp <imf_end
	bne +
	+SetVector	imf_data, adrl
	bra +++
+	


	;advance pointer by 4 bytes
	clc
	lda #$04
	adc adrl
	sta adrl
	bcc +
	inc adrh
+	

+++
	; +restore
	rti

	
; .play_imf
; 	+SetVector	imf_data, .adrl
; 	jsr	.song_length
	
; 	ldy	#$00
; --	lda	.imf_update_wait	;wait until flag cleared
; 	bne	--

; 	inc	tmp4
; 	lda	tmp4
; 	jsr	vdp_bgcolor
	
; 	jsr	.next_data			;next data block
; 	jsr .is_songend			;song end ? indicated by carry=1
; 	bcs	++
	
; 	lda	.regsel		;reg select
; 	sta	a_sound_rs
; 	+snd_nops
; 	lda	.regval		;reg data
; 	sta	a_sound_rw
	
; 	lda	.delayl		;delay > 0, wait until next update
; 	bne	+
; 	lda	.delayh
; 	bne	+
; -	tya				;y overflow?
; 	bne	--
; 	inc	.adrh
; 	lda	#'.'
; 	jsr	chrout
; 	jmp	--
; +	inc	.imf_update_wait	; trigger delay countdown
; 	bra	-
; ++	rts

; .song_length
; 	clc
; 	lda	#<.songend
; 	sbc	.adrl
; 	sta	.length_l
; 	lda	#>.songend
; 	sbc	.adrh
; 	sta	.length_h
; 	rts

; .is_songend
; 	phy
; 	ldy	#$00
; -	lda	(.adrl),y
; 	cmp	.songend,y
; 	bne	+
; 	iny	
; 	cpy	#$04
; 	bne	-
; 	sec
; 	bra	++
; +	clc
; ++	ply
; 	rts

; .next_data
; 	lda	(.adrl),y			
; 	sta	.regsel
; 	iny
; 	lda	(.adrl),y
; 	sta	.regval
; 	iny
; 	lda	(.adrl),y
; 	sta	.delayh
; 	iny
; 	lda	(.adrl),y
; 	sta	.delayl
; 	iny
; 	rts
		
; .load_imf
; 	ldx	#$00
; -	lda	adlib_id,x	;check ADLIB signature
; 	cmp	.imf_file,x
; 	bne	+
; 	inx
; 	cpx	#$05
; 	bne	-
; 	bra	.load_imf_normal
; +	lda	adlib_id+5	;check version != 1
; 	cmp	#$01
; 	bne	.load_imf_normal
; 	bra	.load_imf_with_header
; 	;TODO			;check file name
					
; +	clc				;no imf - clear carry
; 	rts
; .load_imf_normal
; .load_imf_with_header	
; 	sec
; 	rts

; .length_h 	!byte 0
; .length_l	!byte 0
; .imf_update_wait !byte 0
; adlib_id !text "ADLIB"

; !align 255,0

.error
	+PrintString .errtxt

.end	
	jmp (retvec)
.errtxt		!text "load error", $00
.tempo
	!16 (CPU_CLOCK/240)
	!16 (CPU_CLOCK/560)
	!16 (CPU_CLOCK/700)

!source <ym3812.a>
!source <t99xx.lib.a>
imf_end	!16 $ffff
imf_data